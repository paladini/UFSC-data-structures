atq.1 <beginning of page>
atq <-> display the jobs queued to run at specified times
atq [-c] [-n] [username]...
The atq utility displays the at jobs queued up for the current user. at(1) is a utility that allows users to execute com<hy>
mands at a later date. If invoked by a user with the solaris.jobs.admin authorization, atq will display all jobs in the
queue.
If no options are given, the jobs are displayed in chronological order of execution.
When an authorized user invokes atq without specifying username, the entire queue is displayed; when a username
is specified, only those jobs belonging to the named user are displayed.
The following options are supported:
-c Displays the queued jobs in the order they were created (that is, the time that the at command was given).
-n Displays only the total number of jobs currently in the queue.
/var/spool/cron/atjobs spool area for at jobs.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
at(1), atrm(1), auths(1), cron(1M), auth_attr(4), attributes(5)
aio_suspend.3c <beginning of page>
aio_suspend <-> wait for asynchronous I/O request
#include <aio.h>
int aio_suspend(const struct aiocb * const list[], int nent,
 const struct timespec *timeout);
The aio_suspend() function suspends the calling thread until at least one of the asynchronous I/O operations refer<hy>
enced by the list argument has completed, until a signal interrupts the function, or, if timeout is not NULL, until the
time interval specified by timeout has passed. If any of the aiocb structures in the list correspond to completed asyn<hy>
chronous I/O operations (that is, the error status for the operation is not equal to EINPROGRESS) at the time of the
call, the function returns without suspending the calling thread. The list argument is an array of pointers to asynchro<hy>
nous I/O control blocks. The nent argument indicates the number of elements in the array and is limited to
_AIO_LISTIO_MAX = 4096. Each aiocb structure pointed to will have been used in initiating an asynchronous
I/O request via aio_read(3C), aio_write(3C), or lio_listio(3C). This array may contain null pointers, which are ig<hy>
nored. If this array contains pointers that refer to aiocb structures that have not been used in submitting asynchro<hy>
nous I/O, the effect is undefined.
If the time interval indicated in the timespec structure pointed to by timeout passes before any of the I/O operations
referenced by list are completed, then aio_suspend() returns with an error.
If aio_suspend() returns after one or more asynchronous I/O operations have completed, it returns 0. Otherwise, it
returns <mi>1, and sets errno to indicate the error.
The application may determine which asynchronous I/O completed by scanning the associated error and return sta<hy>
tus using aio_error(3C) and aio_return(3C), respectively.
The aio_suspend() function will fail if:
EAGAIN No asynchronous I/O indicated in the list referenced by list completed in the time interval indicated by
timeout.
EINTR A signal interrupted the aio_suspend() function. Since each asynchronous I/O operation might provoke a
signal when it completes, this error return can be caused by the completion of one or more of the very I/O operations
being awaited.
EINVAL The nent argument is less than or equal to 0 or greater than _AIO_LISTIO_MAX, or the timespec struc<hy>
ture pointed to by timeout is not properly set because tv_sec is less than 0 or tv_nsec is either less than 0 or greater
than 10^9.
ENOMEM There is currently not enough available memory; the application can try again later.
ENOSYS The aio_suspend() function is not supported by the system.
The aio_suspend() function has a transitional interface for 64-bit file offsets. See lf64(5).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelAsync-Signal-Safe _ StandardSee standards(5).
aio.h(3HEAD), aio_fsync(3C), aio_read(3C), aio_return(3C), aio_write(3C), lio_listio(3C), signal.h(3HEAD),
attributes(5), lf64(5), standards(5)
Solaris 2.6 was the first release to support the Asynchronous Input and Output option. Prior to this release, this func<hy>
tion always returned <mi>1 and set errno to ENOSYS.
bart.1m <beginning of page>
bart <-> basic audit reporting tool
/usr/bin/bart create [ -n] [-R root_directory]
 [-r rules_file | -]
/usr/bin/bart create [-n] [-R root_directory] -I
 [file_name]...
/usr/bin/bart compare [-i attribute ] [-p]
 [-r rules_file | -] control-manifest test-manifest
bart(1M) is a tool that performs a file-level check of the software contents of a system.
You can also specify the files to track and the types of discrepancies to flag by means of a rules file, bart_rules. See
bart_rules(4).
The bart utility performs two basic functions:
bart create The manifest generator tool takes a file-level snapshot of a system. The output is a catalog of file at<hy>
tributes referred to as a manifest. See bart_manifest(4).
You can specify that the list of files be cataloged in three ways. Use bart create with no options, specify the files by
name on the command line, or create a rules file with directives that specify which the files to monitor. See
bart_rules(4).
By default, the manifest generator catalogs all attributes of all files in the root (/) file system. File systems mounted
on the root file system are cataloged only if they are of the same type as the root file system.
For example, /, /usr, and /opt are separate UFS file systems. /usr and /opt are mounted on /. Therefore, all three file
systems are cataloged. However, /tmp, also mounted on /, is not cataloged because it is a TMPFS file system.
Mounted CD-ROMs are not cataloged since they are HSFS file systems.
bart compare The report tool compares two manifests. The output is a list of per-file attribute discrepancies. These
discrepancies are the differences between two manifests: a control manifest and a test manifest.
A discrepancy is a change to any attribute for a given file cataloged by both manifests. A new file or a deleted file in
a manifest is reported as a discrepancy.
The reporting mechanism provides two types of output: verbose and programmatic. Verbose output is localized and
presented on multiple lines, while programmatic output is more easily parsable by other programs. See OUTPUT.
By default, the report tool generates verbose output where all discrepancies are reported except for modified directo<hy>
ry timestamps (dirmtime attribute).
To ensure consistent and accurate comparison results, control-manifest and test-manifest must be built with the same
rules file.
Use the rules file to ignore specified files or subtrees when you generate a manifest or compare two manifests. Users
can compare manifests from different perspectives by re-running the bart compare command with different rules
files.
The following options are supported:
-i attribute ... Specify the file attributes to be ignored globally. Specify attributes as a comma separated list.
This option produces the same behavior as supplying the file attributes to a global IGNORE keyword in the rules
file. See bart_rules(4).
-I [file_name...] Specify the input list of files. The file list can be specified at the command line or read from stan<hy>
dard input.
<beginning of page>
-n Prevent computation of content signatures for all regular files in the file list.
-p Display manifest comparison output in ``programmatic mode,'' which is suitable for programmatic parsing. The
output is not localized.
-r rules_file Use rules_file to specify which files and directories to catalog, and to define which file attribute discrep<hy>
ancies to flag. If rules_file is -, then the rules are read from standard input. See bart_rules(4) for the definition of the
syntax.
-R root_directory Specify the root directory for the manifest. All paths specified by the rules, and all paths reported
in the manifest, are relative to root_directory. Note -
The root file system of any non-global zones must not be referenced with the -R option. Doing so might damage the
global zone's file system, might compromise the security of the global zone, and might damage the non-global
zone's file system. See zones(5).
bart allows quoting of operands. This is particularly important for white-space appearing in subtree and subtree
modifier specifications.
The following operands are supported:
control-manifest Specify the manifest created by bart create on the control system.
test-manifest Specify the manifest created by bart create on the test system.
The bart create and bart compare commands write output to standard output, and write error messages to standard
error.
The bart create command generates a system manifest. See bart_manifest(4).
When the bart compare command compares two system manifests, it generates a list of file differences. By default,
the comparison output is localized. However, if the -p option is specified, the output is generated in a form that is
suitable for programmatic manipulation.
 filename
 attribute control:xxxx test:yyyy
filename Name of the file that differs between control-manifest and test-manifest. For file names that contain embed<hy>
ded whitespace or newline characters, see bart_manifest(4).
attribute The name of the file attribute that differs between the manifests that are compared. xxxx is the attribute val<hy>
ue from control-manifest, and yyyy is the attribute value from test-manifest. When discrepancies for multiple at<hy>
tributes occur for the same file, each difference is noted on a separate line.
The following attributes are supported:
acl ACL attributes for the file. For a file with ACL attributes, this field contains the output from acltotext().
all All attributes.
contents Checksum value of the file. This attribute is only specified for regular files. If you turn off context checking
or if checksums cannot be computed, the value of this field is -.
<beginning of page>
dest Destination of a symbolic link.
devnode Value of the device node. This attribute is for character device files and block device files only.
dirmtime Modification time in seconds since 00:00:00 UTC, January 1, 1970 for directories.
gid Numerical group ID of the owner of this entry.
lnmtime Creation time for links.
mode Octal number that represents the permissions of the file.
mtime Modification time in seconds since 00:00:00 UTC, January 1, 1970 for files.
size File size in bytes.
type Type of file.
uid Numerical user ID of the owner of this entry.
The following default output shows the attribute differences for the /etc/passwd file. The output indicates that the
size, mtime, and contents attributes have changed.
 /etc/passwd:
  size control:74 test:81
  mtime control:3c165879 test:3c165979
  contents control:daca28ae0de97afd7a6b91fde8d57afa
 test:84b2b32c4165887355317207b48a6ec7
 filename attribute control-val test-val [attribute control-val test-val]*
filename
Same as filename in the default format.
attribute control-val test-val
A description of the file attributes that differ between the control and test manifests for each file. Each entry includes
the attribute value from each manifest. See bart_manifest(4) for the definition of the attributes.
Each line of the programmatic output describes all attribute differences for a single file.
The following programmatic output shows the attribute differences for the /etc/passwd file. The output indicates that
the size, mtime, and contents attributes have changed.
 /etc/passwd size 74 81 mtime 3c165879 3c165979
 contents daca28ae0de97afd7a6b91fde8d57afa 84b2b32c4165887355317207b48a6ec7
<beginning of page>
The manifest generator returns the following exit values:
0 Success
1 Non-fatal error when processing files; for example, permission problems
>1 Fatal error; for example, invalid command-line options
The report tool returns the following exit values:
0 No discrepancies reported
1 Discrepancies found
>1 Fatal error executing comparison
Example 1 Creating a Default Manifest Without Computing Checksums
The following command line creates a default manifest, which consists of all files in the / file system. The -n option
prevents computation of checksums, which causes the manifest to be generated more quickly.
 bart create -n
Example 2 Creating a Manifest for a Specified Subtree
The following command line creates a manifest that contains all files in the /home/nickiso subtree.
 bart create -R /home/nickiso
Example 3 Creating a Manifest by Using Standard Input
The following command line uses output from the find(1) command to generate the list of files to be cataloged. The
find output is used as input to the bart create command that specifies the -I option.
 find /home/nickiso -print | bart create -I
Example 4 Creating a Manifest by Using a Rules File
The following command line uses a rules file, rules, to specify the files to be cataloged.
 bart create -r rules
Example 5 Comparing Two Manifests and Generating Programmatic Output
The following command line compares two manifests and produces output suitable for parsing by a program.
 bart compare -p manifest1 manifest2
Example 6 Comparing Two Manifests and Specifying Attributes to Ignore
The following command line compares two manifests. The dirmtime, lnmtime, and mtime attributes are not com<hy>
<beginning of page>
pared.
 bart compare -i dirmtime,lnmtime,mtime manifest1 manifest2
Example 7 Comparing Two Manifests by Using a Rules File
The following command line uses a rules file, rules, to compare two manifests.
 bart compare -r rules manifest1 manifest2
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wbart _ Interface StabilityEvolving
cksum(1), digest(1), find(1), bart_manifest(4), bart_rules(4), attributes(5)
The file attributes of certain system libraries can be temporarily altered by the system as it boots. To avoid triggering
false warnings, you should compare manifests only if they were both created with the system in the same state; that
is, if both were created in single-user or both in multi-user.
acos.3m <beginning of page>
acos, acosf, acosl <-> arc cosine functions
c99 [ flag... ] file... -lm [ library... ]
#include <math.h>
double acos(double x);
float acosf(float x);
long double acosl(long double x);
These functions compute the principal value of the arc cosine of x. The value of x should be in the range [<mi>1,1].
Upon successful completion, these functions return the arc cosine of x in the range [0, <*p> ] radians.
For finite values of x not in the range [<mi>1,1], a domain error occurs and NaN is returned.
If x is NaN, NaN is returned.
If x is +1, +0 is returned.
If x is <+->Inf, a domain error occurs and NaN is returned.
For exceptional cases, matherr(3M) tabulates the values to be returned by acos() as specified by SVID3 and XPG3.
These functions will fail if:
Domain Error The x argument is finite and not in the range [-1,1], or is <+->Inf.
If the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, the invalid floating-point ex<hy>
ception is raised.
The acos() function sets errno to EDOM if x is not <+->Inf or NaN and is not in the range [<mi>1,1].
An application wanting to check for exceptions should call feclearexcept(FE_ALL_EXCEPT) before calling these
functions. On return, if fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDER<hy>
FLOW) is non-zero, an exception has been raised. An application should either examine the return value or check
the floating point exception flags to detect exceptions.
An application can also set errno to 0 before calling acos(). On return, if errno is non-zero, an error has occurred.
The acosf() and acosl() functions do not set errno.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
cos(3M), feclearexcept(3M), fetestexcept(3M), isnan(3M), math.h(3HEAD), matherr(3M), attributes(5), stan<hy>
dards(5)
asinh.3m <beginning of page>
asinh, asinhf, asinhl <-> inverse hyperbolic sine functions
cc [ flag... ] file... -lm [ library... ]
#include <math.h>
double asinh(double x);
float asinhf(float x);
long double asinhl(long double x);
These functions compute the inverse hyperbolic sine of their argument x.
Upon successful completion, these functions return the inverse hyperbolic sine of their argument.
If x is NaN, NaN is returned.
If x is <+->0 or <+->Inf, x is returned.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
math.h(3HEAD), sinh(3M), attributes(5), standards(5)
audit_class.4 <beginning of page>
audit_class <-> audit class definitions
/etc/security/audit_class
/etc/security/audit_class is a user-configurable ASCII system file that stores class definitions used in the audit sys<hy>
tem. Audit events in audit_event(4) are mapped to one or more of the defined audit classes. audit_event can be up<hy>
dated in conjunction with changes to audit_class. See audit_control(4) and audit_user(4) for information about
changing the preselection of audit classes in the audit system. Programs can use the getauclassent(3BSM) routines
to access audit class information.
The fields for each class entry are separated by colons. Each class entry is a bitmap and is separated from each other
by a newline.
Each entry in the audit_class file has the form:
 mask:name:description
The fields are defined as follows:
mask class mask
name class name
description class description
Each class is represented as a bit in the class mask which is an unsigned integer. Thus, there are 32 different classes
available. Meta-classes can also be defined. These are supersets composed of multiple base classes, and thus will
have more than 1 bit in its mask. See Examples. Two special meta-classes are also pre-defined: all, and no.
all Represents a conjunction of all allowed classes, and is provided as a shorthand method of specifying all classes.
no Is the invalid class, and any event mapped solely to this class will not be audited. Turning auditing on to the all
meta class will not cause events mapped solely to the no class to be written to the audit trail. This class is also used
to map obsolete events which are no longer generated. Obsolete events are retained to process old audit trails files.
Example 1 Using an audit_class File
The following is an example of an audit_class file:
 0x00000000:no:invalid class
 0x00000001:fr:file read
 0x00000002:fw:file write
 0x00000004:fa:file attribute access
 0x00000008:fm:file attribute modify
 0x00000010:fc:file create
 0x00000020:fd:file delete
 0x00000040:cl:file close
 0x00000100:nt:network
 0x00000200:ip:ipc
 0x00000400:na:non-attribute
 0x00001000:lo:login or logout
 0x00004000:ap:application
 0x000f0000:ad:old administrative (meta-class)
 0x00070000:am:administrative (meta-class)
 0x00010000:ss:change system state
 0x00020000:as:system-wide administration
 0x00040000:ua:user administration
 0x00080000:aa:audit utilization
 0x00300000:pc:process (meta-class)
 0x00100000:ps:process start/stop
<beginning of page>
 0x00200000:pm:process modify
 0x20000000:io:ioctl
 0x40000000:ex:exec
 0x80000000:ot:other
 0xffffffff:all:all classes (meta-class)
/etc/security/audit_class
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability
See below.
The file format stability is Committed. The file content is Uncommitted.
bsmconv(1M), au_preselect(3BSM), getauclassent(3BSM), audit_control(4), audit_event(4), audit_user(4), at<hy>
tributes(5)
Part VII, Solaris Auditing, in System Administration Guide: Security Services
It is possible to deliberately turn on the no class in the kernel, in which case the audit trail will be flooded with
records for the audit event AUE_NULL.
This functionality is available only if Solaris Auditing has been enabled. See bsmconv(1M) for more information.
biowait.9f <beginning of page>
biowait <-> suspend processes pending completion of block I/O
#include <sys/types.h>
#include <sys/buf.h>
int biowait(struct buf *bp);
Architecture independent level 1 (DDI/DKI).
bp Pointer to the buf structure describing the transfer.
Drivers allocating their own buf structures with getrbuf(9F) can use the biowait() function to suspend the current
thread and wait for completion of the transfer.
Drivers must call biodone(9F) when the transfer is complete to notify the thread blocked by biowait(). biodone() is
usually called in the interrupt routine.
0 Upon success
non-zero Upon I/O failure. biowait() calls geterror(9F) to retrieve the error number which it returns.
biowait() can be called from user context only.
biodone(9F), geterror(9F), getrbuf(9F), buf(9S)
Writing Device Drivers
acct.h.3head <beginning of page>
acct.h, acct <-> per-process accounting file format
#include <sys/types.h>
#include <sys/acct.h>
Files produced as a result of calling acct(2) have records in the form defined by <sys/acct.h>, whose contents are:
 typedef ushort_t comp_t; /* pseudo "floating point"
  representation */
  /* 3 bit base-8 exponent in the high */
  /* order bits, and a 13-bit fraction */
  /* in the low order bits. */
 struct acct
 {
  char ac_flag; /* Accounting flag */
  char ac_stat; /* Exit status */
  uid_t ac_uid; /* Accounting user ID */
  gid_t ac_gid; /* Accounting group ID */
  dev_t ac_tty; /* control tty */
  time_t ac_btime; /* Beginning time */
  comp_t ac_utime; /* accounting user time in clock ticks */
  comp_t ac_stime; /* accounting system time in clock ticks */
  comp_t ac_etime; /* accounting total elapsed time in clock
  ticks */
  comp_t ac_mem; /* memory usage in clicks (pages) */
  comp_t ac_io; /* chars transferred by read/write */
  comp_t ac_rw; /* number of block reads/writes */
  char ac_comm[8]; /* command name */
 };
 /*
  * Accounting Flags
  */
 #define AFORK 01 /* has executed fork, but no exec */
 #define ASU 02 /* used super-user privileges */
 #define ACCTF 0300 /* record type */
 #define AEXPND 040 /* Expanded Record Type <mi> default */
In ac_flag, the AFORK flag is turned on by each fork and turned off by an exec. The ac_comm field is inherited
from the parent process and is reset by any exec. Each time the system charges the process with a clock tick, it also
adds to ac_mem the current process size, computed as follows:
(data size) + (text size) / (number of in-core processes using text)
The value of ac_mem/(ac_stime+ac_utime) can be viewed as an approximation to the mean process size, as mod<hy>
ified by text sharing.
The structure tacct, (which resides with the source files of the accounting commands), represents a summary of ac<hy>
counting statistics for the user id ta_uid. This structure is used by the accounting commands to report statistics
based on user id.
 /*
  * total accounting (for acct period), also for day
  */
 struct tacct {
  uid_t ta_uid; /* user id */
  char ta_name[8]; /* login name */
  float ta_cpu[2]; /* cum. cpu time in minutes, */
  /* p/np (prime/non-prime time) */
  float ta_kcore[2]; /* cum. kcore-minutes, p/np */
  float ta_con[2]; /* cum. connect time in minutes,
  p/np */
  float ta_du; /* cum. disk usage (blocks)*/
<beginning of page>
  long ta_pc; /* count of processes */
  unsigned short ta_sc; /* count of login sessions */
  unsigned short ta_dc; /* count of disk samples */
  unsigned short ta_fee; /* fee for special services */
 };
The ta_cpu, ta_kcore, and ta_con members contain usage information pertaining to prime time and non-prime time
hours. The first element in each array represents the time the resource was used during prime time hours. The sec<hy>
ond element in each array represents the time the resource was used during non-prime time hours. Prime time and
non-prime time hours may be set in the holidays file (see holidays(4)).
The ta_kcore member is a cumulative measure of the amount of memory used over the accounting period by pro<hy>
cesses owned by the user with uid ta_uid. The amount shown represents kilobyte segments of memory used, per
minute.
The ta_con member represents the amount of time the user was logged in to the system.
/etc/acct/holidays prime/non-prime time table
acctcom(1), acct(1M), acctcon(1M), acctmerg(1M), acctprc(1M), acctsh(1M), prtacct(1M), runacct(1M),
shutacct(1M), acct(2), exec(2), fork(2)
The ac_mem value for a short-lived command gives little information about the actual size of the command, because
ac_mem may be incremented while a different command (for example, the shell) is being executed by the process.
add_wchnstr.3xcurses <beginning of page>
add_wchnstr, add_wchstr, mvadd_wchnstr, mvadd_wchstr, mvwadd_wchnstr, mvwadd_wchstr, wadd_wchnstr,
wadd_wchstr <-> copy a string of complex characters (with renditions) to a window
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library ... ]
#include <curses.h>
int add_wchnstr(const cchar_t *wchstr, int n);
int add_wchstr(const cchar_t *wchstr);
int mvadd_wchnstr(int y, int x, const cchar_t *wchstr, int n);
int mvadd_wchstr(int y, int x, const cchar_t *wchstr);
int mvwadd_wchnstr(WINDOW *win, int y, int x,
 const cchar_t *wchstr, int n);
int mvwadd_wchstr(WINDOW *win, int y, int x, const cchar_t *wchstr);
int wadd_wchstr(WINDOW *win, const cchar_t *wchstr);
int wadd_wchnstr(WINDOW *win, const cchar_t *wchstr, int n);
The add_wchstr() function copies the string of cchar_t characters to the stdscr window at the current cursor posi<hy>
tion. The mvadd_wchstr() and mvwadd_wchstr() functions copy the string to the starting position indicated by
the x (column) and y (row) parameters (the former to the stdscr window; the latter to window win). The
wadd_wchstr() is identical to add_wchstr(), but writes to the window specified by win.
The add_wchnstr(), wadd_wchnstr(), mvadd_wchnstr(), and mvwadd_wchnstr() functions write n characters to
the window, or as many as will fit on the line. If n is less than 0, the entire string is written, or as much of it as fits
on the line. The former two functions place the string at the current cursor position; the latter two commands use
the position specified by the x and y parameters.
These functions differ from the addwstr(3XCURSES) set of functions in two important respects. First, these func<hy>
tions do not advance the cursor after writing the string to the window. Second, the current window rendition (that is,
the combination of attributes and color pair) is not combined with the character; only those attributes that are al<hy>
ready part of the cchar_t character are used.
wchstr Is a pointer to the cchar_t string to be copied to the window.
n Is the maximum number of characters to be copied from wchstr. If n is less than 0, the entire string is written or
as much of it as fits on the line.
y Is the y (row) coordinate of the starting position of wchstr in the window.
x Is the x (column) coordinate of the starting position of wchstr in the window.
win Is a pointer to the window to which the string is to be copied.
On success, these functions return OK. Otherwise, they return ERR.
None.
See attributes(5) for descriptions of the following attributes:
<beginning of page>
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
addnwstr(3XCURSES), add_wch(3XCURSES), attr_off(3XCURSES), libcurses(3XCURSES), attributes(5),
standards(5)
appcert.1 <beginning of page>
appcert <-> examine application-level products for unstable use of Solaris interfaces
appcert [-h] [-n] [-f infile] [-w working_dir] [-B] [-L]
 [-S] {obj | dir}...
The appcert utility examines an application's conformance to the Solaris Application Binary Interface (ABI). The
Solaris ABI defines the runtime library interfaces in Solaris that are safe and stable for application use. More specifi<hy>
cally, appcert identifies any dependencies on unstable runtime interfaces, as well as certain other risks that could
cause the product to fail to work on a subsequent release of Solaris.
appcert checks for: <bu> Private symbol usage in Solaris libraries. These are private symbols, that is, functions or data,
that are not intended for developer consumption. They are interfaces that Solaris libraries use to call one another.
These symbols might change their semantic behavior or even disappear altogether (so-called demoted symbols), so
it is a good practice to make sure your application does not depend upon any of them. <bu> Static linking. In particular,
this refers to static linking of archives libc.a, libsocket.a, and libnsl.a, that is, instead of dynamically linking the
corresponding shared object .so's. Because the semantics of private symbol calls from one Solaris library to another
can change from one release to another, it is not a good practice to hardwire library code into your binary objects. <bu>
Unbound symbols. These are library symbols (that is, functions or data) that the dynamic linker could not resolve
when appcert was run. This might be an environment problem (for example, LD_LIBRARY_PATH) or a build
problem (for example, not specifying -llib and/or -z defs with compiling). They are flagged to point these problems
out and in case a more serious problem is indicated.
An entire product can be readily examined by appcert (that is, if the product is a collection of many programs and
supporting shared objects) by referring appcert to the directories where the product is installed.
To perform its task, appcert constructs a profile of interface dependencies for each object file within the product
(whether an executable object or shared object), to determine all the Solaris system interfaces that are depended up<hy>
on. (Notice that appcert uses the Solaris runtime linker to make this determination.) These dependency profiles are
then compared to a definition of the Solaris ABI to identify any interfaces that are Private (unsafe and unstable for
application-level use).
appcert generates a simple roll-up report that indicates which of the product's components, if any, had liabilities and
what those liabilities were. The report aids developers who are examining their product's release-to-release stability.
Notice that appcert produces complete interface dependency information, both the Public (safe and stable) Solaris
interfaces and the Private (non-ABI) interfaces. This information can also be examined for each product component,
if you want.
IMPORTANT: appcert must run in the same environment in which the application being checked runs. See NOTES.
The following options are supported:
-B If appcert is run in batch mode, the output report will contain one line per binary, beginning with PASS if no
problems were detected for the binary, FAIL if any problems were found, or INC if the binary could not be com<hy>
pletely checked. Do not interpret these labels too literally. For example, PASS just means that none of the appcert
warnings were triggered. These strings are flush left and so can be selected via grep ^FAIL ..., and so forth.
-f infile Specifies the file infile that contains a list of files (one per line) to check. This list is appended to the list de<hy>
termined from the command line operands (see OPERANDS below).
-h Prints out the usage information.
-L appcert examines your product for the presence of shared objects. If it finds some, it appends the directories they
reside in to LD_LIBRARY_PATH. Use this flag to prevent appcert from doing this.
-n When searching directories for binaries to check, this option does not follow symbolic links. See find(1).
-S Appends Solaris library directories (that is, /usr/openwin/lib:/usr/dt/lib) to LD_LIBRARY_PATH.
<beginning of page>
-w working_dir Identifies the directory in which to run the library components and create temporary files (default is
/tmp).
The following operands are supported:
{obj | dir} ... A complete list of objects and/or directories that contain the objects constituting the product to be
checked. appcert recursively searches directories looking for object files; non-object files are ignored.
The following exit values are returned:
0 appcert ran successfully and found no potential binary stability problems.
1 appcert failed to run successfully.
2 Some of the objects checked have potential binary stability problems.
3 No binary objects were located that could be checked.
If the object file to be examined depends on libraries, those dependencies must be recorded in it (by using the com<hy>
piler's -l switch).
If the object file to be examined depends on other shared libraries, those libraries must be accessible via LD_LI<hy>
BRARY_PATH or RUNPATH when appcert is run.
To check 64-bit applications, the machine must be running the 64-bit Solaris kernel. See isalist(1). Also, the checks
for static linking are currently not done on 64-bit applications.
appcert cannot examine: <bu> Object files that are completely or partially statically linked.
 Completely statically linked objects are reported as unstable.
<bu> Executable files that do not have execute permission set.
 These are skipped. Shared objects without execute permission are not skipped.
<bu> Object files that are setuid root.
 Due to limitations in ldd(1), these are skipped. Copy and/or change the permissions to check them.
<bu> Non-ELF file executables such as shell scripts. <bu> Non-C language interfaces to Solaris; for example, C++ and Ja<hy>
va.
 The code itself need not be in C as long as the calls to Solaris libaries are in C.
appcert records its findings in the following files in the working directory (/tmp/appcert.????? by default):
Index A mapping between checked binaries and the subdirectory in the working directory in which the output spe<hy>
cific to that binary can be found.
Report A copy of the rollup report that was displayed on stdout when appcert was run.
Skipped A list of binaries that appcert was asked to check but had to skip, along with a brief reason why each was
skipped.
In addition, there is per-object information in the subdirectories under appcert.?????/objects/, in the following files:
check.demoted_symbols A list of symbols suspected to be demoted Solaris symbols.
check.dynamic.private A list of private Solaris symbols to which the object makes direct bindings.
check.dynamic.public A list of public Solaris symbols to which the object makes direct bindings.
<beginning of page>
check.dynamic.unbound A list of symbols not bound by the dynamic linker when ldd -r was run. For convenience,
ldd output lines containing file not found are also included.
summary.dynamic A pretty-printed summary of dynamic bindings for the objects examined, including tables of
Public and Private symbols used from each Solaris library.
Other files are temporary files used internally by appcert.
Private symbols are functions or data variables in a Solaris library that are not intended for developer or external use.
These symbols are interfaces that the Solaris libraries use to call and communicate with one another. They are
marked in pvs(1) output with the symbol version name SUNWprivate.
Private symbols can change their semantic behavior or even disappear altogether (demoted or deprecated symbols),
so your application should not depend upon any of them.
Demoted symbols are functions or data variables in a Solaris library that were once private to that library and have
been removed (or possibly scoped local to the library) in a later Solaris release. If your application directly calls one
of these demoted symbols, it will fail to run (relocation error) on the release in which the symbol was removed and
releases thereafter.
In some rare cases, a demoted symbol will return in a later release, but nevertheless there are still some releases on
which the application will not run.
Sun Microsystems Inc. performed most of the library scoping in the transition from Solaris 2.5.1 to 2.6. This action
was done to increase binary stability. By making these completely internal interfaces invisible (that is, they cannot
be dynamically linked against), a developer cannot accidentally or intentionally call these interfaces. For more infor<hy>
mation, see the Linker and Libraries Guide, in particular the chapter on versioning. This document may be found
online at http://docs.sun.com.
Unbound symbols are library symbols (that is, functions or data) referenced by the application that the dynamic link<hy>
er could not resolve when appcert was run. Note: appcert does not actually run your application, so some aspect of
the environment that affects dynamic linking might not be set properly.
Unbound symbols do not necessarily indicate a potential binary stability problem. They only mean that when ap<hy>
pcert was run, the runtime dynamic linker could not resolve these symbols.
Unbound symbols might be due to LD_LIBRARY_PATH not being correctly set. Make sure it is set, so that all of
your binary objects can find all of the libraries they depend on (either your product's own libraries, Solaris libraries,
or those of a third party). Then re-run appcert.
You might find it useful to write a shell script that sets up the environment correctly and then runs appcert on the bi<hy>
naries you want to check.
Another common cause for unbound symbols is when a shared object under test has not recorded its dynamic depen<hy>
dencies, that is, at build time the -l switch was not supplied to the compiler and ld(1). So the shared object requires
that the executables that link against it have the correct dependencies recorded.
Notice that such a shared object can either be linked in the standard way (that is, specified at an executable's build
time) or dynamically opened (for example, an executable calls dlopen(3C) on the shared object sometimes when
running). Either case can give rise to unbound symbols when appcert is run. The former can usually be resolved by
setting LD_LIBRARY_PATH appropriately before running appcert. The latter (dlopen) is usually difficult to re<hy>
solve. Under some circumstances, you might be able to set LD_PRELOAD appropriately to preload the needed li<hy>
braries, but this procedure does not always work.
How do you know if the environment has been set up correctly so that there will be no unbound symbols? It must be
set up so that running ldd -r on the binary yields no "file not found" or "symbol not found" errors. See ld.so.1(1)
and ldd(1) for more information on dynamic linking.
In any event, appcert flags unbound symbols as a warning in case they might indicate a more serious problem. Un<hy>
bound symbols can be an indicator of dependencies on demoted symbols (symbols that have been removed from a
library or scoped local to it). Dependencies on demoted symbols will lead to serious binary stability problems.
However, setting up the environment properly should remove most unbound symbols. In general, it is good practice
<beginning of page>
to record library dependencies at build time whenever possible because it helps make the binary object better defined
and self-contained. Also recommended is using the -z defs flag when building shared objects, to force the resolution
of all symbols during compilation. See ld(1) for more information.
appcert runs /bin/ldd -r on each binary object to be tested. It sets the environment variable LD_DE<hy>
BUG="files,bindings". (See ldd(1) and ld.so.1(1) for more information). If that command fails for some reason, ap<hy>
pcert will have no dynamic symbol binding information and will find "no bindings".
appcert can fail if any of the following is true: <bu> The binary object does not have read permission. <bu> The binary ob<hy>
ject is SUID or SGID and the user does not have sufficient privileges. <bu> The binary object is an executable without
the execute permission bit set. <bu> The binary object is completely statically linked. <bu> The binary object has no library
dependency information recorded.
Other cases exist as well (for example, out of memory). In general, this flag means that appcert could not complete<hy>
ly examine the object due to permissions or environment. Try to modify the permissions or environment so that the
dynamic bindings can be recorded.
An obsolete library is one whose use is deprecated and that might, in some future release, be removed from Solaris
altogether. appcert flags these because applications depending on them might not run in future releases of Solaris.
All interfaces, including Private ones, in an obsolete library are frozen and will not change.
Direct use of the symbols sys_errlist or sys_nerr presents a risk in which reference might be made past the end of
the sys_errlist array. These symbols are deprecated in 32-bit versions of Solaris and are absent altogether in 64-bit
versions. Use strerror(3C) instead.
The "strong" symbols (for example, _socket) associated with "weak" symbols (for example, socket ) are reserved as
private (their behavior could change in the future). Your application should only directly reference the weak symbol
(usually the strong symbols begin with "_").
Note: Under certain build environments, the strong/private symbol dependency gets recorded into your binary in<hy>
stead of the weak/public one, even though the source code doesn't appear to reference the private symbol. Neverthe<hy>
less, steps should be taken to trace down why this is occurring and fix the dependency.
appcert needs to run in the same environment in which the application being checked runs. Otherwise it might not
be able to resolve references correctly to interfaces in the Solaris libraries. Take the following steps: 1. Make sure
that LD_LIBRARY_PATH and any other aspects of the environment are set to whatever settings are used when the
application is run. Also make sure that it contains the directories containing any non-Solaris shared objects that are
part of the product, so that they can be found when referenced. 2. Make sure that all the binaries to be checked: <bu>
Are dynamically linked ELF objects <bu> Have execute permission set on executables (this is not necessary for shared
objects) <bu> Are not SUID root (otherwise you will have to be root to check them; make non-SUID copies and check
those if necessary).
You might find it useful to write a shell script that sets up the environment correctly and then runs appcert.
Some potential problems that can be encountered are: <bu> appcert reports unbound symbols that appear to be part of
Solaris libraries.
This is probably caused when the application uses dlopen(3C) to access a shared object that does not have its Solaris
dependencies recorded. appcert cannot resolve symbol use in such cases, since the dynamic linker is never invoked
on the shared object, and there is no other dependency information that could be used to resolve the Solaris symbol
bindings. This can also occur with non-Solaris symbols.
To avoid this problem, make sure that when a shared object is built, its dependencies on Solaris libraries are explicit<hy>
ly recorded by using the -llib option on the compile line (see cc(1) and ld(1)). <bu> appcert reports that the application
uses a Solaris private symbol that is not referenced in the application's source code.
This problem is most likely due to static linking of a Solaris library that references that symbol. Since appcert uses
the dynamic linker to resolve symbols, statically linked libraries appear to appcert to be part of the application code
(which, in a sense, they are). This can also sometimes happen as a result of macro substitution in a Solaris header
file.
To avoid this problem, whenever possible do not statically link Solaris library archives into your application. <bu> ap<hy>
pcert does not recognize a library as part of Solaris.
Some obsolete Solaris libraries are so old that they were obsoleted before their symbols could be versioned. Conse<hy>
quently, appcert cannot recognize them as being part of Solaris.
<beginning of page>
The use of the terms "public" and "private" as equivalent to "stable" and "unstable" is unfortunately somewhat
confusing. In particular, experimental or evolving interfaces are public in the sense that they are documented and
their use is encouraged. But they are unstable, because an application built with them might not run on subsequent
releases. Thus, they are classified as private for appcert's purposes until they are no longer evolving. Conversely,
obsolete interfaces will eventually disappear, and so are unstable, even though they have been public and stable in
the past and are still treated as public by appcert. Fortunately, these two situations are rare.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wapct _ Interface stabilityStable
cc(1), find(1), isalist(1), ld(1), ldd(1), ld.so.1(1), pvs(1), dlopen(3C), strerror(3C), Intro(4), attributes(5)
atomic_and.3c <beginning of page>
atomic_and, atomic_and_8, atomic_and_uchar, atomic_and_16, atomic_and_ushort, atomic_and_32, atom<hy>
ic_and_uint, atomic_and_ulong, atomic_and_64, atomic_and_8_nv, atomic_and_uchar_nv, atomic_and_16_nv,
atomic_and_ushort_nv, atomic_and_32_nv, atomic_and_uint_nv, atomic_and_ulong_nv, atomic_and_64_nv <-> atom<hy>
ic AND operations
#include <atomic.h>
void atomic_and_8(volatile uint8_t *target, uint8_t bits);
void atomic_and_uchar(volatile uchar_t *target, uchar_t bits);
void atomic_and_16(volatile uint16_t *target, uint16_t bits);
void atomic_and_ushort(volatile ushort_t *target, ushort_t bits);
void atomic_and_32(volatile uint32_t *target, uint32_t bits);
void atomic_and_uint(volatile uint_t *target, uint_t bits);
void atomic_and_ulong(volatile ulong_t *target, ulong_t bits);
void atomic_and_64(volatile uint64_t *target, uint64_t bits);
uint8_t atomic_and_8_nv(volatile uint8_t *target, uint8_t bits);
uchar_t atomic_and_uchar_nv(volatile uchar_t *target, uchar_t bits);
uint16_t atomic_and_16_nv(volatile uint16_t *target, uint16_t bits);
ushort_t atomic_and_ushort_nv(volatile ushort_t *target, ushort_t bits);
uint32_t atomic_and_32_nv(volatile uint32_t *target, uint32_t bits);
uint_t atomic_and_uint_nv(volatile uint_t *target, uint_t bits);
ulong_t atomic_and_ulong_nv(volatile ulong_t *target, ulong_t bits);
uint64_t atomic_and_64_nv(volatile uint64_t *target, uint64_t bits);
These functions enable the bitwise AND of bits to the value stored in target to occur in an atomic manner.
The *_nv() variants of these functions return the new value of target.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
atomic_add(3C), atomic_bits(3C), atomic_cas(3C), atomic_dec(3C), atomic_inc(3C), atomic_or(3C), atom<hy>
ic_swap(3C), membar_ops(3C), attributes(5), atomic_ops(9F)
The *_nv() variants are substantially more expensive on some platforms than the versions that do not return values.
Do not use them unless you need to know the new value atomically.
audioens.7d <beginning of page>
audioens <-> Ensoniq ESS 1371 and ESS 1373 audio driver
The audioens driver provides support for the Ensoniq ESS1371, ESS1373, and Creative 5880 AC'97 devices. These
devices are commonly known by several different names, including the Sound Blaster PCI128 and AudioPCI '97.
/kernel/drv/audioens
32-bit kernel module
/kernel/drv/amd64/audioens
64-bit x86 kernel module
/kernel/drv/sparcv9/audioens
64-bit SPARC kernel module
See attributes(5) for descriptions of the following attributes:
tab() box; cw(0i) |cw(5.5i) lw(0i) |lw(5.5i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureSPARC, x86 _
AvailabilitySUNWaudd _ Interface StabilityUncommitted
attributes(5), audio(7I), dsp(7I), mixer(7I)
au_preselect.3bsm <beginning of page>
au_preselect <-> preselect an audit event
cc [ flag... ] file... -lbsm -lsocket -lnsl [ library... ]
#include <bsm/libbsm.h>
int au_preselect(au_event_t event, au_mask_t *mask_p, int sorf, int flag);
The au_preselect() function determines whether the audit event event is preselected against the binary preselection
mask pointed to by mask_p (usually obtained by a call to getaudit(2)). The au_preselect() function looks up the
classes associated with event in audit_event(4) and compares them with the classes in mask_p. If the classes associ<hy>
ated with event match the classes in the specified portions of the binary preselection mask pointed to by mask_p, the
event is said to be preselected.
The sorf argument indicates whether the comparison is made with the success portion, the failure portion, or both
portions of the mask pointed to by mask_p.
The following are the valid values of sorf:
AU_PRS_SUCCESS Compare the event class with the success portion of the preselection mask.
AU_PRS_FAILURE Compare the event class with the failure portion of the preselection mask.
AU_PRS_BOTH Compare the event class with both the success and failure portions of the preselection mask.
The flag argument tells au_preselect() how to read the audit_event(4) database. Upon initial invocation, au_prese<hy>
lect() reads the audit_event(4) database and allocates space in an internal cache for each entry with malloc(3C). In
subsequent invocations, the value of flag determines where au_preselect() obtains audit event information. The fol<hy>
lowing are the valid values of flag:
AU_PRS_REREAD Get audit event information by searching the audit_event(4) database.
AU_PRS_USECACHE Get audit event information from internal cache created upon the initial invocation. This
option is much faster.
Upon successful completion,au_preselect() returns 0 if event is not preselected or 1 if event is preselected. If
au_preselect() could not allocate memory or could not find event in the audit_event(4) database, <mi>1 is returned.
/etc/security/audit_class file mapping audit class number to audit class names and descriptions
/etc/security/audit_event file mappint audit even number to audit event names and associates
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
bsmconv(1M), getaudit(2), au_open(3BSM), getauclassent(3BSM), getauevent(3BSM), malloc(3C), au<hy>
dit_class(4), audit_event(4), attributes(5)
The au_preselect() function is normally called prior to constructing and writing an audit record. If the event is not
preselected, the overhead of constructing and writing the record can be saved.
The functionality described on this manual page is available only if the Solaris Auditing has been enabled. See
bsmconv(1M) for more information.
ber_encode.3ldap <beginning of page>
ber_encode, ber_alloc, ber_printf, ber_put_int, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean,
ber_put_bitstring, ber_start_seq, ber_start_set, ber_put_seq, ber_put_set <-> simplified Basic Encoding Rules library
encoding functions
cc[ flag... ] file... -lldap[ library... ]
#include <lber.h>
BerElement *ber_alloc();
ber_printf(BerElement *ber, char **fmt[, arg... ]);
ber_put_int(BerElement *ber, long num, char tag);
ber_put_ostring(BerElement *ber, char **str, unsigned long len,
 char tag);
ber_put_string(BerElement *ber, char **str, char tag);
ber_put_null(BerElement *ber, char tag);
ber_put_boolean(BerElement *ber, int bool, char tag);
ber_put_bitstring(BerElement *ber, char *str, int blen, char tag);
ber_start_seq(BerElement *ber, char tag);
ber_start_set(BerElement *ber, char tag);
ber_put_seq(BerElement *ber);
ber_put_set(BerElement *ber);
These functions provide a subfunction interface to a simplified implementation of the Basic Encoding Rules of
ASN.1. The version of BER these functions support is the one defined for the LDAP protocol. The encoding rules
are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always en<hy>
coded in primitive form. In addition, these lightweight BER functions restrict tags and class to fit in a single octet
(this means the actual tag must be less than 31). When a "tag"is specified in the descriptions below, it refers to the
tag, class, and primitive or constructed bit in the first octet of the encoding. This man page describes the encoding
functions in the lber library. See ber_decode(3LDAP) for details on the corresponding decoding functions.
Normally, the only functions that need be called by an application are ber_alloc(), to allocate a BER element, and
ber_printf() to do the actual encoding. The other functions are provided for those applications that need more con<hy>
trol than ber_printf() provides. In general, these functions return the length of the element encoded, or <mi>1 if an er<hy>
ror occurred.
The ber_alloc() function is used to allocate a new BER element.
The ber_printf() function is used to encode a BER element in much the same way that sprintf(3S) works. One
important difference, though, is that some state information is kept with the ber parameter so that multiple calls can
be made to ber_printf() to append things to the end of the BER element. Ber_printf() writes to ber, a pointer to a
BerElement such as returned by ber_alloc(). It interprets and formats its arguments according to the format string
fmt. The format string can contain the following characters:
b Boolean. An integer parameter should be supplied. A boolean element is output.
B Bitstring. A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.
A bitstring element is output.
i Integer. An integer parameter should be supplied. An integer element is output.
n Null. No parameter is required. A null element is output.
<beginning of page>
o Octet string. A char * is supplied, followed by the length of the string pointed to. An octet string element is out<hy>
put.
O Octet string. A struct berval * is supplied. An octet string element is output.
s Octet string. A null-terminated string is supplied. An octet string element is output, not including the trailing null
octet.
t Tag. An int specifying the tag to give the next element is provided. This works across calls.
v Several octet strings. A null-terminated array of char * is supplied. Note that a construct like '{v}' is required to
get an actual sequence of octet strings.
{ Begin sequence. No parameter is required.
} End sequence. No parameter is required.
[ Begin set. No parameter is required.
] End set. No parameter is required.
The ber_put_int() function writes the integer element num to the BER element ber.
The ber_put_boolean() function writes the boolean value given by bool to the BER element.
The ber_put_bitstring() function writes blen bits starting at str as a bitstring value to the given BER element. Note
that blen is the length in bits of the bitstring.
The ber_put_ostring() function writes len bytes starting at str to the BER element as an octet string.
The ber_put_string() function writes the null-terminated string (minus the terminating '') to the BER element as an
octet string.
The ber_put_null() function writes a NULL element to the BER element.
The ber_start_seq() function is used to start a sequence in the BER element. The ber_start_set() function works
similarly. The end of the sequence or set is marked by the nearest matching call to ber_put_seq() or
ber_put_set(), respectively.
The ber_first_element() function is used to return the tag and length of the first element in a set or sequence. It al<hy>
so returns in cookie a magic cookie parameter that should be passed to subsequent calls to ber_next_element(),
which returns similar information. Example 1 Assuming the following variable declarations, and that the variables
have been assigned appropriately, an BER encoding of the following ASN.1 object:
  AlmostASearchRequest := SEQUENCE {
  baseObject DistinguishedName,
  scope ENUMERATED {
  baseObject (0),
  singleLevel (1),
  wholeSubtree (2)
  },
  derefAliases ENUMERATED {
  neverDerefaliases (0),
  derefInSearching (1),
  derefFindingBaseObj (2),
  alwaysDerefAliases (3N)
  },
<beginning of page>
  sizelimit INTEGER (0 .. 65535),
  timelimit INTEGER (0 .. 65535),
  attrsOnly BOOLEAN,
  attributes SEQUENCE OF AttributeType
  }
can be achieved like so:
  int scope, ali, size, time, attrsonly;
  char *dn, **attrs;
  /* ... fill in values ... */
  if ( (ber = ber_alloc()) == NULLBER )
  /* error */
  if ( ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
  size, time, attrsonly, attrs ) == -1 )
  /* error */
  else
  /* success */
If an error occurs during encoding, ber_alloc() returns NULL; other functions generally return <mi>1.
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsl (32-bit) _ SUNWcslx (64-bit) _ Interface StabilityCommitted
ber_decode(3LDAP), attributes(5)
Yeong, W., Howes, T., and Hardcastle-Kille, S., "Lightweight Directory Access Protocol", OSI-DS-26, April 1992.
Information Processing - Open Systems Interconnection - Model and Notation - Service Definition - Specification of
Basic Encoding Rules for Abstract Syntax Notation One, International Organization for Standardization, Interna<hy>
tional Standard 8825.
The return values for all of these functions are declared in <lber.h>.
bp_mapin.9f <beginning of page>
bp_mapin <-> allocate virtual address space
#include <sys/types.h>
#include <sys/buf.h>
void bp_mapin(struct buf *bp);
Architecture independent level 1 (DDI/DKI).
bp Pointer to the buffer header structure.
bp_mapin() is used to map virtual address space to a page list maintained by the buffer header during a paged- I/O
request. bp_mapin() allocates system virtual address space, maps that space to the page list, and returns the starting
address of the space in the bp->b_un.b_addr field of the buf(9S) structure. Virtual address space is then deallocated
using the bp_mapout(9F) function.
If a null page list is encountered, bp_mapin() returns without allocating space and no mapping is performed.
bp_mapin() can be called from user and kernel contexts.
bp_mapout(9F), buf(9S)
Writing Device Drivers
accept.3xnet <beginning of page>
accept <-> accept a new connection on a socket
cc [ flag ... ] file ... -lxnet [ library ... ]
#include <sys/socket.h>
int accept(int socket, struct sockaddr *restrict address,
 socklen_t *restrict address_len);
The accept() function extracts the first connection on the queue of pending connections, creates a new socket with
the same socket type protocol and address family as the specified socket, and allocates a new file descriptor for that
socket.
The function takes the following arguments:
socket Specifies a socket that was created with socket(3XNET), has been bound to an address with bind(3XNET),
and has issued a successful call to listen(3XNET).
address Either a null pointer, or a pointer to a sockaddr structure where the address of the connecting socket will be
returned.
address_len Points to a socklen_t which on input specifies the length of the supplied sockaddr structure, and on
output specifies the length of the stored address.
If address is not a null pointer, the address of the peer for the accepted connection is stored in the sockaddr struc<hy>
ture pointed to by address, and the length of this address is stored in the object pointed to by address_len.
If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address
will be truncated.
If the protocol permits connections by unbound clients, and the peer is not bound, then the value stored in the object
pointed to by address is unspecified.
If the listen queue is empty of connection requests and O_NONBLOCK is not set on the file descriptor for the sock<hy>
et, accept() will block until a connection is present. If the listen(3XNET) queue is empty of connection requests and
O_NONBLOCK is set on the file descriptor for the socket, accept() will fail and set errno to EAGAIN or
EWOULDBLOCK.
The accepted socket cannot itself accept more connections. The original socket remains open and can accept more
connections.
When a connection is available, select(3C) will indicate that the file descriptor for the socket is ready for reading.
Upon successful completion, accept() returns the nonnegative file descriptor of the accepted socket. Otherwise, <mi>1
is returned and errno is set to indicate the error.
The accept() function will fail if:
EAGAIN
EWOULDBLOCK O_NONBLOCK is set for the socket file descriptor and no connections are present to be ac<hy>
cepted.
EBADF The socket argument is not a valid file descriptor.
ECONNABORTED A connection has been aborted.
EFAULT The address or address_len parameter can not be accessed or written.
EINTR The accept() function was interrupted by a signal that was caught before a valid connection arrived.
<beginning of page>
EINVAL The socket is not accepting connections.
EMFILE OPEN_MAX file descriptors are currently open in the calling process.
ENFILE The maximum number of file descriptors in the system are already open.
ENOTSOCK The socket argument does not refer to a socket.
EOPNOTSUPP The socket type of the specified socket does not support accepting connections.
The accept() function may fail if:
ENOBUFS No buffer space is available.
ENOMEM There was insufficient memory available to complete the operation.
ENOSR There was insufficient STREAMS resources available to complete the operation.
EPROTO A protocol error has occurred; for example, the STREAMS protocol stack has not been initialized.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
bind(3XNET), connect(3XNET), listen(3XNET), socket(3XNET), attributes(5), standards(5)
acl_free.3sec <beginning of page>
acl_free <-> free memory associated with an acl_t structure
cc [ flag... ] file... -lsec [ library... ]
#include <sys/acl.h>
void acl_free(acl_t *aclp);
The acl_free() function frees memory allocated for the acl_t structure pointed to by the aclp argument.
The acl_free() function does not return a value.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyEvolving _ MT-LevelMT-Safe
acl_get(3SEC), acl(5), attributes(5)
addch.3xcurses <beginning of page>
addch, mvaddch, mvwaddch, waddch <-> add a character (with rendition) to a window
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library ... ]
#include <curses.h>
int addch(const chtype ch);
int mvaddch(int y, int x, const chtype ch);
int mvwaddch(WINDOW *win, int y, int x, const chtype ch);
int waddch(WINDOW *win, const chtype ch);
The addch() function writes a character to the stdscr window at the current cursor position. The mvaddch() and
mvwaddch() functions write the character to the position indicated by the x (column) and y (row) parameters. The
mvaddch() function writes the character to the stdscr window, while mvwaddch() writes the character to the win<hy>
dow specified by win. The waddch() function is identical to addch(), but writes the character to the window speci<hy>
fied by win.
These functions advance the cursor after writing the character. Characters that do not fit on the end of the current
line are wrapped to the beginning of the next line unless the current line is the last line of the window and scrolling
is disabled. In that situation, characters which extend beyond the end of the line are discarded.
When ch is a backspace, carriage return, newline, or tab, X/Open Curses moves the cursor appropriately. Each tab
character moves the cursor to the next tab stop. By default, tab stops occur every eight columns. When ch is a con<hy>
trol character other than backspace, carriage return, newline, or tab, it is written using ^x notation, where x is a
printable character. When X/Open Curses writes ch to the last character position on a line, it automatically gener<hy>
ates a newline. When ch is written to the last character position of a scrolling region and scrollok() is enabled,
X/Open Curses scrolls the scrolling region up one line (see clearok(3XCURSES)).
wchstr Is a pointer to the cchar_t string to be copied to the window.
n Is the maximum number of characters to be copied from wchstr. If n is less than 0, the entire string is written or
as much of it as fits on the line.
y Is the y (row) coordinate of the starting position of wchstr in the window.
x Is the x (column) coordinate of the starting position of wchstr in the window.
win Is a pointer to the window to which the string is to be copied.
On success, these functions return OK. Otherwise, they return ERR.
None.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
attroff(3XCURSES), bkgdset(3XCURSES), doupdate(3XCURSES), inch(3XCURSES), insch(3XCURSES),
libcurses(3XCURSES), nl(3XCURSES), printw(3XCURSES), scrollok(3XCURSES), scrl(3XCURSES), termin<hy>
fo(4), attributes(5), standards(5)
aiocancel.3c <beginning of page>
aiocancel <-> cancel an asynchronous operation
#include <sys/asynch.h>
int aiocancel(aio_result_t *resultp);
aiocancel() cancels the asynchronous operation associated with the result buffer pointed to by resultp. It may not be
possible to immediately cancel an operation which is in progress and in this case, aiocancel() will not wait to cancel
it.
Upon successful completion, aiocancel() returns 0 and the requested operation is cancelled. The application will
not receive the SIGIO completion signal for an asynchronous operation that is successfully cancelled.
Upon successful completion, aiocancel() returns 0. Upon failure, aiocancel() returns <mi>1 and sets errno to indicate
the error.
aiocancel() will fail if any of the following are true:
EACCES The parameter resultp does not correspond to any outstanding asynchronous operation, although there is
at least one currently outstanding.
EFAULT resultp points to an address outside the address space of the requesting process. See NOTES.
EINVAL There are not any outstanding requests to cancel.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT-LevelSafe
aioread(3C), aiowait(3C), attributes(5)
Passing an illegal address as resultp will result in setting errno to EFAULT only if it is detected by the application
process.
aliases.4 <beginning of page>
aliases, addresses, forward <-> addresses and aliases for sendmail
/etc/mail/aliases
/etc/mail/aliases.db
/etc/mail/aliases.dir
/etc/mail/aliases.pag
~/.forward
These files contain mail addresses or aliases, recognized by sendmail(1M) for the local host:
/etc/passwd
Mail addresses (usernames) of local users.
/etc/mail/aliases
Aliases for the local host, in ASCII format. Root can edit this file to add, update, or delete local mail aliases.
/etc/mail/aliases.{dir , pag}
The aliasing information from /etc/mail/aliases, in binary ndbm(3C) format for use by sendmail(1M). The program
newaliases(1M) maintains these files.
/etc/mail/aliases.db
 The aliasing information from /etc/mail/aliases, in binary, Berkeley DataBase format for use by sendmail(1M).
The program maintains these files.
Depending on the configuration of the AliasFile option in /etc/mail/sendmail.cf, either the single file aliases.db or
the pair of files aliases.{dir, pag} is generated by newaliases(1M). As shipped with Solaris, sendmail(1M) supports
both formats. If neither is specified, the Berkeley DataBase format which generates the single .db file is used.
~/.forward
Addresses to which a user's mail is forwarded (see Automatic Forwarding).
In addition, the NIS name services aliases map mail.aliases, and the NIS+ mail_aliases table, both contain addresses
and aliases available for use across the network.
As distributed, sendmail(1M) supports the following types of addresses:
 username
Each local username is listed in the local host's /etc/passwd file.
 pathname
Messages addressed to the absolute pathname of a file are appended to that file.
 |command
If the first character of the address is a vertical bar (|), sendmail(1M) pipes the message to the standard input of the
command the bar precedes.
 username@domain
<beginning of page>
If domain does not contain any `.' (dots), then it is interpreted as the name of a host in the current domain. Other<hy>
wise, the message is passed to a mailhost that determines how to get to the specified domain. Domains are divided
into subdomains separated by dots, with the top-level domain on the right.
For example, the full address of John Smith could be:
 js@jsmachine.Podunk-U.EDU
if he uses the machine named jsmachine at Podunk University.
 ... [host!] host!username
These are sometimes mistakenly referred to as ``Usenet'' addresses. uucp(1C) provides links to numerous sites
throughout the world for the remote copying of files.
Other site-specific forms of addressing can be added by customizing the sendmail.cf configuration file. See send<hy>
mail(1M) for details. Standard addresses are recommended.
/etc/mail/aliases is formatted as a series of lines of the form
 aliasname:address[, address]
aliasname is the name of the alias or alias group, and address is the address of a recipient in the group. Aliases can
be nested. That is, an address can be the name of another alias group. Because of the way sendmail(1M) performs
mapping from upper-case to lower-case, an address that is the name of another alias group must not contain any
upper-case letters.
Lines beginning with white space are treated as continuation lines for the preceding alias. Lines beginning with # are
comments.
An alias of the form:
 owner-aliasname : address
sendmail directs error-messages resulting from mail to aliasname to address, instead of back to the person who sent
the message. sendmail rewrites the SMTP envelope sender to match this, so owner-aliasname should always point
to alias-request, and alias-request should point to the owner's actual address:
 owner-aliasname: aliasname-request
 aliasname-request address
An alias of the form:
 aliasname: :include:pathname
with colons as shown, adds the recipients listed in the file pathname to the aliasname alias. This allows a private list
to be maintained separately from the aliases file.
The aliases file on the master NIS server is used for the mail.aliases NIS map, which can be made available to every
NIS client. The mail_aliases table serves the same purpose on a NIS+ server. Thus, the /etc/mail/aliases* files on
the various hosts in a network will one day be obsolete. Domain-wide aliases should ultimately be resolved into
usernames on specific hosts. For example, if the following were in the domain-wide alias file:
 jsmith:js@jsmachine
then any NIS or NIS+ client could just mail to jsmith and not have to remember the machine and username for John
Smith.
<beginning of page>
If a NIS or NIS+ alias does not resolve to an address with a specific host, then the name of the NIS or NIS+ domain
is used. There should be an alias of the domain name for a host in this case.
For example, the alias:
 jsmith:root
sends mail on a NIS or NIS+ client to root@podunk-u if the name of the NIS or NIS+ domain is podunk-u.
When an alias (or address) is resolved to the name of a user on the local host, sendmail(1M) checks for a ~/.forward
file, owned by the intended recipient, in that user's home directory, and with universal read access. This file can con<hy>
tain one or more addresses or aliases as described above, each of which is sent a copy of the user's mail.
Care must be taken to avoid creating addressing loops in the ~/.forward file. When forwarding mail between ma<hy>
chines, be sure that the destination machine does not return the mail to the sender through the operation of any NIS
aliases. Otherwise, copies of the message may "bounce." Usually, the solution is to change the NIS alias to direct
mail to the proper destination.
A backslash before a username inhibits further aliasing. For instance, to invoke the vacation program, user js creates
a ~/.forward file that contains the line:
 \js, "|/usr/ucb/vacation js"
so that one copy of the message is sent to the user, and another is piped into the vacation program.
The ~/.forward file can be used to specify special "per user" extensions by creating a .forward+extension file in the
home directory. For example, with an address like jsmith+jerry@jsmachine, the sendmail(1M) utility recognizes
everything before the "+" as the actual username (jsmith) and everything after it, up to the "@" symbol, as the ex<hy>
tension (jerry) which is passed to the mail delivery agent for local use.
The default value of the ForwardPath processing option in sendmail(1M) is:
 O ForwardPath=$z/.forward.$w+$h:$z/.forward+$h:$z/.forward.$w:$z \
 /.forward
where $z is the macro for the user's home directory, $w is the macro for the local machine name and $h is the exten<hy>
sion. For example, for mail using the address, jsmith+jerry@jsmachine, the sendmail(1M) utility checks each of
the four following file names, in the order given, to see if it exists and if it has "safe" permissions, that is, that neither
the file nor any of its parent directories are group- or world-writable:
 ~jsmith/.forward.jsmachine+jerry
 ~jsmith/.forward+jerry
 ~jsmith/.forward.jsmachine
 ~jsmith/.forward
The first file that meets the conditions is used to forward the mail, that is, all the entries in that file receive a copy of
the mail. The search is then stopped.
/etc/passwd Password file
/etc/nsswitch.conf Name service switch configuration file
/etc/mail/aliases Mail aliases file (ascii)
/etc/mail/aliases.db Database of mail aliases (binary)
/etc/mail/aliases.dir Database of mail aliases (binary)
<beginning of page>
/etc/mail/aliases.pag Database of mail aliases (binary)
/etc/mail/sendmail.cf sendmail configuration file
~/.forward Forwarding information file
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wsndmr
passwd(1), uucp(1C), vacation(1), newaliases(1M), sendmail(1M), ndbm(3C), getusershell(3C), passwd(4),
shells(4), attributes(5)
Because of restrictions in ndbm(3C), a single alias cannot contain more than about 1000 characters (if this format is
used). The Berkeley DataBase format does not have any such restriction. Nested aliases can be used to circumvent
this limit.
For aliases which result in piping to a program or concatenating a file, the shell of the controlling user must be al<hy>
lowed. Which shells are and are not allowed are determined by getusershell(3C).
ar.h.3head <beginning of page>
ar.h, ar <-> archive file format
#include <ar.h>
The archive command ar is used to combine several files into one. Archives are used mainly as libraries to be
searched by the link editor ld.
Each archive begins with the archive magic string.
 #define ARMAG "!<arch>\n" /* magic string */
 #define SARMAG 8 /* length of magic string */
Following the archive magic string are the archive file members. Each file member is preceded by a file member
header which is of the following format:
 #define ARFMAG "`\n" /* header trailer string */
 struct ar_hdr /* file member header */
 {
  char ar_name[16]; /* '/' terminated file member name */
  char ar_date[12]; /* file member date */
  char ar_uid[6] /* file member user identification */
  char ar_gid[6] /* file member group identification */
  char ar_mode[8] /* file member mode (octal) */
  char ar_size[10]; /* file member size */
  char ar_fmag[2]; /* header trailer string */
 };
All information in the file member headers is in printable ASCII. The numeric information contained in the headers
is stored as decimal numbers (except for ar_mode which is in octal). Thus, if the archive contains printable files, the
archive itself is printable.
If the file member name fits, the ar_name field contains the name directly, and is terminated by a slash (/) and
padded with blanks on the right. If the member's name does not fit, ar_name contains a slash (/) followed by a deci<hy>
mal representation of the name's offset in the archive string table described below.
The ar_date field is the modification date of the file at the time of its insertion into the archive. Common format ar<hy>
chives can be moved from system to system as long as the portable archive command ar is used.
Each archive file member begins on an even byte boundary; a newline is inserted between files if necessary. Never<hy>
theless, the size given reflects the actual size of the file exclusive of padding.
Notice there is no provision for empty areas in an archive file.
Each archive that contains object files (see a.out(4)) includes an archive symbol table. This symbol table is used by
the link editor ld to determine which archive members must be loaded during the link edit process. The archive
symbol table (if it exists) is always the first file in the archive (but is never listed) and is automatically created and/or
updated by ar.
The archive symbol table has a zero length name (that is, ar_name[0] is '/'), ar_name[1]==' ', etc.). All ``words''
in this symbol table have four bytes, using the machine-independent encoding shown below. All machines use the
encoding described here for the symbol table, even if the machine's ``natural'' byte order is different.
  0 1 2 3
 0x01020304 01 02 03 04
The contents of this file are as follows: 1. The number of symbols. Length: 4 bytes. 2. The array of offsets into the
archive file. Length: 4 bytes * ``the number of symbols''. 3. The name string table. Length: ar_size - 4 bytes *
(``the number of symbols'' + 1).
As an example, the following symbol table defines 4 symbols. The archive member at file offset 114 defines name.
The archive member at file offset 122 defines object. The archive member at file offset 426 defines function and the
archive member at file offset 434 defines name2.
<beginning of page>
 Offset +0 +1 +2 +3
  ___________________
  0 | 4 | 4 offset entries
  |___________________|
  4 | 114 | name
  |___________________|
  8 | 122 | object
  |___________________|
 12 | 426 | function
  |___________________|
 16 | 434 | name2
  |___________________|
 20 | n | a | m | e |
  |____|____|____|____|
 24 | \0 | o | b | j |
  |____|____|____|____|
 28 | e | c | t | \0 |
  |____|____|____|____|
 32 | f | u | n | c |
  |____|____|____|____|
 36 | t | i | o | n |
  |____|____|____|____|
 40 | \0 | n | a | m |
  |____|____|____|____|
 44 | e | 2 | \0 | |
  |____|____|____|____|
The string table contains exactly as many null terminated strings as there are elements in the offsets array. Each off<hy>
set from the array is associated with the corresponding name from the string table (in order). The names in the string
table are all the defined global symbols found in the common object files in the archive. Each offset is the location of
the archive header for the associated symbol.
If some archive member's name is more than 15 bytes long, a special archive member contains a table of file names,
each followed by a slash and a new-line. This string table member, if present, will precede all ``normal'' archive
members. The special archive symbol table is not a ``normal'' member, and must be first if it exists. The ar_name
entry of the string table's member header holds a zero length name ar_name[0]=='/', followed by one trailing slash
(ar_name[1]=='/'), followed by blanks (ar_name[2]==' ', etc.). Offsets into the string table begin at zero. Example
ar_name values for short and long file names appear below.
 Offset +0 +1 +2 +3 +4 +5 +6 +7 +8 +9
  __________________________________________________
  0 | f | i | l | e | _ | n | a | m | e | _ |
  |____|____|____|____|____|____|____|____|____|____|
 10 | s | a | m | p | l | e | / | \n | l | o |
  |____|____|____|____|____|____|____|____|____|____|
 20 | n | g | e | r | f | i | l | e | n | a |
  |____|____|____|____|____|____|____|____|____|____|
 30 | m | e | x | a | m | p | l | e | / | \n |
  |____|____|____|____|____|____|____|____|____|____|
  Member Name ar_name
 _______________________________________________________________
 short-name | short-name/ | Not in string table
  | |
 file_name_sample | /0 | Offset 0 in string table
  | |
 longerfilenamexample | /18 | Offset 18 in string table
 _____________________|______________|___________________________
ar(1), ld(1), strip(1), a.out(4)
The strip utility will remove all archive symbol entries from the header. The archive symbol entries must be re<hy>
<beginning of page>
stored with the -ts options of the ar command before the archive can be used with the link editor ld.
atan.3m <beginning of page>
atan, atanf, atanl <-> arc tangent function
c99 [ flag... ] file... -lm [ library... ]
#include <math.h>
double atan(double x);
float atanf(float x);
long double atanl(long double x);
These functions compute the principal value of the arc tangent of x.
Upon successful completion, these functions return the arc tangent of x in the range [<mi><*p> /2,<*p> /2] radians.
If x is NaN, NaN is returned.
If x is <+->0, x is returned.
If x is <+->Inf, <+-><*p> /2 is returned.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
atan2(3M), isnan(3M), math.h(3HEAD), tan(3M), attributes(5), standards(5)
atomic_inc.3c <beginning of page>
atomic_inc, atomic_inc_8, atomic_inc_uchar, atomic_inc_16, atomic_inc_ushort, atomic_inc_32, atomic_inc_uint,
atomic_inc_ulong, atomic_inc_64, atomic_inc_ptr, atomic_inc_8_nv, atomic_inc_uchar_nv, atomic_inc_16_nv,
atomic_inc_ushort_nv, atomic_inc_32_nv, atomic_inc_uint_nv, atomic_inc_ulong_nv, atomic_inc_64_nv, atom<hy>
ic_inc_ptr_nv <-> atomic inrement operations
#include <atomic.h>
void atomic_inc_8(volatile uint8_t *target);
void atomic_inc_uchar(volatile uchar_t *target);
void atomic_inc_16(volatile uint16_t *target);
void atomic_inc_ushort(volatile ushort_t *target);
void atomic_inc_32(volatile uint32_t *target);
void atomic_inc_uint(volatile uint_t *target);
void atomic_inc_ulong(volatile ulong_t *target);
void atomic_inc_64(volatile uint64_t *target);
void atomic_inc_ptr(volatile void *target);
uint8_t atomic_inc_8_nv(volatile uint8_t *target);
uchar_t atomic_inc_uchar_nv(volatile uchar_t *target);
uint16_t atomic_inc_16_nv(volatile uint16_t *target);
ushort_t atomic_inc_ushort_nv(volatile ushort_t *target);
uint32_t atomic_inc_32_nv(volatile uint32_t *target);
uint_t atomic_inc_uint_nv(volatile uint_t *target);
ulong_t atomic_inc_ulong_nv(volatile ulong_t *target);
uint64_t atomic_inc_64_nv(volatile uint64_t *target);
void *atomic_inc_ptr_nv(volatile void *target);
These functions enable the inrementing (by one) of the value stored in target to occur in an atomic manner.
The *_nv() variants of these functions return the new value of target.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
atomic_add(3C), atomic_and(3C), atomic_bits(3C), atomic_cas(3C), atomic_dec(3C), atomic_or(3C), atom<hy>
ic_swap(3C), membar_ops(3C), attributes(5), atomic_ops(9F)
The *_nv() variants are substantially more expensive on some platforms than the versions that do not return values.
Do not use them unless you need to know the new value atomically.
au.4 <beginning of page>
au <-> AU audio file format
#include <audio/au.h>
An AU audio file is composed of three parts: a header, an optional description field, and a contiguous segment of au<hy>
dio data. The header is 24 bytes, and the description field is at least 4 bytes. Therefore, the offset for most AU files is
28 bytes. However, some people store additional data in the AU header.
The AU audio structure members and audio data are stored big endian. That is, it starts with the most significant
byte, regardless of the native byte order of the machine architecture on which an application may be running. There<hy>
fore, multi-byte audio data may require byte reversal for proper playback on different processor architectures. See
the macro section for properly reading and writing the AU audio structure members.
The AU header is defined by the following structure:
 struct au_filehdr {
  uint32_t au_magic; /* magic number (.snd) */
  uint32_t au_offset; /* byte offset to start of audio data */
  uint32_t au_data_size; /* data length in bytes */
  uint32_t au_encoding; /* data encoding */
  uint32_t au_sample_rate; /* samples per second */
  uint32_t au_channels; /* number of interleaved channels */
 };
 typedef struct au_filehdr au_filehdr_t;
The au_magic field always contains the following constant for an AU audio file:
 AUDIO_AU_FILE_MAGIC ( 0x2e736e64 ) /* ".snd" */
The au_offset field contains the length of the audio file header plus the variable length info field. Consequently, it
can be interpreted as the offset from the start of the file to the start of the audio data.
The au_data_size field contains the length, in bytes, of the audio data segment. If this length is not known when the
header is written, it should be set to AUDIO_AU_UNKNOWN_SIZE, defined as follows:
 AUDIO_AU_UNKNOWN_SIZE ( ~0 ) /* (unsigned) -1 */
When the au_data_size field contains AUDIO_AU_UNKNOWN_SIZE, the length of the audio data can be deter<hy>
mined by subtracting au_offset from the total length of the file.
The encoding field contains one of the following enumerated keys:
 AUDIO_AU_ENCODING_ULAW /* 8-bit u-law */
 AUDIO_AU_ENCODING_LINEAR_8 /* 8-bit linear PCM */
 AUDIO_AU_ENCODING_LINEAR_16 /* 16-bit linear PCM */
 AUDIO_AU_ENCODING_LINEAR_24 /* 24-bit linear PCM */
 AUDIO_AU_ENCODING_LINEAR_32 /* 32-bit linear PCM */
 AUDIO_AU_ENCODING_FLOAT /* Floating point */
 AUDIO_AU_ENCODING_DOUBLE /* Double precision float */
 AUDIO_AU_ENCODING_FRAGMENTED /* Fragmented sample data */
 AUDIO_AU_ENCODING_DSP /* DSP program */
 AUDIO_AU_ENCODING_FIXED_8 /* 8-bit fixed point */
 AUDIO_AU_ENCODING_FIXED_16 /* 16-bit fixed point */
 AUDIO_AU_ENCODING_FIXED_24 /* 24-bit fixed point */
 AUDIO_AU_ENCODING_FIXED_32 /* 32-bit fixed point */
 AUDIO_AU_ENCODING_EMPHASIS /* 16-bit linear with emphasis */
 AUDIO_AU_ENCODING_COMPRESSED /* 16-bit linear compressed */
 AUDIO_AU_ENCODING_EMP_COMP /* 16-bit linear with emphasis
  and compression */
 AUDIO_AU_ENCODING_MUSIC_KIT /* Music kit DSP commands */
 AUDIO_AU_ENCODING_ADPCM_G721 /* CCITT G.721 ADPCM */
 AUDIO_AU_ENCODING_ADPCM_G722 /* CCITT G.722 ADPCM */
 AUDIO_AU_ENCODING_ADPCM_G723_3 /* CCITT G.723.3 ADPCM */
<beginning of page>
 AUDIO_AU_ENCODING_ADPCM_G723_5 /* CCITT G.723.5 ADPCM */
 AUDIO_AU_ENCODING_ALAW /* 8-bit A-law G.711 */
All of the linear encoding formats are signed integers centered at zero.
The au_sample_rate field contains the audio file's sampling rate in samples per second. Some common sample
rates include 8000, 11025, 22050, 44100, and 48000 samples per second.
The au_channels field contains the number of interleaved data channels. For monaural data, this value is set to one.
For stereo data, this value is set to two. More than two data channels can be interleaved, but such formats are cur<hy>
rently unsupported by the Solaris audio driver architecture. For a stereo sound file, the first sample is the left track
and the second sample is the right track.
The optional info field is a variable length annotation field that can be either text or data. If it is a text description of
the sound, then it should be NULL terminated. However, some older files might not be terminated properly. The size
of the info field is set when the structure is created and cannot be enlarged later.
Accessing all of the AU audio structure members should be done through the supplied AUDIO_AU_FILE2HOST
and AUDIO_AU_HOST2FILE macros. By always using these macros, code will be byte-order independent. See
the example below. Example 1 Displaying Header Information for a Sound File
The following program reads and displays the header information for an AU sound file. The AU<hy>
DIO_AU_FILE2HOST macro ensures that this information will always be in the proper byte order.
 void main(void)
 {
  au_filehdr_t hdr;
  au_filehdr_t local;
  int fd;
  char *name = "bark.au";
  if ((fd = open(name, O_RDONLY)) < 0) {
  printf("can't open file %s\n", name);
  exit(1);
  }
  (void) read(fd, &hdr, sizeof (hdr));
  AUDIO_AU_FILE2HOST(&hdr.au_magic, &local.au_magic);
  AUDIO_AU_FILE2HOST(&hdr.au_offset, &local.au_offset);
  AUDIO_AU_FILE2HOST(&hdr.au_data_size, &local.au_data_size);
  AUDIO_AU_FILE2HOST(&hdr.au_encoding, &local.au_encoding);
  AUDIO_AU_FILE2HOST(&hdr.au_sample_rate, &local.au_sample_rate);
  AUDIO_AU_FILE2HOST(&hdr.au_channels, &local.au_channels);
  printf("Magic = %x\n", local.au_magic);
  printf("Offset = %d\n", local.au_offset);
  printf("Number of data bytes = %d\n", local.au_data_size);
  printf("Sound format = %d\n", local.au_encoding);
  printf("Sample rate = %d\n", local.au_sample_rate);
  printf("Number of channels = %d\n", local.au_channels);
  (void) close(fd);
 }
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Waudh _ Stability LevelEvolving
<beginning of page>
attributes(5)
Some older AU audio files are incorrectly coded with info strings that are not properly NULL-terminated. Thus, ap<hy>
plications should always use the au_offset value to find the end of the info data and the beginning of the audio data.
audiosolo.7d <beginning of page>
audiosolo <-> ESS Solo-1 audio device support
The audiosolo driver provides support for the ESS Solo-1 audio device. This device is found on certain mother<hy>
boards and discrete audio cards. It supports 16-bit 48 kHZ stereo playback and capture.
/kernel/drv/audiosolo
32-bit kernel driver module
/kernel/drv/amd64/audiosolo
64-bit kernel driver module
See attributes(5) for a descriptions of the following attributes:
tab() box; cw(1.83i) |cw(3.67i) lw(1.83i) |lw(3.67i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86 _
AvailabilitySUNWaudiosolo
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
auditreduce.1m <beginning of page>
auditreduce <-> merge and select audit records from audit trail files
auditreduce [options] [audit-trail-file]...
auditreduce allows you to select or merge records from audit trail files. Audit files can be from one or more ma<hy>
chines.
The merge function merges together audit records from one or more input audit trail files into a single output file.
The records in an audit trail file are assumed to be sorted in chronological order (oldest first) and this order is main<hy>
tained by auditreduce in the output file.
Unless instructed otherwise, auditreduce will merge the entire audit trail, which consists of all the audit trail files in
the directory structure audit_root_dir/*/files (see audit_control(4) for details of the structure of the audit root). Un<hy>
less specified with the -R or -S option, audit_root_dir defaults to /etc/security/audit. By using the file selection op<hy>
tions it is possible to select some subset of these files, or files from another directory, or files named explicitly on the
command line.
The select function allows audit records to be selected on the basis of numerous criteria relating to the record's con<hy>
tent (see audit.log(4) for details of record content). A record must meet all of the record-selection-option criteria to
be selected.
Any audit trail file not named on the command line must conform to the audit trail filename format. Files produced
by the audit system already have this format. Output file names produced by auditreduce are in this format. It is:
 start-time.end-time.suffix
where start-time is the 14-character timestamp of when the file was opened, end-time is the 14-character timestamp
of when the file was closed, and suffix is the name of the machine which generated the audit trail file, or some other
meaningful suffix (for example, all, if the file contains a combined group of records from many machines). The end-
time can be the literal string not_terminated, to indicate that the file is still being written to by the audit system.
Timestamps are of the form yyyymmddhhmmss (year, month, day, hour, minute, second). The timestamps are in
Greenwich Mean Time (GMT).
The file selection options indicate which files are to be processed and certain types of special treatment.
-A
All of the records from the input files will be selected regardless of their timestamp. This option effectively disables
the -a, -b, and -d options. This is useful in preventing the loss of records if the -D option is used to delete the input
files after they are processed. Note, however, that if a record is not selected due to another option, then -A will not
override that.
-C
Only process complete files. Files whose filename end-time timestamp is not_terminated are not processed (such a
file is currently being written to by the audit system). This is useful in preventing the loss of records if -D is used to
delete the input files after they are processed. It does not apply to files specified on the command line.
-D suffix
Delete input files after they are read if the entire run is successful. If auditreduce detects an error while reading a
file, then that file is not deleted. If -D is specified, -A, -C and -O are also implied. suffix is given to the -O option.
This helps prevent the loss of audit records by ensuring that all of the records are written, only complete files are
processed, and the records are written to a file before being deleted. Note that if both -D and -O are specified in the
command line, the order of specification is significant. The suffix associated with the latter specification is in effect.
-M machine
Allows selection of records from files with machine as the filename suffix. If -M is not specified, all files are pro<hy>
cessed regardless of suffix. -M can also be used to allow selection of records from files that contain combined
records from many machines and have a common suffix (such as all).
<beginning of page>
-N
Select objects in new mode.This flag is off by default, thus retaining backward compatibility. In the existing, old
mode, specifying the -e, -f, -g, -r, or -u flags would select not only actions taken with those IDs, but also certain ob<hy>
jects owned by those IDs. When running in new mode, only actions are selected. In order to select objects, the -o
option must be used.
-O suffix
Direct output stream to a file in the current audit_root_dir with the indicated suffix. suffix can alternatively contain
a full pathname, in which case the last component is taken as the suffix, ahead of which the timestamps will be
placed, ahead of which the remainder of the pathname will be placed. If the -O option is not specified, the output is
sent to the standard output. When auditreduce places timestamps in the filename, it uses the times of the first and
last records in the merge as the start-time and end-time.
-Q
Quiet. Suppress notification about errors with input files.
-R pathname
Specify the pathname of an alternate audit root directory audit_root_dir to be pathname. Therefore, rather than using
/etc/security/audit/*/files by default, pathname/*/files will be examined instead. Note -
The root file system of any non-global zones must not be referenced with the -R option. Doing so might damage the
global zone's file system, might compromise the security of the global zone, and might damage the non-global
zone's file system. See zones(5).
-S server
This option causes auditreduce to read audit trail files from a specific location (server directory). server is normally
interpreted as the name of a subdirectory of the audit root, therefore auditreduce will look in audit_root_dir/serv<hy>
er/files for the audit trail files. But if server contains any `/' characters, it is the name of a specific directory not nec<hy>
essarily contained in the audit root. In this case, server/files will be consulted. This option allows archived files to be
manipulated easily, without requiring that they be physically located in a directory structure like that of /etc/securi<hy>
ty/audit.
-V
Verbose. Display the name of each file as it is opened, and how many records total were written to the output stream.
The record selection options listed below are used to indicate which records are written to the output file produced
by auditreduce.
Multiple arguments of the same type are not permitted.
-a date-time
Select records that occurred at or after date-time. The date-time argument is described under Option Arguments,
below. date-time is in local time. The -a and -b options can be used together to form a range.
-b date-time
Select records that occurred before date-time.
-c audit-classes
Select records by audit class. Records with events that are mapped to the audit classes specified by audit-classes are
selected. Audit class names are defined in audit_class(4). The audit-classes can be a comma separated list of audit
flags like those described in audit_control(4). Using the audit flags, one can select records based upon success and
failure criteria.
<beginning of page>
-d date-time
Select records that occurred on a specific day (a 24-hour period beginning at 00:00:00 of the day specified and end<hy>
ing at 23:59:59). The day specified is in local time. The time portion of the argument, if supplied, is ignored. Any
records with timestamps during that day are selected. If any hours, minutes, or seconds are given in time, they are ig<hy>
nored. -d can not be used with -a or -b.
-e effective-user
Select records with the specified effective-user.
-f effective-group
Select records with the specified effective-group.
-g real-group
Select records with the specified real-group.
-j subject-ID
Select records with the specified subject-ID where subject-ID is a process ID.
-l label
Select records with the specified label (or label range), as explained under "Option Arguments," below. This option
is available only if the system is configured with Trusted Extensions.
-m event
Select records with the indicated event. The event is the literal string or the event number.
-o object_type=objectID_value
Select records by object type. A match occurs when the record contains the information describing the specified ob<hy>
ject_type and the object ID equals the value specified by objectID_value. The allowable object types and values are
as follows:
file=pathname
Select records containing file system objects with the specified pathname, where pathname is a comma separated list
of regular expressions. If a regular expression is preceded by a tilde (~), files matching the expression are excluded
from the output. For example, the option file=~/usr/openwin,/usr,/etc would select all files in /usr or /etc except
those in /usr/openwin. The order of the regular expressions is important because auditreduce processes them from
left to right, and stops when a file is known to be either selected or excluded. Thus the option file= /usr, /etc,
~/usr/openwin would select all files in /usr and all files in /etc. Files in /usr/openwin are not excluded because the
regular expression /usr is matched first. Care should be given in surrounding the pathname with quotes so as to pre<hy>
vent the shell from expanding any tildes.
filegroup=group
Select records containing file system objects with group as the owning group.
fileowner=user
Select records containing file system objects with user as the owning user.
msgqid=ID
Select records containing message queue objects with the specified ID where ID is a message queue ID.
<beginning of page>
msgqgroup=group
Select records containing message queue objects with group as the owning or creating group.
msgqowner=user
Select records containing message queue objects with user as the owning or creating user.
pid=ID
Select records containing process objects with the specified ID where ID is a process ID. Process are objects when
they are receivers of signals.
procgroup=group
Select records containing process objects with group as the real or effective group.
procowner=user
Select records containing process objects with user as the real or effective user.
semid=ID
Select records containing semaphore objects with the specified ID where ID is a semaphore ID.
semgroup=group
Select records containing semaphore objects with group as the owning or creating group.
semowner=user
Select records containing semaphore objects with user as the owning or creating user.
shmid=ID
Select records containing shared memory objects with the specified ID where ID is a shared memory ID.
shmgroup=group
Select records containing shared memory objects with group as the owning or creating group.
shmowner=user
Select records containing shared memory objects with user as the owning or creating user.
sock=port_number|machine
Select records containing socket objects with the specified port_number or the specified machine where machine is a
machine name as defined in hosts(4).
fmri=service instance
Select records containing fault management resource identifier (FMRI) objects with the specified service instance.
See smf(5).
<beginning of page>
-r real-user
Select records with the specified real-user.
-s session-id
Select audit records with the specified session-id.
-u audit-user
Select records with the specified audit-user.
-z zone-name
Select records from the specified zone name. The zone name selection is case-sensitive.
When one or more filename arguments appear on the command line, only the named files are processed. Files speci<hy>
fied in this way need not conform to the audit trail filename format. However, -M, -S, and -R must not be used when
processing named files. If the filename is ``<mi>'' then the input is taken from the standard input.
audit-trail-file
An audit trail file as defined in audit.log(4). An audit trail file not named on the command line must conform to the
audit trail file name format. Audit trail files produced as output of auditreduce are in this format as well. The format
is:
start-time . end-time . suffix
start-time is the 14 character time stamp denoting when the file was opened. end-time is the 14 character time stamp
denoting when the file was closed. end-time can also be the literal string not_terminated, indicating the file is still
be written to by the audit daemon or the file was not closed properly (a system crash or abrupt halt occurred). suffix
is the name of the machine that generated the audit trail file (or some other meaningful suffix; for example, all would
be a good suffix if the audit trail file contains a combined group of records from many machines).
date-time
The date-time argument to -a, -b, and -d can be of two forms: An absolute date-time takes the form:
 yyyymmdd [ hh [ mm [ ss ]]]
where yyyy specifies a year (with 1970 as the earliest value), mm is the month (01-12), dd is the day (01-31), hh is
the hour (00-23), mm is the minute (00-59), and ss is the second (00-59). The default is 00 for hh, mm and ss.
An offset can be specified as: +n d|h|m| s where n is a number of units, and the tags d, h, m, and s stand for days,
hours, minutes and seconds, respectively. An offset is relative to the starting time. Thus, this form can only be used
with the -b option.
event
The literal string or ordinal event number as found in audit_event(4). If event is not found in the audit_event file it
is considered invalid.
group
The literal string or ordinal group ID number as found in group(4). If group is not found in the group file it is con<hy>
sidered invalid. group can be negative.
label
The literal string representation of a MAC label or a range of two valid MAC labels. To specify a range, use x;y
where x and y are valid MAC labels. Only those records that are fully bounded by x and y will be selected. If x or y
is omitted, the default uses ADMIN_LOW or ADMIN_HIGH respectively. Notice that quotes must be used when
<beginning of page>
specifying a range.
pathname
A regular expression describing a pathname.
user
The literal username or ordinal user ID number as found in passwd(4). If the username is not found in the passwd
file it is considered invalid. user can be negative.
Example 1 The auditreduce command
praudit(1M) is available to display audit records in a human-readable form.
This will display the entire audit trail in a human-readable form:
 % auditreduce | praudit
If all the audit trail files are being combined into one large file, then deleting the original files could be desirable to
prevent the records from appearing twice:
 % auditreduce -V -D /etc/security/audit/combined/all
This displays what user milner did on April 13, 1988. The output is displayed in a human-readable form to the stan<hy>
dard output:
 % auditreduce -d 19880413 -u milner | praudit
The above example might produce a large volume of data if milner has been busy. Perhaps looking at only login and
logout times would be simpler. The -c option will select records from a specified class:
 % auditreduce -d 19880413 -u milner -c lo | praudit
To see milner's login/logout activity for April 13, 14, and 15, the following is used. The results are saved to a file in
the current working directory. Notice that the name of the output file will have milnerlo as the suffix, with the appro<hy>
priate timestamp prefixes. Notice also that the long form of the name is used for the -c option:
 % auditreduce -a 19880413 -b +3d -u milner -c login_logout -O milnerlo
To follow milner's movement about the file system on April 13, 14, and 15 the chdir record types could be viewed.
Notice that in order to get the same time range as the above example we needed to specify the -b time as the day af<hy>
ter our range. This is because 19880416 defaults to midnight of that day, and records before that fall on 0415, the
end-day of the range.
 % auditreduce -a 19880413 -b 19880416 -u milner -m AUE_CHDIR | praudit
<beginning of page>
In this example, the audit records are being collected in summary form (the login/logout records only). The records
are being written to a summary file in a different directory than the normal audit root to prevent the selected records
from existing twice in the audit root.
 % auditreduce -d 19880330 -c lo -O /etc/security/audit_summary/logins
If activity for user ID 9944 has been observed, but that user is not known to the system administrator, then the com<hy>
mand in the following example searches the entire audit trail for any records generated by that user. auditreduce
queries the system about the current validity of ID 9944 and displays a warning message if it is not currently active:
 % auditreduce -O /etc/security/audit_suspect/user9944 -u 9944
To get an audit log of only the global zone:
 % auditreduce -z global
/etc/security/audit/server/files/*
location of audit trails, when stored
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ Interface StabilitySee below.
The command invocation is Stable. The binary file format is Stable. The binary file contents is Unstable.
bsmconv(1M), praudit(1M), audit.log(4), audit_class(4), audit_control(4), group(4), hosts(4), passwd(4), at<hy>
tributes(5), smf(5)
See the section on Solaris Auditing in System Administration Guide: Security Services.
auditreduce displays error messages if there are command line errors and then exits. If there are fatal errors during
the run, auditreduce displays an explanatory message and exits. In this case, the output file might be in an inconsis<hy>
tent state (no trailer or partially written record) and auditreduce displays a warning message before exiting. Suc<hy>
cessful invocation returns 0 and unsuccessful invocation returns 1.
Since auditreduce might be processing a large number of input files, it is possible that the machine-wide limit on
open files will be exceeded. If this happens, auditreduce displays a message to that effect, give information on how
many file there are, and exit.
If auditreduce displays a record's timestamp in a diagnostic message, that time is in local time. However, when file<hy>
names are displayed, their timestamps are in GMT.
Conjunction, disjunction, negation, and grouping of record selection options should be allowed.
The functionality described in this man page is available only if the Solaris Auditing has been enabled. See bsm<hy>
conv(1M) for more information.
The -z option should be used only if the audit policy zonename is set. If there is no zonename token, then no records
will be selected.
automountd.1m <beginning of page>
automountd <-> autofs mount/unmount daemon
automountd [-Tvn] [-D name=value]
automountd is an RPC server that answers file system mount and unmount requests from the autofs file system. It
uses local files or name service maps to locate file systems to be mounted. These maps are described with the auto<hy>
mount(1M) command.
If automount finds any non-trivial entries in either the local or distributed automount maps and if the daemon is not
running already, the automountd daemon is automatically invoked by automount(1M). automountd enables the
svc:/network/nfs/nlockmgr service (lockd(1M)), and the svc:/network/nfs/status service (statd(1M)), if NFS
mounts need to be done.
At startup, the automountd daemon is invoked as is invoked as the system/filesystem/autofs:default service. See
NOTES.
The following options are supported:
-D name=value Assign value to the indicated automount map substitution variable. These assignments cannot be
used to substitute variables in the master map auto_master.
-n Turn off browsing for all autofs mount points. This option overrides the -browse autofs map option on the local
host.
-T Trace. Expand each RPC call and display it on the standard output.
-v Verbose. Log status messages to the console.
See largefile(5) for the description of the behavior of automountd when encountering files greater than or equal to 2
Gbyte ( 2^31 bytes).
/etc/auto_master Master map for automounter.
/etc/default/autofs Supplies default values for parameters for automount and automountd. See autofs(4).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
svcs(1), automount(1M), svcadm(1M), autofs(4), attributes(5), largefile(5), smf(5)
The automountd service is managed by the service management facility, smf(5), under the service identifier:
 svc:/system/filesystem/autofs
Administrative actions on this service, such as enabling, disabling, or requesting restart, can be performed using sv<hy>
cadm(1M). The service's status can be queried using svcs(1). If it is disabled, it is enabled by automount(1M) un<hy>
less the application/auto_enable property is set to false.
bc.1 <beginning of page>
bc <-> arbitrary precision arithmetic language
/usr/bin/bc [-c] [-l] [file]...
/usr/xpg6/bin/bc [-c] [-l] [file]...
The bc utility implements an arbitrary precision calculator. It takes input from any files given, then reads from the
standard input. If the standard input and standard output to bc are attached to a terminal, the invocation of bc is in<hy>
teractive, causing behavioral constraints described in the following sections. bc processes a language that resembles
C and is a preprocessor for the desk calculator program dc, which it invokes automatically unless the -c option is
specified. In this case the dc input is sent to the standard output instead.
The syntax for bc programs is as follows:
L Means a letter a<mi>z,
E Means an expression: a (mathematical or logical) value, an operand that takes a value, or a combination of oper<hy>
ands and operators that evaluates to a value,
S Means a statement.
Enclosed in /* and */.
 Simple variables: L.
 Array elements: L [ E ] (up to BC_DIM_MAX dimensions).
 The words ibase, obase (limited to BC_BASE_MAX), and scale (limited to BC_SCALE_MAX).
Arbitrarily long numbers with optional sign and decimal point. Strings of fewer than BC_STRING_MAX charac<hy>
ters, between double quotes ("). ( E )
sqrt ( E ) Square root
length ( E ) Number of significant decimal digits.
scale ( E ) Number of digits right of decimal point.
L ( E , ... , E )
+ <mi> * / % ^
(% is remainder; ^ is power)
++ <mi><mi>
(prefix and postfix; apply to names)
== <= >= != < >
= =+ =<mi> =* =/ =% =^
 E
 { S ;... ; S }
 if ( E ) S
 while ( E ) S
<beginning of page>
 for ( E ; E ; E ) S
 null statement
 break
 quit
.string
 define L ( L ,..., L ) {
  auto L ,..., L
  S ;... S
  return ( E )
 }
s(x) sine
c(x) cosine
e(x) exponential
l(x) log
a(x) arctangent
j(n,x) Bessel function
All function arguments are passed by value.
The value of a statement that is an expression is printed unless the main operator is an assignment. Either semicolons
or new-lines may separate statements. Assignment to scale influences the number of digits to be retained on arith<hy>
metic operations in the manner of dc. Assignments to ibase or obase set the input and output number radix respec<hy>
tively.
The same letter may be used as an array, a function, and a simple variable simultaneously. All variables are global to
the program. auto variables are stacked during function calls. When using arrays as function arguments or defining
them as automatic variables, empty square brackets must follow the array name.
The following operands are supported:
-c Compiles only. The output is dc commands that are sent to the standard output.
-l Defines the math functions and initializes scale to 20, instead of the default zero.
-l Defines the math functions and initializes scale to 20, instead of the default zero. All math results have the scale of
20.
The following operands are supported:
file A pathname of a text file containing bc program statements. After all cases of file have been read, bc reads the
standard input.
Example 1 Setting the precision of a variable
In the shell, the following assigns an approximation of the first ten digits of n to the variable x:
 x=$(printf "%s\n" 'scale = 10; 104348/33215' | bc)
<beginning of page>
Example 2 Defining a computing function
Defines a function to compute an approximate value of the exponential function:
 scale = 20
 define e(x){
  auto a, b, c, i, s
  a = 1
  b = 1
  s = 1
  for(i=1; 1==1; i++){
   a = a*x
   b = b*i
   c = a/b
   if(c == 0) return(s)
   s = s+c
  }
 }
Example 3 Printing the approximate values of the function
Prints approximate values of the exponential function of the first ten integers:
 for(i=1; i<=10; i++) e(i)
or
 for (i = 1; i <= 10; ++i) { e(i) }
See environ(5) for descriptions of the following environment variables that affect the execution of bc: LANG,
LC_ALL, LC_CTYPE, LC_MESSAGES, and NLSPATH.
The following exit values are returned:
0 All input files were processed successfully.
unspecified An error occurred.
/usr/lib/lib.b mathematical library
/usr/include/limits.h to define BC_ parameters
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wesu _ Interface StabilityStandard
dc(1), awk(1), attributes(5), environ(5), standards(5)
The bc command does not recognize the logical operators && and ||.
<beginning of page>
The for statement must have all three expressions (E's).
bioclone.9f <beginning of page>
bioclone <-> clone another buffer
#include <sys/ddi.h>
#include <sys/sunddi.h>
struct buf *bioclone(struct buf *bp, off_t off, size_t len, dev_t dev,
 daddr_t blkno, int (*iodone) (struct buf *), struct buf *bp_mem,
 int sleepflag);
Solaris DDI specific (Solaris DDI).
bp Pointer to the buf(9S) structure describing the original I/O request.
off Offset within original I/O request where new I/O request should start.
len Length of the I/O request.
dev Device number.
blkno Block number on device.
iodone Specific biodone(9F) routine.
bp_mem Pointer to a buffer structure to be filled in or NULL.
sleepflag Determines whether caller can sleep for memory. Possible flags are KM_SLEEP to allow sleeping until
memory is available, or KM_NOSLEEP to return NULL immediately if memory is not available.
The bioclone() function returns an initialized buffer to perform I/O to a portion of another buffer. The new buffer
will be set up to perform I/O to the range within the original I/O request specified by the parameters off and len. An
offset 0 starts the new I/O request at the same address as the original request. off + len must not exceed b_bcount,
the length of the original request. The device number dev specifies the device to which the buffer is to perform I/O.
blkno is the block number on device. It will be assigned to the b_blkno field of the cloned buffer structure. iodone
lets the driver identify a specific biodone(9F) routine to be called by the driver when the I/O is complete. bp_mem
determines from where the space for the buffer should be allocated. If bp_mem is NULL, bioclone() will allocate a
new buffer using getrbuf(9F). If sleepflag is set to KM_SLEEP, the driver may sleep until space is freed up. If
sleepflag is set to KM_NOSLEEP, the driver will not sleep. In either case, a pointer to the allocated space is re<hy>
turned or NULL to indicate that no space was available. After the transfer is completed, the buffer has to be freed us<hy>
ing freerbuf(9F). If bp_mem is not NULL, it will be used as the space for the buffer structure. The driver has to en<hy>
sure that bp_mem is initialized properly either using getrbuf(9F) or bioinit(9F).
If the original buffer is mapped into the kernel virtual address space using bp_mapin(9F) before calling bioclone(),
a clone buffer will share the kernel mapping of the original buffer. An additional bp_mapin() to get a kernel map<hy>
ping for the clone buffer is not necessary.
The driver has to ensure that the original buffer is not freed while any of the clone buffers is still performing I/O.
The biodone() function has to be called on all clone buffers before it is called on the original buffer.
The bioclone() function returns a pointer to the initialized buffer header, or NULL if no space is available.
The bioclone() function can be called from user, interrup, or interrupt context. Drivers must not allow bioclone() to
sleep if called from an interrupt routine. Example 1 Using bioclone() for Disk Striping
A device driver can use bioclone() for disk striping. For each disk in the stripe, a clone buffer is created which per<hy>
forms I/O to a portion of the original buffer.
 static int
<beginning of page>
 stripe_strategy(struct buf *bp)
 {
  ...
  bp_orig = bp;
  bp_1 = bioclone(bp_orig, 0, size_1, dev_1, blkno_1,
  stripe_done, NULL, KM_SLEEP);
  fragment++;
  ...
  bp_n = bioclone(bp_orig, offset_n, size_n, dev_n,
  blkno_n, stripe_done, NULL, KM_SLEEP);
  fragment++;
  /* submit bp_1 ... bp_n to device */
  xxstrategy(bp_x);
  return (0);
 }
 static uint_t
 xxintr(caddr_t arg)
 {
  ...
  /*
  * get bp of completed subrequest. biodone(9F) will
  * call stripe_done()
  */
  biodone(bp);
  return (0);
 }
 static int
 stripe_done(struct buf *bp)
 {
  ...
  freerbuf(bp);
  fragment--;
  if (fragment == 0) {
  /* get bp_orig */
  biodone(bp_orig);
  }
  return (0);
 }
biodone(9F), bp_mapin(9F), freerbuf(9F), getrbuf(9F), buf(9S)
Writing Device Drivers
boot.1m <beginning of page>
boot <-> start the system kernel or a standalone program
boot [OBP names] [file] [-aLV] [-F object] [-D default-file]
 [-Z dataset] [boot-flags] [<mi><mi>] [client-program-args]
kernel$ /platform/i86pc/kernel/$ISADIR/unix [boot-args]
 [-B prop=val [,val...]]
Bootstrapping is the process of loading and executing a standalone program. For the purpose of this discussion,
bootstrapping means the process of loading and executing the bootable operating system. Typically, the standalone
program is the operating system kernel (see kernel(1M)), but any standalone program can be booted instead. On a
SPARC-based system, the diagnostic monitor for a machine is a good example of a standalone program other than
the operating system that can be booted.
If the standalone is identified as a dynamically-linked executable, boot will load the interpreter (linker/loader) as in<hy>
dicated by the executable format and then transfer control to the interpreter. If the standalone is statically-linked, it
will jump directly to the standalone.
Once the kernel is loaded, it starts the UNIX system, mounts the necessary file systems (see vfstab(4)), and runs
/sbin/init to bring the system to the "initdefault" state specified in /etc/inittab. See inittab(4).
On SPARC based systems, the bootstrap procedure on most machines consists of the following basic phases.
After the machine is turned on, the system firmware (in PROM) executes power-on self-test (POST). The form and
scope of these tests depends on the version of the firmware in your system.
After the tests have been completed successfully, the firmware attempts to autoboot if the appropriate flag has been
set in the non-volatile storage area used by the firmware. The name of the file to load, and the device to load it from
can also be manipulated.
These flags and names can be set using the eeprom(1M) command from the shell, or by using PROM commands
from the ok prompt after the system has been halted.
The second level program is either a fileystem-specific boot block (when booting from a disk), or inetboot or wan<hy>
boot (when booting across the network).
Network Booting
Network booting occurs in two steps: the client first obtains an IP address and any other parameters necessary to per<hy>
mit it to load the second-stage booter. The second-stage booter in turn loads the boot archive from the boot device.
An IP address can be obtained in one of three ways: RARP, DHCP, or manual configuration, depending on the func<hy>
tions available in and configuration of the PROM. Machines of the sun4u and sun4v kernel architectures have
DHCP-capable PROMs.
The boot command syntax for specifying the two methods of network booting are:
 boot net:rarp
 boot net:dhcp
The command:
 boot net
without a rarp or dhcp specifier, invokes the default method for network booting over the network interface for
which net is an alias.
The sequence of events for network booting using RARP/bootparams is described in the following paragraphs. The
sequence for DHCP follows the RARP/bootparams description.
When booting over the network using RARP/bootparams, the PROM begins by broadcasting a reverse ARP request
until it receives a reply. When a reply is received, the PROM then broadcasts a TFTP request to fetch the first block
<beginning of page>
of inetboot. Subsequent requests will be sent to the server that initially answered the first block request. After load<hy>
ing, inetboot will also use reverse ARP to fetch its IP address, then broadcast bootparams RPC calls (see boot<hy>
params(4)) to locate configuration information and its root file system. inetboot then loads the boot archive by
means of NFS and transfers control to that archive.
When booting over the network using DHCP, the PROM broadcasts the hardware address and kernel architecture
and requests an IP address, boot parameters, and network configuration information. After a DHCP server responds
and is selected (from among potentially multiple servers), that server sends to the client an IP address and all other
information needed to boot the client. After receipt of this information, the client PROM examines the name of the
file to be loaded, and will behave in one of two ways, depending on whether the file's name appears to be an HTTP
URL. If it does not, the PROM downloads inetboot, loads that file into memory, and executes it. inetboot loads the
boot archive, which takes over the machine and releases inetboot. Startup scripts then initiate the DHCP agent (see
dhcpagent(1M)), which implements further DHCP activities.
If the file to be loaded is an HTTP URL, the PROM will use HTTP to load the referenced file. If the client has been
configured with an HMAC SHA-1 key, it will check the integrity of the loaded file before proceeding to execute it.
The file is expected to be the wanboot binary. The WAN boot process can be configured to use either DHCP or
NVRAM properties to discover the install server and router and the proxies needed to connect to it. When wanboot
begins executing, it determines whether sufficient information is available to it to allow it to proceed. If any neces<hy>
sary information is missing, it will either exit with an appropriate error or bring up a command interpreter and
prompt for further configuration information. Once wanboot has obtained the necessary information, it loads the
boot loader into memory by means of HTTP. If an encryption key has been installed on the client, wanboot will ver<hy>
ify the boot loader's signature and its accompanying hash. Presence of an encryption key but no hashing key is an er<hy>
ror.
The wanboot boot loader can communicate with the client using either HTTP or secure HTTP. If the former, and if
the client has been configured with an HMAC SHA-1 key, the boot loader will perform an integrity check of the root
file system. Once the root file system has been loaded into memory (and possibly had an integrity check performed),
the boot archive is transferred from the server. If provided with a boot_logger URL by means of the wan<hy>
boot.conf(4) file, wanboot will periodically log its progress.
Not all PROMs are capable of consuming URLs. You can determine whether a client is so capable using the list-se<hy>
curity-keys OBP command (see monitor(1M)).
WAN booting is not currently available on the x86 platform.
The wanboot Command Line
When the client program is wanboot, it accepts client-program-args of the form:
 boot ... -o opt1[,opt2[,...]]
where each option may be an action:
dhcp
Require wanboot to obtain configuration parameters by means of DHCP.
prompt
Cause wanboot to enter its command interpreter.
<cmd>
One of the interpreter commands listed below.
...or an assignment, using the interpreter's parameter names listed below.
The wanboot Command Interpreter
The wanboot command interpreter is invoked by supplying a client-program-args of "-o prompt" when booting.
Input consists of single commands or assignments, or a comma-separated list of commands or assignments. The
configuration parameters are:
<beginning of page>
host-ip
IP address of the client (in dotted-decimal notation)
router-ip
IP address of the default router (in dotted-decimal notation)
subnet-mask
subnet mask (in dotted-decimal notation)
client-id
DHCP client identifier (a quoted ASCII string or hex ASCII)
hostname
hostname to request in DHCP transactions (ASCII)
http-proxy
HTTP proxy server specification (IPADDR[:PORT])
The key names are:
3des
the triple DES encryption key (48 hex ASCII characters)
aes
the AES encryption key (32 hex ASCII characters)
sha1
the HMAC SHA-1 signature key (40 hex ASCII characters)
Finally, the URL or the WAN boot CGI is referred to by means of:
bootserver
URL of WAN boot's CGI (the equivalent of OBP's file parameter)
The interpreter accepts the following commands:
help
Print a brief description of the available commands
var=val
Assign val to var, where var is one of the configuration parameter names, the key names, or bootserver.
var=
Unset parameter var.
<beginning of page>
list
List all parameters and their values (key values retrieved by means of OBP are never shown).
prompt
Prompt for values for unset parameters. The name of each parameter and its current value (if any) is printed, and the
user can accept this value (press Return) or enter a new value.
go
Once the user is satisfied that all values have been entered, leave the interpreter and continue booting.
exit
Quit the boot interpreter and return to OBP's ok prompt.
Any of these assignments or commands can be passed on the command line as part of the -o options, subject to the
OBP limit of 128 bytes for boot arguments. For example, -o list,go would simply list current (default) values of the
parameters and then continue booting.
iSCSI boot is currently supported only on x86. The host being booted must be equipped with NIC(s) capable of
iBFT (iSCSI Boot Firmware Table) or have the mainboard's BIOS be iBFT-capable. iBFT, defined in the Advanced
Configuration and Power Interface (ACPI) 3.0b specification, specifies a block of information that contains various
parameters that are useful to the iSCSI Boot process.
Firmware implementing iBFT presents an iSCSI disk in the BIOS during startup as a bootable device by establishing
the connection to the iSCSI target. The rest of the process of iSCSI booting is the same as booting from a local disk.
To configure the iBFT properly, users need to refer to the documentation from their hardware vendors.
When booting from disk, the OpenBoot PROM firmware reads the boot blocks from blocks 1 to 15 of the partition
specified as the boot device. This standalone booter usually contains a file system-specific reader capable of reading
the boot archive.
If the pathname to the standalone is relative (does not begin with a slash), the second level boot will look for the
standalone in a platform-dependent search path. This path is guaranteed to contain /platform/platform-name. Many
SPARC platforms next search the platform-specific path entry /platform/hardware-class-name. See filesystem(5). If
the pathname is absolute, boot will use the specified path. The boot program then loads the standalone at the appro<hy>
priate address, and then transfers control.
Once the boot archive has been transferred from the boot device, Solaris can initialize and take over control of the
machine. This process is further described in the "Boot Archive Phase," below, and is identical on all platforms.
If the filename is not given on the command line or otherwise specified, for example, by the boot-file NVRAM vari<hy>
able, boot chooses an appropriate default file to load based on what software is installed on the system and the capa<hy>
bilities of the hardware and firmware.
The path to the kernel must not contain any whitespace.
Booting from ZFS differs from booting from UFS in that, with ZFS, a device specifier identifies a storage pool, not a
single root file system. A storage pool can contain multiple bootable datasets (that is, root file systems). Therefore,
when booting from ZFS, it is not sufficient to specify a boot device. One must also identify a root file system within
the pool that was identified by the boot device. By default, the dataset selected for booting is the one identified by
the pool's bootfs property. This default selection can be overridden by specifying an alternate bootable dataset with
the -Z option.
The boot archive contains a file system image that is mounted using an in-memory disk. The image is self-describ<hy>
ing, specifically containing a file system reader in the boot block. This file system reader mounts and opens the
RAM disk image, then reads and executes the kernel contained within it. By default, this kernel is in:
 /platform/`uname -i`/kernel/unix
<beginning of page>
If booting from ZFS, the pathnames of both the archive and the kernel file are resolved in the root file system (that
is, dataset) selected for booting as described in the previous section.
The initialization of the kernel continues by loading necessary drivers and modules from the in-memory filesystem
until I/O can be turned on and the root filesystem mounted. Once the root filesystem is mounted, the in-memory
filesystem is no longer needed and is discarded.
The OpenBoot boot command takes arguments of the following form:
 ok boot [device-specifier] [arguments]
The default boot command has no arguments:
 ok boot
If no device-specifier is given on the boot command line, OpenBoot typically uses the boot-device or diag-device
NVRAM variable. If no optional arguments are given on the command line, OpenBoot typically uses the boot-file or
diag-file NVRAM variable as default boot arguments. (If the system is in diagnostics mode, diag-device and diag-
file are used instead of boot-device and boot-file).
arguments may include more than one string. All argument strings are passed to the secondary booter; they are not
interpreted by OpenBoot.
If any arguments are specified on the boot command line, then neither the boot-file nor the diag-file NVRAM vari<hy>
able is used. The contents of the NVRAM variables are not merged with command line arguments. For example, the
command:
 ok boot -s
ignores the settings in both boot-file and diag-file; it interprets the string "-s" as arguments. boot will not use the
contents of boot-file or diag-file.
With older PROMs, the command:
 ok boot net
took no arguments, using instead the settings in boot-file or diag-file (if set) as the default file name and arguments to
pass to boot. In most cases, it is best to allow the boot command to choose an appropriate default based upon the
system type, system hardware and firmware, and upon what is installed on the root file system. Changing boot-file or
diag-file can generate unexpected results in certain circumstances.
This behavior is found on most OpenBoot 2.x and 3.x based systems. Note that differences may occur on some plat<hy>
forms.
The command:
ok boot cdrom
...also normally takes no arguments. Accordingly, if boot-file is set to the 64-bit kernel filename and you attempt to
boot the installation CD or DVD with boot cdrom, boot will fail if the installation media contains only a 32-bit ker<hy>
nel.
Because the contents of boot-file or diag-file can be ignored depending on the form of the boot command used, re<hy>
liance upon boot-file should be discouraged for most production systems.
When executing a WAN boot from a local (CD or DVD) copy of wanboot, one must use:
<beginning of page>
ok boot cdrom -F wanboot - install
Modern PROMs have enhanced the network boot support package to support the following syntax for arguments to
be processed by the package:
[protocol,] [key=value,]*
All arguments are optional and can appear in any order. Commas are required unless the argument is at the end of
the list. If specified, an argument takes precedence over any default values, or, if booting using DHCP, over configu<hy>
ration information provided by a DHCP server for those parameters.
protocol, above, specifies the address discovery protocol to be used.
Configuration parameters, listed below, are specified as key=value attribute pairs.
tftp-server
IP address of the TFTP server
file
file to download using TFTP or URL for WAN boot
host-ip
IP address of the client (in dotted-decimal notation)
router-ip
IP address of the default router
subnet-mask
subnet mask (in dotted-decimal notation)
client-id
DHCP client identifier
hostname
hostname to use in DHCP transactions
http-proxy
HTTP proxy server specification (IPADDR[:PORT])
tftp-retries
maximum number of TFTP retries
dhcp-retries
maximum number of DHCP retries
The list of arguments to be processed by the network boot support package is specified in one of two ways: <bu> As ar<hy>
guments passed to the package's open method, or <bu> arguments listed in the NVRAM variable network-boot-argu<hy>
ments.
Arguments specified in network-boot-arguments will be processed only if there are no arguments passed to the
<beginning of page>
package's open method.
Argument Values
protocol specifies the address discovery protocol to be used. If present, the possible values are rarp or dhcp.
If other configuration parameters are specified in the new syntax and style specified by this document, absence of the
protocol parameter implies manual configuration.
If no other configuration parameters are specified, or if those arguments are specified in the positional parameter
syntax currently supported, the absence of the protocol parameter causes the network boot support package to use
the platform-specific default address discovery protocol.
Manual configuration requires that the client be provided its IP address, the name of the boot file, and the address of
the server providing the boot file image. Depending on the network configuration, it might be required that subnet-
mask and router-ip also be specified.
If the protocol argument is not specified, the network boot support package uses the platform-specific default ad<hy>
dress discovery protocol.
tftp-server is the IP address (in standard IPv4 dotted-decimal notation) of the TFTP server that provides the file to
download if using TFTP.
When using DHCP, the value, if specified, overrides the value of the TFTP server specified in the DHCP response.
The TFTP RRQ is unicast to the server if one is specified as an argument or in the DHCP response. Otherwise, the
TFTP RRQ is broadcast.
file specifies the file to be loaded by TFTP from the TFTP server, or the URL if using HTTP. The use of HTTP is
triggered if the file name is a URL, that is, the file name starts with http: (case-insensitive).
When using RARP and TFTP, the default file name is the ASCII hexadecimal representation of the IP address of the
client, as documented in a preceding section of this document.
When using DHCP, this argument, if specified, overrides the name of the boot file specified in the DHCP response.
When using DHCP and TFTP, the default file name is constructed from the root node's name property, with commas
(,) replaced by periods (.).
When specified on the command line, the filename must not contain slashes (/).
The format of URLs is described in RFC 2396. The HTTP server must be specified as an IP address (in standard
IPv4 dotted-decimal notation). The optional port number is specified in decimal. If a port is not specified, port 80
(decimal) is implied.
The URL presented must be "safe-encoded", that is, the package does not apply escape encodings to the URL pre<hy>
sented. URLs containing commas must be presented as a quoted string. Quoting URLs is optional otherwise.
host-ip specifies the IP address (in standard IPv4 dotted-decimal notation) of the client, the system being booted. If
using RARP as the address discovery protocol, specifying this argument makes use of RARP unnecessary.
If DHCP is used, specifying the host-ip argument causes the client to follow the steps required of a client with an
"Externally Configured Network Address", as specified in RFC 2131.
router-ip is the IP address (in standard IPv4 dotted-decimal notation) of a router on a directly connected network.
The router will be used as the first hop for communications spanning networks. If this argument is supplied, the
router specified here takes precedence over the preferred router specified in the DHCP response.
subnet-mask (specified in standard IPv4 dotted-decimal notation) is the subnet mask on the client's network. If the
subnet mask is not provided (either by means of this argument or in the DHCP response), the default mask appropri<hy>
ate to the network class (Class A, B, or C) of the address assigned to the booting client will be assumed.
client-id specifies the unique identifier for the client. The DHCP client identifier is derived from this value. Client
identifiers can be specified as: <bu> The ASCII hexadecimal representation of the identifier, or <bu> a quoted string
Thus, client-id="openboot" and client-id=6f70656e626f6f74 both represent a DHCP client identifier of
<beginning of page>
6F70656E626F6F74.
Identifiers specified on the command line must must not include slash (/) or spaces.
The maximum length of the DHCP client identifier is 32 bytes, or 64 characters representing 32 bytes if using the
ASCII hexadecimal form. If the latter form is used, the number of characters in the identifier must be an even num<hy>
ber. Valid characters are 0-9, a-f, and A-F.
For correct identification of clients, the client identifier must be unique among the client identifiers used on the sub<hy>
net to which the client is attached. System administrators are responsible for choosing identifiers that meet this re<hy>
quirement.
Specifying a client identifier on a command line takes precedence over any other DHCP mechanism of specifying
identifiers.
hostname (specified as a string) specifies the hostname to be used in DHCP transactions. The name might or might
not be qualified with the local domain name. The maximum length of the hostname is 255 characters. Note -
The hostname parameter can be used in service environments that require that the client provide the desired host<hy>
name to the DHCP server. Clients provide the desired hostname to the DHCP server, which can then register the
hostname and IP address assigned to the client with DNS.
http-proxy is specified in the following standard notation for a host:
 host [":"" port]
...where host is specified as an IP ddress (in standard IPv4 dotted-decimal notation) and the optional port is specified
in decimal. If a port is not specified, port 8080 (decimal) is implied.
tftp-retries is the maximum number of retries (specified in decimal) attempted before the TFTP process is deter<hy>
mined to have failed. Defaults to using infinite retries.
dhcp-retries is the maximum number of retries (specified in decimal) attempted before the DHCP process is deter<hy>
mined to have failed. Defaults to of using infinite retries.
On x86 based systems, the bootstrapping process consists of two conceptually distinct phases, kernel loading and
kernel initialization. Kernel loading is implemented in GRUB (GRand Unified Bootloader) using the BIOS ROM on
the system board, and BIOS extensions in ROMs on peripheral boards. The BIOS loads GRUB, starting with the
first physical sector from a hard disk, DVD, or CD. If supported by the ROM on the network adapter, the BIOS can
also download the pxegrub binary from a network boot server. Once GRUB is located, it executes a command in a
menu to load the unix kernel and a pre-constructed boot archive containing kernel modules and data.
If the device identified by GRUB as the boot device contains a ZFS storage pool, the menu.lst file used to create the
GRUB menu will be found in the dataset at the root of the pool's dataset hierarchy. This is the dataset with the same
name as the pool itself. There is always exactly one such dataset in a pool, and so this dataset is well-suited for pool-
wide data such as the menu.lst file. After the system is booted, this dataset is mounted at /poolname in the root file
system.
There can be multiple bootable datasets (that is, root file systems) within a pool. By default, the file system in which
file name entries in a menu.lst file are resolved is the one identified by the pool's bootfs property (see zpool(1M)).
However, a menu.lst entry can contain a bootfs command, which specifies an alternate dataset in the pool. In this
way, the menu.lst file can contain entries for multiple root file systems within the pool.
Kernel initialization starts when GRUB finishes loading the boot archive and hands control over to the unix binary.
At this point, GRUB becomes inactive and no more I/O occurs with the boot device. The Unix operating system ini<hy>
tializes, links in the necessary modules from the boot archive and mounts the root file system on the real root device.
At this point, the kernel regains storage I/O, mounts additional file systems (see vfstab(4)), and starts various operat<hy>
ing system services (see smf(5)).
A requirement of booting from a root filesystem image built into a boot archive then remounting root onto the actual
root device is that the contents of the boot archive and the root filesystem must be consistent. Otherwise, the proper
operation and integrity of the machine cannot be guaranteed.
The term "consistent" means that all files and modules in the root filesystem are also present in the boot archive and
<beginning of page>
have identical contents. Since the boot strategy requires first reading and mounting the boot archive as the first-stage
root image, all unloadable kernel modules and initialization derived from the contents of the boot archive are re<hy>
quired to match the real root filesystem. Without such consistency, it is possible that the system could be running
with a kernel module or parameter setting applied to the root device before reboot, but not yet updated in the root ar<hy>
chive. This inconsistency could result in system instability or data loss.
Once the root filesystem is mounted, and before relinquishing the in-memory filesystem, Solaris performs a consis<hy>
tency verification against the two file systems. If an inconsistency is detected, Solaris suspends the normal boot se<hy>
quence and falls back to failsafe mode. Correcting this state requires the administrator take one of two steps. The
recommended procedure is to reboot to the failsafe archive and rebuild the boot archive. This ensures that a known
kernel is booted and functioning for the archive rebuild process. Alternatively, the administrator can elect to clear the
inconsistent boot archive service state and continue system bring-up if the inconsistency is such that correct system
operation will not be impaired. See svcadm(1M).
If the boot archive service is cleared and system bring-up is continued (the second alternative above), the system
may be running with unloadable kernel drivers or other modules that are out-of-date with respect to the root filesys<hy>
tem. As such, correct system operation may be compromised.
To ensure that the boot archive is consistent, the normal system shutdown process, as initiated by reboot(1M) and
shutdown(1M), checks for and applies updates to the boot archive at the conclusion of the umountall(1M) mile<hy>
stone.
An update to any kernel file, driver, module or driver configuration file that needs to be included in the boot archive
after the umountall service is complete will result in a failed boot archive consistency check during the next boot.
To avoid this, it is recommended to always shut down a machine cleanly.
If an update is required to the kernel after completion of the umountall service, the administrator may elect to re<hy>
build the archive by invoking:
 # bootadm update-archive
The failsafe archive can be used to boot the machine at any time for maintenance or troubleshooting. The failsafe
boot archive is installed on the machine, sourced from the miniroot archive. Booting the failsafe archive causes the
machine to boot using the in-memory filesystem as the root device.
The SPARC failsafe archive is:
 /platform/`uname -i`/failsafe
...and can be booted as follows:
 ok boot [device-specifier] -F failsafe
If a user wishes to boot a failsafe archive from a particular ZFS bootable dataset, this can be done as follows:
 ok boot [device-specifier] -Z dataset -F failsafe
The x86 failsafe archive is:
 /boot/x86.miniroot-safe
...and can be booted by selecting the Solaris failsafe item from the GRUB menu.
The following SPARC options are supported:
<beginning of page>
-a
The boot program interprets this flag to mean ask me, and so it prompts for the name of the standalone. The '-a' flag
is then passed to the standalone program.
-D default-file
Explicitly specify the default-file. On some systems, boot chooses a dynamic default file, used when none is other<hy>
wise specified. This option allows the default-file to be explicitly set and can be useful when booting kmdb(1) since,
by default, kmdb loads the default-file as exported by the boot program.
-F object
Boot using the named object. The object must be either an ELF executable or bootable object containing a boot
block. The primary use is to boot the failsafe or wanboot boot archive.
-L
List the bootable datasets within a ZFS pool. You can select one of the bootable datasets in the list, after which de<hy>
tailed instructions for booting that dataset are displayed. Boot the selected dataset by following the instructions. This
option is supported only when the boot device contains a ZFS storage pool.
-V
Display verbose debugging information.
boot-flags
The boot program passes all boot-flags to file. They are not interpreted by boot. See the kernel(1M) and kmdb(1)
manual pages for information about the options available with the default standalone program.
client-program-args
The boot program passes all client-program-args to file. They are not interpreted by boot.
file
Name of a standalone program to boot. If a filename is not explicitly specified, either on the boot command line or
in the boot-file NVRAM variable, boot chooses an appropriate default filename.
OBP names
Specify the open boot prom designations. For example, on Desktop SPARC based systems, the designation
/sbus/esp@0,800000/sd@3,0:a indicates a SCSI disk (sd) at target 3, lun0 on the SCSI bus, with the esp host
adapter plugged into slot 0.
-Z dataset
Boot from the root file system in the specified ZFS dataset.
The following x86 options are supported:
-B prop=val...
One or more property-value pairs to be passed to the kernel. Multiple property-value pairs must be separated by a
comma. Use of this option is the equivalent of the command: eeprom prop=val. See eeprom(1M) for available prop<hy>
erties and valid values.
If the root file system corresponding to this menu entry is a ZFS dataset, the menu entry needs the following option
added:
<beginning of page>
 -B $ZFS-BOOTFS
boot-args
The boot program passes all boot-args to file. They are not interpreted by boot. See kernel(1M) and kmdb(1) for in<hy>
formation about the options available with the kernel.
/platform/i86pc/kernel/$ISADIR/unix
Name of the kernel to boot. When using the kernel$ token, $ISADIR expands to amd64 on 64-bit machines, and a
null string on other machines. As a result of this dereferencing, this path expands to the proper kernel for the ma<hy>
chine.
After a PC-compatible machine is turned on, the system firmware in the BIOS ROM executes a power-on self test
(POST), runs BIOS extensions in peripheral board ROMs, and invokes software interrupt INT 19h, Bootstrap. The
INT 19h handler typically performs the standard PC-compatible boot, which consists of trying to read the first physi<hy>
cal sector from the first diskette drive, or, if that fails, from the first hard disk. The processor then jumps to the first
byte of the sector image in memory.
The first sector on a floppy disk contains the master boot block (GRUB stage1). The stage 1 is responsible for load<hy>
ing GRUB stage2. Now GRUB is fully functional. It reads and executes the menu file /boot/grub/menu.lst. A simi<hy>
lar sequence occurs for DVD or CD boot, but the master boot block location and contents are dictated by the El Tori<hy>
to specification. The El Torito boot also leads to strap.com, which in turn loads boot.bin.
The first sector on a hard disk contains the master boot block, which contains the master boot program and the
FDISK table, named for the PC program that maintains it. The master boot finds the active partition in the FDISK
table, loads its first sector (GRUB stage1), and jumps to its first byte in memory. This completes the standard PC-
compatible hard disk boot sequence. If GRUB stage1 is installed on the master boot block (see the -m option of in<hy>
stallgrub(1M)), then stage2 is loaded directly from the Solaris FDISK partition regardless of the active partition.
An x86 FDISK partition for the Solaris software begins with a one-cylinder boot slice, which contains GRUB
stage1 in the first sector, the standard Solaris disk label and volume table of contents (VTOC) in the second and
third sectors, and GRUB stage2 in the fiftieth and subsequent sectors. The area from sector 4 to 49 might contain
boot blocks for older versions of Solaris. This makes it possible for multiple Solaris releases on the same FDISK to
coexist. When the FDISK partition for the Solaris software is the active partition, the master boot program (mboot)
reads the partition boot program in the first sector into memory and jumps to it. It in turn reads GRUB stage2 pro<hy>
gram into memory and jumps to it. Once the GRUB menu is displayed, the user can choose to boot an operating sys<hy>
tem on a different partition, a different disk, or possibly from the network.
For network booting, the supported method is Intel's Preboot eXecution Environment (PXE) standard. When boot<hy>
ing from the network using PXE, the system or network adapter BIOS uses DHCP to locate a network bootstrap pro<hy>
gram (pxegrub) on a boot server and reads it using Trivial File Transfer Protocol (TFTP). The BIOS executes the
pxegrub by jumping to its first byte in memory. The pxegrub program downloads a menu file and presents the en<hy>
tries to user.
The kernel startup process is independent of the kernel loading process. During kernel startup, console I/O goes to
the device specified by the console property.
When booting from UFS, the root device is specified by the bootpath property, and the root file system type is spec<hy>
ified by the fstype property. These properties should be setup by the Solaris Install/Upgrade process in /boot/so<hy>
laris/bootenv.rc and can be overridden with the -B option, described above (see the eeprom(1M) man page).
When booting from ZFS, the root device is specified by a boot parameter specified by the -B $ZFS-BOOTFS pa<hy>
rameter on either the kernel or module line in the GRUB menu entry. This value (as with all parameters specified by
the -B option) is passed by GRUB to the kernel.
If the console properties are not present, console I/O defaults to screen and keyboard. The root device defaults to
ramdisk and the file system defaults to ufs. Example 1 To Boot the Default Kernel In Single-User Interactive
Mode
To boot the default kernel in single-user interactive mode, respond to the ok prompt with one of the following:
<beginning of page>
 boot -as
 boot disk3 -as
Example 2 Network Booting with WAN Boot-Capable PROMs
To illustrate some of the subtle repercussions of various boot command line invocations, assume that the network-
boot-arguments are set and that net is devaliased as shown in the commands below.
In the following command, device arguments in the device alias are processed by the device driver. The network
boot support package processes arguments in network-boot-arguments.
 boot net
The command below results in no device arguments. The network boot support package processes arguments in net<hy>
work-boot-arguments.
 boot net:
The command below results in no device arguments. rarp is the only network boot support package argument. net<hy>
work-boot-arguments is ignored.
 boot net:rarp
In the command below, the specified device arguments are honored. The network boot support package processes ar<hy>
guments in network-boot-arguments.
 boot net:speed=100,duplex=full
Example 3 Using wanboot with Older PROMs
The command below results in the wanboot binary being loaded from DVD or CD, at which time wanboot will per<hy>
form DHCP and then drop into its command interpreter to allow the user to enter keys and any other necessary con<hy>
figuration.
 boot cdrom -F wanboot -o dhcp,prompt
Example 4 To Boot the Default Kernel In 32-bit Single-User Interactive Mode
To boot the default kernel in single-user interactive mode, edit the GRUB kernel command line to read:
 kernel /platform/i86pc/kernel/unix -as
Example 5 To Boot the Default Kernel In 64-bit Single-User Interactive Mode
To boot the default kernel in single-user interactive mode, edit the GRUB kernel command line to read:
<beginning of page>
 kernel /platform/i86pc/kernel/amd64/unix -as
Example 6 Switching Between 32-bit and 64-bit Kernels on 64-bit x86 Platform
To be able to boot both 32-bit and 64-bit kernels, add entries for both kernels to /boot/grub/menu.lst, and use the
set-menu subcommand of bootadm(1M) to switch. See bootadm(1M) for an example of the bootadm set-menu.
/platform/platform-name/ufsboot
Second-level program to boot from a disk, DVD, or CD
/etc/inittab
Table in which the initdefault state is specified
/sbin/init
Program that brings the system to the initdefault state
/platform/platform-name/kernel/sparcv9/unix
Default program to boot system.
/boot
Directory containing boot-related files.
/boot/grub/menu.lst
Menu of bootable operating systems displayed by GRUB.
/platform/i86pc/kernel/unix
32-bit kernel.
/platform/i86pc/kernel/amd64/unix
64-bit kernel.
kmdb(1), uname(1), bootadm(1M), eeprom(1M), init(1M), installboot(1M), kernel(1M), monitor(1M), shut<hy>
down(1M), svcadm(1M), umountall(1M), zpool(1M), uadmin(2), bootparams(4), inittab(4), vfstab(4), wan<hy>
boot.conf(4), filesystem(5)
RFC 903, A Reverse Address Resolution Protocol, http://www.ietf.org/rfc/rfc903.txt
RFC 2131, Dynamic Host Configuration Protocol, http://www.ietf.org/rfc/rfc2131.txt
RFC 2132, DHCP Options and BOOTP Vendor Extensions, http://www.ietf.org/rfc/rfc2132.txt
RFC 2396, Uniform Resource Identifiers (URI): Generic Syntax, http://www.ietf.org/rfc/rfc2396.txt

Sun Hardware Platform Guide
OpenBoot Command Reference Manual
The boot utility is unable to determine which files can be used as bootable programs. If the booting of a file that is
not bootable is requested, the boot utility loads it and branches to it. What happens after that is unpredictable.
<beginning of page>
platform-name can be found using the -i option of uname(1). hardware-class-name can be found using the -m op<hy>
tion of uname(1).
The current release of the Solaris operating system does not support machines running an UltraSPARC-I CPU.
bsd_signal.3c <beginning of page>
bsd_signal <-> simplified signal facilities
#include <signal.h>
void (*bsd_signal(int sig, void (*func)(int)))(int);
The bsd_signal() function provides a partially compatible interface for programs written to historical system inter<hy>
faces (see USAGE below).
The function call bsd_signal(sig, func) has an effect as if implemented as:
 void (*bsd_signal(int sig, void (*func)(int)))(int)
 {
  struct sigaction act, oact;
  act.sa_handler = func;
  act.sa_flags = SA_RESTART;
  sigemptyset(&act.sa_mask);
  sigaddset(&act.sa_mask, sig);
  if (sigaction(sig, &act, &oact) == <mi>1)
  return(SIG_ERR);
  return(oact.sa_handler);
 }
The handler function should be declared:
 void handler(int sig);
where sig is the signal number. The behavior is undefined if func is a function that takes more than one argument, or
an argument of a different type.
Upon successful completion, bsd_signal() returns the previous action for sig. Otherwise, SIG_ERR is returned and
errno is set to indicate the error.
Refer to sigaction(2).
This function is a direct replacement for the BSD signal(3UCB) function for simple applications that are installing a
single-argument signal handler function. If a BSD signal handler function is being installed that expects more than
one argument, the application has to be modified to use sigaction(2). The bsd_signal() function differs from sig<hy>
nal(3UCB) in that the SA_RESTART flag is set and the SA_RESETHAND will be clear when bsd_signal() is
used. The state of these flags is not specified for signal(3UCB).
See attributes(5) for descriptions of the following attributes:
tab() box; lw(2.75i) |lw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStandard
sigaction(2), sigaddset(3C), sigemptyset(3C), signal(3UCB), attributes(5), standards(5)
abort.3c <beginning of page>
abort <-> terminate the process abnormally
#include <stdlib.h>
void abort(void);
The abort() function causes abnormal process termination to occur, unless the signal SIGABRT is being caught and
the signal handler does not return. The abnormal termination processing includes at least the effect of fclose(3C) on
all open streams and message catalogue descriptors, and the default actions defined for SIGABRT. The SIGABRT
signal is sent to the calling process as if by means of the raise(3C) function with the argument SIGABRT.
The status made available to wait(3C) or waitpid(3C) by abort will be that of a process terminated by the SIGA<hy>
BRT signal. abort will override blocking or ignoring the SIGABRT signal.
The abort() function does not return.
No errors are defined.
Catching the signal is intended to provide the application writer with a portable means to abort processing, free from
possible interference from any implementation-provided library functions. If SIGABRT is neither caught nor ig<hy>
nored, and the current directory is writable, a core dump may be produced.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelSafe
exit(2), getrlimit(2), kill(2), fclose(3C), raise(3C), signal(3C), wait(3C), waitpid(3C), attributes(5), standards(5)
acctadm.1m <beginning of page>
acctadm <-> configure extended accounting facility
/usr/sbin/acctadm [-DEsrux] [-d resource_list]
 [-e resource_list] [-f filename]
 [task | process | flow | net]
acctadm configures various attributes of the extended accounting facility. Without arguments, acctadm displays the
current status of the extended accounting facility.
The following options are supported:
-d resource_list
Disable reporting of resource usage for resource. Specify resource_list as a comma-separated list of resources or re<hy>
source groups.
This option requires an operand. See OPERANDS.
-D
Disable accounting of the given operand type without closing the accounting file. This option can be used to tempo<hy>
rarily stop writing accounting records to the accounting file without closing it. To close the file use the -x option. See
-x.
-e resource_list
Enable reporting of resource usage for resource. Specify resource_list as a comma-separated list of resources or re<hy>
source groups.
This option requires an operand. See OPERANDS.
-E
Enable accounting of the given operand type without sending the accounting output to a file. This option requires an
operand. See OPERANDS.
-f filename
Send the accounting output for the given operand type to filename. If filename exists, its contents must be of the giv<hy>
en accounting type.
This option requires an operand. See OPERANDS.
-r
Display available resource groups.
When this option is used with an operand, it displays resource groups available for a given accounting type. When
no operand is specified, this option displays resource groups for all available accounting types. See OPERANDS.
-s
Start method for the smf(5) instance. This option is used to restore the extended accounting configuration at boot.
-x
Deactivate accounting of the given operand type. This option also closes the accounting file for the given accounting
type if it is currently open.
This option requires an operand. See OPERANDS.
The -d, -D, -e, -E, -f, and -x options require an operand.
<beginning of page>
The following operands are supported:
process
Run acctadm on the process accounting components of the extended accounting facility.
task
Run acctadm on the task accounting components of the extended accounting facility.
flow
Run acctadm on the IPQoS accounting components of the extended accounting facility.
net
Run acctadm on links and flows administered by dladm(1M) and flowadm(1M), respectively. Basic network ac<hy>
counting relates only to links, while extended network accounting includes both link and flow accounting.
The optional final parameter to acctadm represents whether the command should act on the process, system task,
IPQoS, or network accounting components of the extended accounting facility. Example 1 Displaying the Current
Status
The following command displays the current status. In this example, system task accounting is active and tracking
only CPU resources. Process and flow accounting are not active.
 $ acctadm
  Task accounting: active
  Task accounting file: /var/adm/exacct/task
  Tracked task resources: extended
  Untracked task resources: host
  Process accounting: inactive
  Process accounting file: none
  Tracked process resources: none
 Untracked process resources: extended,host
  Flow accounting: inactive
  Flow accounting file: none
  Tracked flow resources: none
  Untracked flow resources: extended
  Net accounting: inactive
  Net accounting file: none
  Tracked Net resources: none
  Untracked Net resources: extended
Example 2 Activating Basic Process Accounting
The following command activates basic process accounting:
 $ acctadm -e basic -f /var/adm/exacct/proc process
Example 3 Displaying Available Resource Groups
The following command displays available resource groups:
 $ acctadm -r
  process:
  extended pid,uid,gid,cpu,time,command,tty,projid, \
  taskid,ancpid,wait-status,zone,flag,memory,mstate
<beginning of page>
  basic pid,uid,gid,cpu,time,command,tty,flag
  task:
  extended taskid,projid,cpu,time,host,mstate,anctaskid,zone
  basic taskid,projid,cpu,time
  flow:
  extended saddr,daddr,sport,dport,proto,dsfield,nbytes,npkts, \
  action,ctime,lseen,projid,uid
  basic saddr,daddr,sport,dport,proto,nbytes,npkts,action
  net:
  extended name,devname,edest,vlan_tpid,vlan_tci,sap,cpuid, \
  priority,bwlimit,curtime,ibytes,obytes,ipkts,opks,ierrpkts \
  oerrpkts,saddr,daddr,sport,dport,protocol,dsfield
  basic name,devname,edest,vlan_tpid,vlan_tci,sap,cpuid, \
  priority,bwlimit,curtime,ibytes,obytes,ipkts,opks,ierrpkts \
  oerrpkts
In the output above, the lines beginning with extended are shown with a backslash character. In actual acctadm out<hy>
put, these lines are displayed as unbroken, long lines.
Example 4 Displaying Resource Groups for Task Accounting
The following command displays resource groups for task accounting:
 $ acctadm -r task
  extended taskid,projid,cpu,time,host,mstate,anctaskid,zone
  basic taskid,projid,cpu,time
The following exit values are returned:
0
Successful completion.
The modifications to the current configuration were valid and made successfully.
1
An error occurred.
A fatal error occured either in obtaining or modifying the accounting configuration.
2
Invalid command line options were specified.
95
A fatal, non-configuration error occurred during the start of the smf(5) service instance.
96
A fatal configuration error occurred during the start of the smf(5) service instance.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
<beginning of page>
Wcsu _ Interface StabilityCommitted
dladm(1M), flowadm(1M), acct(2), attributes(5), smf(5), ipqos(7IPP)
Both extended accounting and regular accounting can be active.
Available resources can vary from system to system, and from platform to platform.
Extended accounting configuration is stored in the service management facility (smf(5)) repository. The configura<hy>
tion is restored at boot by a transient service instance, one per accounting type:
 svc:/system/extended-accounting:flow Flow accounting
 svc:/system/extended-accounting:process Process accounting
 svc:/system/extended-accounting:task Task accounting
 svc:/system/extended-accounting:net Network accounting
The instances are enabled or disabled by acctadm as needed. Configuration changes are made using acctadm; ser<hy>
vice properties should not be modified directly using svccfg(1M).
Users can manage extended accounting (start accounting, stop accounting, change accounting configuration parame<hy>
ters) if they have the appropriate RBAC Rights profile for the accounting type to be managed: <bu> Extended Account<hy>
ing Flow Management <bu> Extended Accounting Process Management <bu> Extended Accounting Task Management <bu> Ex<hy>
tended Accounting Network Management
The preceding profiles are for, respectively, flow accounting, process accounting, task accounting, and network ac<hy>
counting.
acl.2 <beginning of page>
acl, facl <-> get or set a file's Access Control List (ACL)
#include <sys/acl.h>
int acl(char *pathp, int cmd, int nentries, void *aclbufp);
int facl(int fildes, int cmd, int nentries, void *aclbufp);
The acl() and facl() functions get or set the ACL of a file whose name is given by pathp or referenced by the open
file descriptor fildes. The nentries argument specifies how many ACL entries fit into buffer aclbufp. The acl() func<hy>
tion is used to manipulate ACL on file system objects.
The following types are supported for aclbufp:
aclent_t Used by the UFS file system.
ace_t Used by the ZFS and NFSv4 file systems.
The following values for cmd are supported:
SETACL nentries aclent_t ACL entries, specified in buffer aclbufp, are stored in the file's ACL. All directories in
the path name must be searchable.
GETACL Buffer aclbufp is filled with the file's aclent_t ACL entries. Read access to the file is not required, but all
directories in the path name must be searchable.
GETACLCNT The number of entries in the file's aclent_t ACL is returned. Read access to the file is not required,
but all directories in the path name must be searchable.
ACE_SETACL nentries ace_t ACL entries, specified in buffer aclbufp, are stored in the file's ACL. All directories
in the path name must be searchable. Write ACL access is required to change the file's ACL.
ACE_GETACL Buffer aclbufp is filled with the file's ace_t ACL entries. Read access to the file is required and all
directories in the path name must be searchable.
ACE_GETACLCNT The number of entries in the file's ace_t ACL is returned. Read access to the file is required
and all directories in the path name must be searchable.
Upon successful completion, acl() and facl() return 0 if cmd is SETACL or ACE_SETACL. If cmd is GETACL,
GETACLCNT, ACE_GETACL or ACE_GETACLCNT, the number of ACL entries is returned. Otherwise, <mi>1 is
returned and errno is set to indicate the error.
The acl() function will fail if:
EACCES The caller does not have access to a component of the pathname.
EFAULT The pathp or aclbufp argument points to an illegal address.
EINVAL The cmd argument is not GETACL, SETACL, ACE_GETACL, GETACLCNT, or ACE_GETACLC<hy>
NT; the cmd argument is SETACL and nentries is less than 3; or the cmd argument is SETACL or ACE_SETA<hy>
CL and the ACL specified in aclbufp is not valid.
EIO A disk I/O error has occurred while storing or retrieving the ACL.
<beginning of page>
ENOENT A component of the path does not exist.
ENOSPC The cmd argument is GETACL and nentries is less than the number of entries in the file's ACL, or the
cmd argument is SETACL and there is insufficient space in the file system to store the ACL.
ENOSYS The cmd argument is SETACL or ACE_SETACL and the file specified by pathp resides on a file system
that does not support ACLs, or the acl() function is not supported by this implementation.
ENOTDIR A component of the path specified by pathp is not a directory, or the cmd argument is SETACL or
ACE_SETACL and an attempt is made to set a default ACL on a file type other than a directory.
ENOTSUP The cmd argument is GETACL, but the ACL is composed of ace_t entries, and the ACL cannot be
translated into aclent_t form.
The cmd argument is ACE_SETACL, but the underlying filesystem only supports ACLs composed of aclent_t en<hy>
tries and the ACL could not be translated into aclent_t form.
EPERM The effective user ID does not match the owner of the file and the process does not have appropriate privi<hy>
lege.
EROFS The cmd argument is SETACL or ACE_SETACL and the file specified by pathp resides on a file system
that is mounted read-only.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyEvolving
getfacl(1), setfacl(1), aclcheck(3SEC), aclsort(3SEC)
acltomode.3sec <beginning of page>
acltomode, aclfrommode <-> convert an ACL to or from permission bits
cc [ flag... ] file... -lsec [ library... ]
#include <sys/types.h>
#include <sys/acl.h>
int acltomode(aclent_t *aclbufp, int nentries, mode_t *modep);
int aclfrommode(aclent_t *aclbufp, int nentries, mode_t *modep);
The acltomode() function converts an ACL pointed to by aclbufp into the permission bits buffer pointed to by mod<hy>
ep. If the USER_OBJ ACL entry, GROUP_OBJ ACL entry, or the OTHER_OBJ ACL entry cannot be found in
the ACL buffer, then the function fails with errno set to EINVAL.
The USER_OBJ ACL entry permission bits are copied to the file owner class bits in the permission bits buffer. The
OTHER_OBJ ACL entry permission bits are copied to the file other class bits in the permission bits buffer. If there
is a CLASS_OBJ (ACL mask) entry, the CLASS_OBJ ACL entry permission bits are copied to the file group class
bits in the permission bits buffer. Otherwise, the GROUP_OBJ ACL entry permission bits are copied to the file
group class bits in the permission bits buffer.
The aclfrommode() function converts the permission bits pointed to by modep into an ACL pointed to by aclbufp. If
the USER_OBJ ACL entry, GROUP_OBJ ACL entry, or the OTHER_OBJ ACL entry cannot be found in the
ACL buffer, the function fails with errno set to EINVAL.
The file owner class bits from the permission bits buffer are copied to the USER_OBJ ACL entry. The file other
class bits from the permission bits buffer are copied to the OTHER_OBJ ACL entry. If there is a CLASS_OBJ
(ACL mask) entry, the file group class bits from the permission bits buffer are copied to the CLASS_OBJ ACL en<hy>
try, and the GROUP_OBJ ACL entry is not modified. Otherwise, the file group class bits from the permission bits
buffer are copied to the GROUP_OBJ ACL entry.
The nentries argument represents the number of ACL entries in the buffer pointed to by aclbufp.
Upon successful completion, the function returns 0. Otherwise, it returns <mi>1 and sets errno to indicate the error.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability
Evolving _ MT-LevelUnsafe
acl(2), attributes(5)
adbgen.1m <beginning of page>
adbgen <-> generate adb script
/usr/lib/adb/adbgen [-m model] filename.adb ...
adbgen makes it possible to write adb(1) scripts that do not contain hard-coded dependencies on structure member
offsets. The input to adbgen is a file named filename.adb that contains header information, then a null line, then the
name of a structure, and finally an adb script. adbgen only deals with one structure per file; all member names are
assumed to be in this structure. The output of adbgen is an adb script in filename. adbgen operates by generating a
C program which determines structure member offsets and sizes, which in turn generate the adb script.
The header lines, up to the null line, are copied verbatim into the generated C program. Typically, these are #include
statements, which include the headers containing the relevant structure declarations.
The adb script part may contain any valid adb commands (see adb(1)), and may also contain adbgen requests, each
enclosed in braces ({}). Request types are: <bu> Print a structure member. The request form is {member,format}. mem<hy>
ber is a member name of the structure given earlier, and format is any valid adb format request or any of the adb<hy>
gen format specifiers (such as {POINTER}) listed below. For example, to print the p_pid field of the proc structure
as a decimal number, you would write {p_pid,d}. <bu> Print the appropriate adb format character for the given adbgen
format specifier. This action takes the data model into consideration. The request form is {format specifier}. The
valid adbgen format specifiers are:
{POINTER} pointer value in hexadecimal
{LONGDEC} long value in decimal
{ULONGDEC} unsigned long value in decimal
{ULONGHEX} unsigned long value in hexadecimal
{LONGOCT} long value in octal
{ULONGOCT} unsigned long value in octal
<bu> Reference a structure member. The request form is {*member,base}. member is the member name whose value is
desired, and base is an adb register name which contains the base address of the structure. For example, to get the
p_pid field of the proc structure, you would get the proc structure address in an adb register, for example <f, and
write {*p_pid,<f}. <bu> Tell adbgen that the offset is valid. The request form is {OFFSETOK}. This is useful after in<hy>
voking another adb script which moves the adb dot. <bu> Get the size of the structure. The request form is {SIZEOF}.
adbgen replaces this request with the size of the structure. This is useful in incrementing a pointer to step through an
array of structures. <bu> Calculate an arbitrary C expression. The request form is {EXPR,expression}. adbgen replaces
this request with the value of the expression. This is useful when more than one structure is involved in the script. <bu>
Get the offset to the end of the structure. The request form is {END}. This is useful at the end of the structure to get
adb to align the dot for printing the next structure member.
adbgen keeps track of the movement of the adb dot and generates adb code to move forward or backward as neces<hy>
sary before printing any structure member in a script. adbgen's model of the behavior of adb's dot is simple: it is as<hy>
sumed that the first line of the script is of the form struct_address/adb text and that subsequent lines are of the form
+/adb text. The adb dot then moves in a sane fashion. adbgen does not check the script to ensure that these limita<hy>
tions are met. adbgen also checks the size of the structure member against the size of the adb format code and
warns if they are not equal.
The following option is supported:
-m model Specifies the data type model to be used by adbgen for the macro. This affects the outcome of the {format
specifier} requests described under DESCRIPTION and the offsets and sizes of data types. model can be ilp32 or
lp64. If the -m option is not given, the data type model defaults to ilp32.
The following operand is supported:
<beginning of page>
filename.adb Input file that contains header information, followed by a null line, the name of the structure, and final<hy>
ly an adb script.
Example 1 A sample adbgen file.
For an include file x.h which contained
 struct x {
  char *x_cp;
  char x_c;
  int x_i;
 };
then , an adbgen file (call it script.adb) to print the file x.h would be:
 #include "x.h"
 x
 ./"x_cp"16t"x_c"8t"x_i"n{x_cp,{POINTER}}{x_c,C}{x_i,D}
After running adbgen as follows,
 % /usr/lib/adb/adbgen script.adb
the output file script contains:
 ./"x_cp"16t"x_c"8t"x_i"nXC3+D
For a macro generated for a 64-bit program using the lp64 data model as follows,
 % /usr/lib/adb/adbgen/ -m lp64 script.adb
the output file script would contain:
 ./"x_cp"16t"x_c"8t"x_i"nJC3+D
To invoke the script, type:
 example% adb program
 x$<script
/usr/platform/platform-name/lib/adb/*
platform-specific adb scripts for debugging the 32-bit kernel
<beginning of page>
/usr/platform/platform-name/lib/adb/sparcv9/*
platform-specific adb scripts for debugging the 64-bit SPARC V9 kernel
/usr/lib/adb/*
adb scripts for debugging the 32-bit kernel
/usr/lib/adb/sparcv9/*
adb scripts for debugging the 64-bit SPARC V9 kernel
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wesu
adb(1), uname(1), kadb(1M), attributes(5)
Warnings are given about structure member sizes not equal to adb format items and about badly formatted requests.
The C compiler complains if a structure member that does not exist is referenced. It also complains about an amper<hy>
sand before array names; these complaints may be ignored.
platform-name can be found using the -i option of uname(1).
adb syntax is ugly; there should be a higher level interface for generating scripts.
Structure members which are bit fields cannot be handled because C will not give the address of a bit field. The ad<hy>
dress is needed to determine the offset.
addnwstr.3xcurses <beginning of page>
addnwstr, addwstr, mvaddnwstr, mvaddwstr, mvwaddnwstr, mvwaddwstr, waddnwstr, waddwstr <-> add a wide-char<hy>
acter string to a window
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library ... ]
#include <curses.h>
int addnwstr(const wchar_t *wstr, int n);
int addwstr(const wchar_t *wstr);
int mvaddnwstr(int y, int x, const wchar_t *wstr, int n);
int mvaddwstr(int y, int x, const wchar_t *wstr);
int mvwaddnwstr(WINDOW*win, int y, int x, const wchar_t *wstr, int n);
int mvwaddwstr(WINDOW*win, int y, int x, const wchar_t *wstr);
int waddnwstr(WINDOW*win, const wchar_t *wstr, int n);
int waddwstr(WINDOW*win, const wchar_t *wstr);
The addwstr() function writes a null-terminated wide-character string to the stdscr window at the current cursor
position. The waddwstr() function performs an identical action, but writes the string to the window specified by
win. The mvaddwstr() and mvwaddwstr() functions write the string to the position indicated by the x (column)
and y (row) parameters (the former to the stdscr window; the latter to window win).
The addnwstr(), waddnwstr(), mvaddnwstr(), and mvwaddnwstr() functions write at most n characters to the
window. If n is less than 0, the entire string is written. The former two functions place the characters at the current
cursor position; the latter two commands use the position specified by the x and y parameters.
All of these functions advance the cursor after writing the string.
These functions are functionally equivalent to building a cchar_t from the wchar_t and the window rendition (or
background character and rendition) and calling the wadd_wch(3XCURSES) function once for each wchar_t in
the string. Refer to the curses(3XCURSES) man page for a complete description of special character handling and
of the interaction between the window rendition (or background character and rendition) and the character written.
Note that these functions differ from the add_wchnstr(3XCURSES) set of functions in that the latter copy the
string as is (without combining each character with the foreground and background attributes of the window).
wstr Is a pointer to the wide-character string that is to be written to the window.
n Is the maximum number of characters to be copied from wstr. If n is less than 0, the entire string is written or as
much of it as fits on the line.
y Is the y (row) coordinate of the starting position of wstr in the window.
x Is the x (column) coordinate of the starting position of wstr in the window.
win Is a pointer to the window in which the string is to be written.
On success, these functions return OK. Otherwise, they return ERR.
None.
See attributes(5) for descriptions of the following attributes:
<beginning of page>
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
add_wch(3XCURSES), add_wchnstr(3XCURSES), curses(3XCURSES), libcurses(3XCURSES), attributes(5),
standards(5)
afe.7d <beginning of page>
afe <-> ADMtek Fast Ethernet device driver
/dev/afe
The afe driver is a multi-threaded, loadable, clonable, GLD-based STREAMS driver supporting the Data Link
Provider Interface dlpi(7P) on ADMtek (now Infineon) Centaur and Comet Fast Ethernet controllers.
The afe driver can be used as either a "style 1" or a "style 2" Data Link Service Provider. Physical points of attach<hy>
ment (PPAs) are interpreted as the instance number of the afe controller as assigned by the Solaris operating envi<hy>
ronment.
The relevant fields returned as part of a DL_INFO_ACK response are: <bu> Maximum SDU is 1500. <bu> Minimum SDU
is 0. <bu> The dlsap address length is 8. <bu> MAC type is DL_ETHER. <bu> SAP length is -2. The 6-byte physical address
is followed immediately by a 2-byte SAP. <bu> Service mode is DL_CLDLS. <bu> Broadcast address is the 6-byte Ether<hy>
net broadcast address (ff:ff:ff:ff:ff:ff).
If the SAP provided is zero, then IEEE 802.3 mode is assumed and outbound frames will have the frame payload
length written into the type field. Likewise, inbound frames with a SAP between zero and 1500 are interpreted as
IEEE 802.3 frames and delivered to any streams that are bound to SAP zero (the 802.3 SAP).
The following properties may be configured using either ndd(1M) or the afe.conf configuration file as described
by driver.conf(4):
adv_autoneg_cap
Enables (default) or disables IEEE 802.3u auto-negotiation of link speed and duplex settings. If enabled, the device
negotiates among the supported (and configured, see below) link options with the link partner. If disabled, at least
one of the link options below must be specified. The driver selects the first enabled link option according to the IEEE
802.3u specified preferences.
adv_100T4_cap
Enables the 100 BaseT4 link option. (Note that most hardware does not support this unusual link style. Also, this
uses two pairs of wires for data, rather than one.)
adv_100fdx_cap
Enables the 100 Base TX full-duplex link option. (This is generally the fastest mode if both link partners support it.
Most modern equipment supports this mode.)
adv_100hdx_cap
Enables the 100 Base TX half-duplex link option. (Typically used when the link partner is a 100 Mbps hub.)
adv_10fdx_cap
Enables the 10 Base-T full-duplex link option. (This less-frequently used mode is typically used when the link part<hy>
ner is a 10 Mbps switch.)
adv_10hdx_cap
Enables the 10 Base-T half-duplex link option. (This is the fall-back when no other option is available. It is typical<hy>
ly used when the link partner is a 10 Mbps hub or is an older network card.)
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySPARC,
x86 _ Interface Stability Committed
<beginning of page>
/dev/afe
Special character device.
/kernel/drv/afe
32-bit driver binary (x86).
/kernel/drv/amd64/afe
64-bit driver binary (x86).
/kernel/drv/sparcv9/afe
64-bit driver binary (SPARC).
/kernel/drv/afe.conf
Configuration file.
ndd(1M), driver.conf(4), attributes(5), streamio(7I), dlpi(7P)
IEEE 802.3 <em> Institute of Electrical and Electronics Engineers, 2002
aio_read.3c <beginning of page>
aio_read <-> asynchronous read from a file
#include <aio.h>
int aio_read(struct aiocb *aiocbp);
The aio_read() function allows the calling process to read aiocbp->aio_nbytes from the file associated with
aiocbp->aio_fildes into the buffer pointed to by aiocbp->aio_buf. The function call returns when the read request
has been initiated or queued to the file or device (even when the data cannot be delivered immediately). If
_POSIX_PRIORITIZED_IO is defined and prioritized I/O is supported for this file, then the asynchronous opera<hy>
tion is submitted at a priority equal to the scheduling priority of the process minus aiocbp->aio_reqprio. The aiocbp
value may be used as an argument to aio_error(3C) and aio_return(3C) in order to determine the error status and
return status, respectively, of the asynchronous operation while it is proceeding. If an error condition is encountered
during queuing, the function call returns without having initiated or queued the request. The requested operation
takes place at the absolute position in the file as given by aio_offset, as if lseek(2) were called immediately prior to
the operation with an offset equal to aio_offset and a whence equal to SEEK_SET. After a successful call to en<hy>
queue an asynchronous I/O operation, the value of the file offset for the file is unspecified.
The aiocbp->aio_sigevent structure defines what asynchronous notification is to occur when the asynchronous oper<hy>
ation completes, as specified in signal.h(3HEAD).
The aiocbp->aio_lio_opcode field is ignored by aio_read().
The aiocbp argument points to an aiocb structure. If the buffer pointed to by aiocbp->aio_buf or the control block
pointed to by aiocbp becomes an illegal address prior to asynchronous I/O completion, then the behavior is unde<hy>
fined.
Simultaneous asynchronous operations using the same aiocbp produce undefined results.
If _POSIX_SYNCHRONIZED_IO is defined and synchronized I/O is enabled on the file associated with
aiocbp->aio_fildes, the behavior of this function is according to the definitions of synchronized I/O data integrity
completion and synchronized I/O file integrity completion.
For any system action that changes the process memory space while an asynchronous I/O is outstanding to the ad<hy>
dress range being changed, the result of that action is undefined.
For regular files, no data transfer will occur past the offset maximum established in the open file description associ<hy>
ated with aiocbp->aio_fildes.
The aio_read() function returns 0 to the calling process if the I/O operation is successfully queued; otherwise, the
function returns <mi>1 and sets errno to indicate the error.
The aio_read() function will fail if:
EAGAIN The requested asynchronous I/O operation was not queued due to system resource limitations.
Each of the following conditions may be detected synchronously at the time of the call to aio_read(), or asyn<hy>
chronously. If any of the conditions below are detected synchronously, the aio_read() function returns -1 and sets
errno to the corresponding value. If any of the conditions below are detected asynchronously, the return status of the
asynchronous operation is set to <mi>1, and the error status of the asynchronous operation will be set to the correspond<hy>
ing value.
EBADF The aiocbp->aio_fildes argument is not a valid file descriptor open for reading.
EINVAL The file offset value implied by aiocbp->aio_offset would be invalid, aiocbp->aio_reqprio is not a valid
value, or aiocbp->aio_nbytes is an invalid value.
In the case that the aio_read() successfully queues the I/O operation but the operation is subsequently canceled or
encounters an error, the return status of the asynchronous operation is one of the values normally returned by the
read(2) function call. In addition, the error status of the asynchronous operation will be set to one of the error status<hy>
es normally set by the read() function call, or one of the following values:
<beginning of page>
EBADF The aiocbp->aio_fildes argument is not a valid file descriptor open for reading.
ECANCELED The requested I/O was canceled before the I/O completed due to an explicit aio_cancel(3C) request.
EINVAL The file offset value implied by aiocbp->aio_offset would be invalid.
The following condition may be detected synchronously or asynchronously:
EOVERFLOW The file is a regular file, aiobcp->aio_nbytes is greater than 0 and the starting offset in
aiobcp->aio_offset is before the end-of-file and is at or beyond the offset maximum in the open file description asso<hy>
ciated with aiocbp->aio_fildes.
For portability, the application should set aiocb->aio_reqprio to 0.
The aio_read() function has a transitional interface for 64-bit file offsets. See lf64(5).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe _ StandardSee standards(5).
close(2), exec(2), exit(2), fork(2), lseek(2), read(2), write(2), aio_cancel(3C), aio_return(3C), aio.h(3HEAD),
lio_listio(3C), siginfo.h(3HEAD), signal.h(3HEAD), attributes(5), lf64(5), standards(5)
alarm.2 <beginning of page>
alarm <-> schedule an alarm signal
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
The alarm() function causes the system to generate a SIGALRM signal for the process after the number of real-
time seconds specified by seconds have elapsed (see signal.h(3HEAD)). Processor scheduling delays may prevent
the process from handling the signal as soon as it is generated.
If seconds is 0, a pending alarm request, if any, is cancelled. If seconds is greater than LONG_MAX/hz, seconds is
rounded down to LONG_MAX/hz. The value of hz is normally 100.
Alarm requests are not stacked; only one SIGALRM generation can be scheduled in this manner; if the SIGAL<hy>
RM signal has not yet been generated, the call will result in rescheduling the time at which the SIGALRM signal
will be generated.
The fork(2) function clears pending alarms in the child process. A new process image created by one of the exec(2)
functions inherits the time left to an alarm signal in the old process's image.
If there is a previous alarm request with time remaining, alarm() returns a non-zero value that is the number of
seconds until the previous request would have generated a SIGALRM signal. Otherwise, alarm() returns 0.
The alarm() function is always successful; no return value is reserved to indicate an error.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelAsync-Signal-Safe
exec(2), fork(2), signal.h(3HEAD), attributes(5), standards(5)
amr.7d <beginning of page>
amr <-> SCSI HBA driver for Dell PERC 3/DC, 4/SC, 4/DC and 4/DI
The amr plain SCSI host bus adapter driver is a SCSA-compliant nexus driver that supports the Dell PERC
3DC/4SC/4DC/4Di RAID devices.
The amr driver ports from FreeBSD and only supports basic RAID disk I/O functions.
There are no user configurable parameters available. Please configure your hardware through BIOS.
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Availabilityx86
/kernel/drv/amr 32-bit ELF kernel module.
/kernel/drv/amd64/amr 64-bit kernel module (x86 only).
/kernel/drv/amr.conf Driver configuration file (contains no user-configurable options).
prtconf(1M), attributes(5), lsimega(7D), scsi_hba_attach_setup(9F), scsi_sync_pkt(9F), scsi_transport(9F), sc<hy>
si_inquiry(9S), scsi_device(9S), scsi_pkt(9S)
Small Computer System Interface-2 (SCSI-2)
arch.1 <beginning of page>
arch <-> display the architecture of the current host
arch [-k | archname]
The arch utility displays the application architecture of the current host system. Due to extensive historical use of
this command without any options, all SunOS 5.x SPARC based systems will return "sun4" as their application ar<hy>
chitecture. Use of this command is discouraged. See NOTES section below.
Systems can be broadly classified by their architectures, which define what executables will run on which ma<hy>
chines. A distinction can be made between kernel architecture and application architecture (or, commonly, just "ar<hy>
chitecture"). Machines that run different kernels due to underlying hardware differences may be able to run the same
application programs.
-k Displays the kernel architecture, such as sun4u. This defines which specific SunOS kernel will run on the ma<hy>
chine, and has implications only for programs that depend on the kernel explicitly (for example, ps(1)).
The following operand is supported:
archname Use archname to determine whether the application binaries for this application architecture can run on
the current host system. The archname must be a valid application architecture, such as sun4, i86pc, and so forth.
If application binaries for archname can run on the current host system, TRUE (0) is returned. Otherwise, FALSE
(1) is returned.
The following exit values are returned:
0 Successful completion.
>0 An error occurred.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
mach(1), ps(1), uname(1), attributes(5)
This command is provided for compatibility with previous releases and its use is discouraged. Instead, the uname
command is recommended. See uname(1) for usage information.
as.1 <beginning of page>
as <-> assembler
as [-b] [-i] [-K {pic,PIC}] [-L] [-m] [-n] [-o outfile]
 [-P] [-Dname] [-Dname=def] [-Ipath] [-Uname]... [-q]
 [-Qy | n] [-s] [-S [a | b | c | l | A | B | C | L]]
 [-T] [-V]
 [-xarch=v7 | -xarch=v8 | -xarch=v8a | -xarch=v8plus |
 -xarch=v8plusa | -xarch=v8plusb | -xarch=v8plusd |
 -xarch=v8plusv | -xarch=v9 | -xarch=v9a |
 -xarch=v9b | -xarch=v9d | -xarch=v9v]
 [-xF] [-Y dirname] filename...
as [-b] [-i] [-K PIC] [-L] [-m] [-n] [-o outfile] [-P]
 [-Dname] [-Dname=def] [-Ipath] [-Uname]... [-Qy | n]
 [-s] [-S [a | b | c | l | A | B | C | L]] [-T] [-V]
 [-xarch=generic64 | -xarch=amd64] [-Y dirname]
 [-xmodel= [ SMALL | KERNEL ]] filename...
The as command creates object files from assembly language source files.
The following flags are common to both SPARC and x86. They can be specified in any order:
-b Generates extra symbol table information.
-i Ignore line number information from preprocessor.
-K pic | PIC Generates position-independent code.
-L Saves all symbols, including temporary labels that are normally discarded to save space, in the ELF symbol table.
-m Runs the m4(1) macro processor on the input to the assembler.
-n Suppresses all the warnings while assembling.
-o outfile Puts the output of the assembly in outfile. By default, the output file name is formed by removing the .s
suffix, if there is one, from the input file name and appending a .o suffix.
-P Runs cpp(1), the C preprocessor, on the files being assembled. The preprocessor is run separately on each input
file, not on their concatenation. The preprocessor output is passed to the assembler.
-Dname
-Dname=def When the -P option is in effect, these options are passed to the cpp(1) preprocessor without interpreta<hy>
tion by the as command; otherwise, they are ignored.
-Ipath When the -P option is in effect, this option is passed to the cpp(1) preprocessor without interpretation by the
as command; otherwise, it is ignored.
-Uname When the -P option is in effect, this option is passed to the cpp(1) preprocessor without interpretation by
the as command; otherwise, it is ignored.
-Qy | n If y is specified, this option produces the assembler version information in the comment section of the output
object file. If n is specified, the information is suppressed.
-s Places all stabs in the .stabs section. By default, stabs are placed in stabs.excl sections, which are stripped out by
the static linker, ld(1), during final execution. When the -s option is used, stabs remain in the final executable be<hy>
<beginning of page>
cause .stab sections are not stripped by the static linker.
-S[a|b|c|l|A|B|C|L] Produces a disassembly of the emitted code to the standard output. Adding each of the following
characters to the -S option produces:
a disassembling with address
b disassembling with ".bof"
c disassembling with comments
l disassembling with line numbers
Capital letters turn the switch off for the corresponding option.
-T This is a migration option for 4.x assembly files to be assembled on 5.x systems. With this option, the symbol
names in 4.x assembly files are interpreted as 5.x symbol names.
-V Writes the version number of the assembler being run on the standard error output.
-xF Allows function reordering by the Performance Analyzer. If you compile with the -xF option, and then run the
Performance Analyzer, you can generate a map file that shows an optimized order for the functions. The subsequent
link to build the executable file can be directed to use that map file by using the linker -M mapfile option. It places
each function from the executable file into a separate section.
-Y dirname Specify directory m4 and/or cm4def.
-q Performs a quick assembly. When the -q option is used, many error checks are not performed. This option dis<hy>
ables many error checks. Use of this option to assemble handwritten assembly language is not recommended.
-xarch=v7 This option instructs the assembler to accept instructions defined in the SPARC version 7 (V7) architec<hy>
ture. The resulting object code is in ELF format.
-xarch=v8 This option instructs the assembler to accept instructions defined in the SPARC-V8 architecture, less the
quad-precision floating-point instructions. The resulting object code is in ELF format.
-xarch=v8a This option instructs the assembler to accept instructions defined in the SPARC-V8 architecture, less the
quad-precision floating-point instructions and less the fsmuld instruction. The resulting object code is in ELF format.
This is the default choice of the -xarch=options.
-xarch=v8plus This option instructs the assembler to accept instructions defined in the SPARC-V9 architecture, less
the quad-precision floating-point instructions. The resulting object code is in ELF format. It does not execute on a
Solaris V8 system (a machine with a V8 processor). It executes on a Solaris V8+ system. This combination is a
SPARC 64-bit processor and a 32-bit OS.
-xarch=v8plusa This option instructs the assembler to accept instructions defined in the SPARC-V9 architecture,
less the quad-precision floating-point instructions, plus the instructions in the Visual Instruction Set (VIS). The re<hy>
sulting object code is in V8+ ELF format. It does not execute on a Solaris V8 system (a machine with a V8 proces<hy>
sor). It executes on a Solaris V8+ system
<beginning of page>
-xarch=v8plusb This option enables the assembler to accept instructions defined in the SPARC-V9 architecture,
plus the instructions in the Visual Instruction Set (VIS), with UltraSPARC-III extensions. The resulting object code
is in V8+ ELF32 format.
-xarch=v8plusd This option enables the assembler to accept instructions DEFIned in UltraSPARC Architecture
2009. The resulting object code is in V8+ ELF32 format.
-xarch=v8plusv This option enables the assembler to accept instructions defined in UltraSPARC Architecture 2005,
including the extensions dealing with the sun4v virtual machine model. The resulting object code is in V8+ ELF32
format.
-xarch=v9 This option limits the instruction set to the SPARC-V9 architecture. The resulting .o object files are in
64-bit ELF format and can only be linked with other object files in the same format. The resulting executable can
only be run on a 64-bit SPARC processor running 64-bit Solaris with the 64-bit kernel.
-xarch=v9a This option limits the instruction set to the SPARC-V9 architecture, adding the Visual Instruction Set
(VIS) and extensions specific to UltraSPARC processors. The resulting .o object files are in 64-bit ELF format and
can only be linked with other object files in the same format. The resulting executable can only be run on a 64-bit
SPARC processor running 64-bit Solaris with the 64-bit kernel.
-xarch=v9b This option enables the assembler to accept instructions defined in the SPARC-V9 architecture, plus the
Visual Instruction Set (VIS), with UltraSPARC-III extensions. The resulting .o object files are in ELF64 format and
can only be linked with other V9 object files in the same format. The resulting executable can only be run on a
64-bit processor running a 64-bit Solaris operating environment with the 64-bit kernel.
-xarch=v9d This option enables the assembler to accept instructions defined in UltraSPARC Architecture 2009. The
resulting object code is in ELF64 format.
-xarch=v9v This option enables the assembler to accept instructions defined in UltraSPARC Architecture 2005, in<hy>
cluding the extensions dealing with the sun4v virtual machine model. The resulting object code is in ELF64 format.
-xarch>=generic64 Limits the instruction set to AMD64. The resulting object code is in 64-bit ELF format.
-xarch=amd64 Limits the instruction set to AMD64. The resulting object code is in 64-bit ELF format.
-xmodel=[SMALL | KERNEL] For AMD64 only, generate R_X86_64_32S relocatable type for static data access
under KERNEL. Otherwise, generate R_X86_64_32 under SMALL. SMALL is the default.
The following operand is supported:
filename Assembly language source file
TMPDIR The as command normally creates temporary files in the directory /tmp. Another directory can be speci<hy>
fied by setting the environment variable TMPDIR to the chosen directory. (If TMPDIR is not a valid directory, then
as uses /tmp).
By default, as creates its temporary files in /tmp.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
<beginning of page>
Wsprot
cpp(1),ld(1), m4(1), nm(1), strip(1), tmpnam(3C), a.out(4), attributes(5)
dbx and analyzer manual pages available with Sun Studio documentation.
If the -m option, which invokes the m4(1) macro processor, is used, keywords for m4 cannot be used as symbols
(variables, functions, labels) in the input file, since m4 cannot determine which keywords are assembler symbols and
which keywords are real m4 macros.
Whenever possible, access the assembler through a compilation system interface program.
All undefined symbols are treated as global.
asy.7d <beginning of page>
asy <-> asynchronous serial port driver
#include <fcntl.h>
#include <sys/termios.h>
open("/dev/term/n", mode);
open("/dev/tty/n", mode);
open("/dev/cua/n", mode);
The asy module is a loadable STREAMS driver that provides basic support for Intel-8250, National Semiconduc<hy>
tor-16450, 16550, and some 16650 and 16750 and equivalent UARTs connected via the ISA-bus, in addition to basic
asynchronous communication support. The asy module supports those termio(7I) device control functions specified
by flags in the c_cflag word of the termios structure, and by the IGNBRK, IGNPAR, PARMRK, INPCK, IXON,
IXANY, or IXOFF flags in the c_iflag word of the termios structure. All other termio(7I) functions must be per<hy>
formed by STREAMS modules pushed atop the driver. When a device is opened, the ldterm(7M) and ttcom<hy>
pat(7M) STREAMS modules are automatically pushed on top of the stream, providing the standard termio(7I) in<hy>
terface.
The character-special devices /dev/term/a, /dev/term/b, /dev/term/c and /dev/term/d are used to access the four
standard serial ports (COM1, COM2, COM3 and COM4 at I/O addresses 3f8, 2f8, 3e8 and 2e8 respectively). Serial
ports on non-standard ISA-bus I/O addresses are accessed via the character-special devices /dev/term/0,
/dev/term/1, etc. Device names are typically used to provide a logical access point for a dial-in line that is used with
a modem.
To allow a single tty line to be connected to a modem and used for incoming and outgoing calls, a special feature is
available that is controlled by the minor device number. By accessing character-special devices with names of the
form /dev/cua/n, it is possible to open a port without the Carrier Detect signal being asserted, either through hard<hy>
ware or an equivalent software mechanism. These devices are commonly known as dial-out lines. Note -
This module is affected by the setting of certain eeprom variables, ttya-ignore-cd and ttya-rts-dtr-off (and similarly
for ttyb-, ttyc-, and ttyd- parameters). For information on these parameters, see the eeprom(1M) man page. Note -
For serial ports on the standard COM1 to COM4 I/O addresses above, the default setting for ttya-ignore-cd and ttya-
rts-dtr-off is true. If any of these ports are connected to a modem, these settings should be changed to false. For seri<hy>
al ports on non-standard I/O addresses, the default setting for ttya-ignore-cd and ttya-rts-dtr-off is false.
Once a /dev/cua/n line is opened, the corresponding tty line cannot be opened until the /dev/cua/n line is closed. A
blocking open will wait until the /dev/cua/n line is closed (which will drop Data Terminal Ready, after which Car<hy>
rier Detect will usually drop as well) and carrier is detected again. A non-blocking open will return an error. If the
/dev/ttydn line has been opened successfully (usually only when carrier is recognized on the modem), the corre<hy>
sponding /dev/cua/n line cannot be opened. This allows a modem to be attached to /dev/term/[n] (renamed from
/dev/tty[n]) and used for dial-in (by enabling the line for login in /etc/inittab) or dial-out (by tip(1) or uucp(1C)) as
/dev/cua/n when no one is logged in on the line.
The standard set of termio ioctl() calls are supported by asy.
Breaks can be generated by the TCSBRK, TIOCSBRK, and TIOCCBRK ioctl() calls.
The input and output line speeds may be set to any speed that is supported by termio. The speeds cannot be set inde<hy>
pendently; for example, when the output speed is set, the input speed is automatically set to the same speed.
When the asy module is used to service the serial console port, it supports a BREAK condition that allows the sys<hy>
tem to enter the debugger or the monitor. The BREAK condition is generated by hardware and it is usually enabled
by default.
A BREAK condition originating from erroneous electrical signals cannot be distinguished from one deliberately sent
by remote DCE. The Alternate Break sequence can be used as a remedy against this. Due to a risk of incorrect se<hy>
quence interpretation, SLIP and certain other binary protocols should not be run over the serial console port when
Alternate Break sequence is in effect. Although PPP is a binary protocol, it is able to avoid these sequences using the
ACCM feature in RFC 1662. For Solaris PPP 4.0, you do this by adding the following line to the /etc/ppp/options
file (or other configuration files used for the connection; see pppd(1M) for details):
 asyncmap 0x00002000
<beginning of page>
By default, the Alternate Break sequence is a three character sequence: carriage return, tilde and control-B (CR ~
CTRL-B), but may be changed by the driver. For more information on breaking (entering the debugger or monitor),
see kbd(1) and kb(7M).
An open() will fail under the following conditions:
ENXIO The unit being opened does not exist.
EBUSY The dial-out device is being opened while the dial-in device is already open, or the dial-in device is being
opened with a no-delay open and the dial-out device is already open.
EBUSY The unit has been marked as exclusive-use by another process with a TIOCEXCL ioctl() call.
EINTR The open was interrupted by the delivery of a signal.
/dev/term/[a-d]
/dev/term/[012...] dial-in tty lines
/dev/cua/[a-d]
/dev/cua/[012...]
 dial-out tty lines
/kernel/drv/amd64/asy 64-bit kernel module for 64-bit x86 platform
/kernel/drv/asy.conf asy configuration file
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86
tip(1), kbd(1), uucp(1C), eeprom(1M), pppd(1M), ioctl(2), open(2), termios(3C), attributes(5), ldterm(7M),
ttcompat(7M), kb(7M), termio(7I)
asyn: silo overflow.
The hardware overrun occurred before the input character could be serviced.
asyn: ring buffer overflow.
The driver's character input ring buffer overflowed before it could be serviced.
ath.7d <beginning of page>
ath <-> Atheros AR52xx 802.11b/g wireless NIC driver
The ath 802.11b/g wireless NIC driver is a multi-threaded, loadable, clonable, GLDv3-based STREAMS driver
for the Atheros AR52xx (AR5210/5211/5212) chipset-based wireless NIC.
The ath driver functions include controller initialization, wireless 802.11b/g infrastructure network connection,
WEP, frame transmit and receive, and promiscuous and multi-cast support.
The ath driver performs auto-negotiation to determine the data rates and mode. Supported 802.11b data rates
(Mbits/sec.) are 1, 2, 5.5 and 11. Supported 802.11g data rates (Mbits/sec.) are 1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48
and 54.
 The ath driver supports only BSS networks (also known as "ap" or "infrastructure" networks) and the "open" (or
"opensystem") authentication type. Only WEP encryption is currently supported. Configuration and administration
can be performed through the dladm(1M) or wificonfig(1M) utilities.
/dev/ath* Special character device.
/kernel/drv/ath 32-bit ELF kernel module (x86).
/kernel/drv/amd64/ath 64-bit ELF kernel module (x86).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86
dladm(1M), wificonfig(1M), gld(7D)
ANSI/IEEE Std 802.11- Standard for Wireless LAN Technology, 1999.
IEEE Std 802.11a- Standard for Wireless LAN Technology-Rev. A, 2003
IEEE Std 802.11b - Standard for Wireless LAN Technology-Rev.B, 2003
IEEE Std 802.11g<em> Standard for Wireless LAN Technology - Rev. G, 2003
atomic_cas.3c <beginning of page>
atomic_cas, atomic_cas_8, atomic_cas_uchar, atomic_cas_16, atomic_cas_ushort, atomic_cas_32, atomic_cas_uint,
atomic_cas_ulong, atomic_cas_64, atomic_cas_ptr <-> atomic compare and swap operations
#include <atomic.h>
uint8_t atomic_cas_8(volatile uint8_t *target, uint8_t cmp,
 uint8_t newval);
uchar_t atomic_cas_uchar(volatile uchar_t *target, uchar_t cmp,
 uchar_t newval);
uint16_t atomic_cas_16(volatile uint16_t *target, uint16_t cmp,
 uint16_t newval);
ushort_t atomic_cas_ushort(volatile ushort_t *target, ushort_t cmp,
 ushort_t newval);
uint32_t atomic_cas_32(volatile uint32_t *target, uint32_t cmp,
 uint32_t newval);
uint_t atomic_cas_uint(volatile uint_t *target, uint_t cmp,
 uint_t newval);
ulong_t atomic_cas_ulong(volatile ulong_t *target, ulong_t cmp,
 ulong_t newval);
uint64_t atomic_cas_64(volatile uint64_t *target, uint64_t cmp,
 uint64_t newval);
void *atomic_cas_ptr(volatile void *target, void *cmp,
 void *newval);
These functions enable a compare and swap operation to occur atomically. The value stored in target is compared
with cmp. If these values are equal, the value stored in target is replaced with newval. The old value stored in target
is returned by the function whether or not the replacement occurred.
These functions return the old value of *target.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
atomic_add(3C), atomic_and(3C), atomic_bits(3C), atomic_dec(3C), atomic_inc(3C), atomic_or(3C), atom<hy>
ic_swap(3C), membar_ops(3C), attributes(5), atomic_ops(9F)
atomic_or.3c <beginning of page>
atomic_or, atomic_or_8, atomic_or_uchar, atomic_or_16, atomic_or_ushort, atomic_or_32, atomic_or_uint, atom<hy>
ic_or_ulong, atomic_or_64, atomic_or_8_nv, atomic_or_uchar_nv, atomic_or_16_nv, atomic_or_ushort_nv, atom<hy>
ic_or_32_nv, atomic_or_uint_nv, atomic_or_ulong_nv, atomic_or_64_nv <-> atomic OR operations
#include <atomic.h>
void atomic_or_8(volatile uint8_t *target, uint8_t bits);
void atomic_or_uchar(volatile uchar_t *target, uchar_t bits);
void atomic_or_16(volatile uint16_t *target, uint16_t bits);
void atomic_or_ushort(volatile ushort_t *target, ushort_t bits);
void atomic_or_32(volatile uint32_t *target, uint32_t bits);
void atomic_or_uint(volatile uint_t *target, uint_t bits);
void atomic_or_ulong(volatile ulong_t *target, ulong_t bits);
void atomic_or_64(volatile uint64_t *target, uint64_t bits);
uint8_t atomic_or_8_nv(volatile uint8_t *target, uint8_t bits);
uchar_t atomic_or_uchar_nv(volatile uchar_t *target, uchar_t bits);
uint16_t atomic_or_16_nv(volatile uint16_t *target, uint16_t bits);
ushort_t atomic_or_ushort_nv(volatile ushort_t *target, ushort_t bits);
uint32_t atomic_or_32_nv(volatile uint32_t *target, uint32_t bits);
uint_t atomic_or_uint_nv(volatile uint_t *target, uint_t bits);
ulong_t atomic_or_ulong_nv(volatile ulong_t *target, ulong_t bits);
uint64_t atomic_or_64_nv(volatile uint64_t *target, uint64_t bits);
These functions enable the the bitwise OR of bits to the value stored in target to occur in an atomic manner.
The *_nv() variants of these functions return the new value of target.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
atomic_add(3C), atomic_and(3C), atomic_bits(3C), atomic_cas(3C), atomic_dec(3C), atomic_inc(3C), atom<hy>
ic_swap(3C), membar_ops(3C), attributes(5), atomic_ops(9F)
The *_nv() variants are substantially more expensive on some platforms than the versions that do not return values.
Do not use them unless you need to know the new value atomically.
attributes.5 <beginning of page>
attributes, architecture, availability, CSI, stability, MT-Level, standard <-> attributes of interfaces
The ATTRIBUTES section of a manual page contains a table defining attribute types and their corresponding val<hy>
ues. The following is an example of an attributes table. Not all attribute types are appropriate for all types of inter<hy>
faces.
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC _ AvailabilitySUNWcsu _ CSIEnabled _ Interface StabilityCommitted _ MT-LevelSafe _ StandardSee stan<hy>
dards(5).
Architecture defines processor or specific hardware. See -p option of uname(1). In some cases, it may indicate re<hy>
quired adapters or peripherals.
This refers to the software package which contains the command or component being described on the man page.
To be able to use the command, the indicated package must have been installed. For information on how to add a
package see pkgadd(1M).
OS utilities and libraries free of dependencies on the properties of any code sets are said to have Code Set Indepen<hy>
dence (CSI). They have the attribute of being CSI enabled. This is in contrast to many commands and utilities, for
example, that work only with Extended Unix Codesets (EUC), an encoding method that allows concurrent support
for up to four code sets and is commonly used to represent Asian character sets.
For practical reasons, however, this independence is not absolute. Certain assumptions are still applied to the current
CSI implementation: <bu> File code is a superset of ASCII. <bu> To support multi-byte characters and null-terminated
UNIX file names, the NULL and / (slash) characters cannot be part of any multi-byte characters. <bu> Only "stateless"
file code encodings are supported. Stateless encoding avoids shift, locking shift, designation, invocation, and so
forth, although single shift is not excluded. <bu> Process code (wchar_t values) is implementation dependent and can
change over time or between implementations or between locales. <bu> Not every object can have names composed of
arbitrary characters. The names of the following objects must be composed of ASCII characters: <bu> User names,
group name, and passwords <bu> System name <bu> Names of printers and special devices <bu> Names of terminals (/dev/tty*)
<bu> Process ID numbers <bu> Message queues, semaphores, and shared memory labels. <bu> The following may be composed
of ISO Latin-1 or EUC characters: <bu> File names <bu> Directory names <bu> Command names <bu> Shell variables and environ<hy>
mental variable names <bu> Mount points for file systems <bu> NIS key names and domain names <bu> The names of NFS
shared files should be composed of ASCII characters. Although files and directories may have names and contents
composed of characters from non-ASCII code sets, using only the ASCII codeset allows NFS mounting across any
machine, regardless of localization. For the commands and utilities that are CSI enabled, all can handle single-byte
and multi-byte locales released in 2.6. For applications to get full support of internationalization services, dynamic
binding has to be applied. Statically bound programs will only get support for C and POSIX locales.
Sun often provides developers with early access to new technologies, which allows developers to evaluate with them
as soon as possible. Unfortunately, new technologies are prone to changes and standardization often results in inter<hy>
face incompatibility from previous versions.
To make reasonable risk assessments, developers need to know how likely an interface is to change in future releas<hy>
es. To aid developers in making these assessments, interface stability information is included on some manual pages
for commands, entry-points, and file formats.
The more stable interfaces can safely be used by nearly all applications, because Sun will endeavor to ensure that
these continue to work in future minor releases. Applications that depend only on Committed interfaces should reli<hy>
ably continue to function correctly on future minor releases (but not necessarily on earlier major releases).
The less stable interfaces allow experimentation and prototyping, but should be used only with the understanding
that they might change incompatibly or even be dropped or replaced with alternatives in future minor releases.
"Interfaces" that Sun does not document (for example, most kernel data structures and some symbols in system
header files) may be implementation artifacts. Such internal interfaces are not only subject to incompatible change or
removal, but we are unlikely to mention such a change in release notes.
Products are given release levels, as well as names, to aid compatibility discussions. Each release level may also in<hy>
clude changes suitable for lower levels.
<beginning of page>
tab(); cw(1.1i) cw(1.1i) cw(3.3i) lw(1.1i) lw(1.1i) lw(3.3i) ReleaseVersionSignificance _ Majorx.0T{ Likely to con<hy>
tain major feature additions; adhere to different, possibly incompatible standard revisions; and though unlikely,
could change, drop, or replace Committed interfaces. Initial product releases are usually 1.0. T} _ Minorx.yT{
Compared to an x.0 or earlier release (y!=0), it is likely to contain: feature additions, compatible changes to Com<hy>
mitted interfaces, or likely incompatible changes to Uncommitted or Volatile interfaces. T} _ Microx.y.zT{ Intend<hy>
ed to be interface compatible with the previous release (z!=0), but likely to add bug fixes, performance enhance<hy>
ments, and support for additional hardware. Incompatible changes to Volatile interfaces are possible. T}
In the context of interface stability, update releases (occasionally referred to as patch releases) should be considered
equivalent to Micro Releases.
The following table summarizes how stability level classifications relate to release level. The first column lists the
Stability Level. The second column lists the Release Level for Incompatible Changes, and the third column lists oth<hy>
er comments. For a complete discussion of individual classifications, see the appropriate subsection below.
tab(); cw(1.1i) cw(1.1i) cw(3.3i) lw(1.1i) lw(1.1i) lw(3.3i) StabilityReleaseComments _ CommittedMajor (x.0)In<hy>
compatibilities are exceptional. _ UncommittedMinor (x.y)Incompatibilities are common. _ VolatileMicro
(x.y.z)Incompatibilities are common.
The interface stability level classifications described on this manual page apply to both source and binary interfaces
unless otherwise stated. All stability level classifications are public, with the exception of the Private classification.
The precise stability level of a public interface (one that is documented in the manual pages) is unspecified unless
explicitly stated. The stability level of an undocumented interface is implicitly Private.
The existence of documentation other than the documentation that is a component of the Solaris product should not
be construed to imply any level of stability for interfaces provided by the Solaris product. The only source of stabili<hy>
ty level information is Solaris manual pages.
Committed
The intention of a Committed interface is to enable third parties to develop applications to these interfaces, release
them, and have confidence that they will run on all releases of the product after the one in which the interface was
introduced, and within the same Major release. Even at a Major release, incompatible changes are expected to be
rare, and to have strong justifications.
Interfaces defined and controlled as industry standards are most often treated as Committed interfaces. In this case,
the controlling body and/or public, versioned document is typically noted in a "Standard" entry in the Attributes ta<hy>
ble or elsewhere in the documentation.
Although a truly exceptional event, incompatible changes are possible in any release if the associated defect is seri<hy>
ous enough as outlined in the Exceptions section of this document or in a Minor release by following the End of
Feature process. If support of a Committed interface must be discontinued, Sun will attempt to provide notification
and the stability level will be marked Obsolete.
Uncommitted
No commitment is made about either source or binary compatibility of these interfaces from one Minor release to
the next. Even the drastic incompatible change of removal of the interface in a Minor release is possible. Uncom<hy>
mitted interfaces are generally not appropriate for use by release-independent products.
Incompatible changes to the interface are intended to be motivated by true improvement to the interface which may
include ease of use considerations. The general expectation should be that Uncommitted interfaces are not likely to
change incompatibly and if such changes occur they will be small in impact and may often have a mitigation plan.
Uncommitted interfaces generally fall into one of the following subcategorizes: 1. Interfaces that are experimental
or transitional. They are typically used to give outside developers early access to new or rapidly changing technolo<hy>
gy, or to provide an interim solution to a problem where a more general solution is anticipated. 2. Interfaces whose
specification is controlled by an outside body yet Sun expects to make a reasonable effort to maintain compatibility
with previous releases until the next Minor release at which time Sun expects to synchronize with the external speci<hy>
fication. 3. Interfaces whose target audience values innovation (and possibly ease of use) over stability. This at<hy>
tribute is often associated with administrative interfaces for higher tier components. For Uncommitted interfaces,
Sun makes no claims about either source or binary compatibility from one minor release to another. Applications de<hy>
<beginning of page>
veloped based on these interfaces may not work in future minor releases.
Volatile
Volatile interfaces can change at any time and for any reason.
The Volatile interface stability level allows Sun products to quickly track a fluid, rapidly evolving specification. In
many cases, this is preferred to providing additional stability to the interface, as it may better meet the expectations
of the consumer.
The most common application of this taxonomy level is to interfaces that are controlled by a body other than Sun,
but unlike specifications controlled by standards bodies or Free or Open Source Software (FOSS) communities
which value interface compatibility, it can not be asserted that an incompatible change to the interface specification
would be exceedingly rare. It may also be applied to FOSS controlled software where it is deemed more important to
track the community with minimal latency than to provide stability to our customers.
It also common to apply the Volatile classification level to interfaces in the process of being defined by trusted or
widely accepted organization. These are generically referred to as draft standards. An "IETF Internet draft" is a
well understood example of a specification under development.
Volatile can also be applied to experimental interfaces.
No assertion is made regarding either source or binary compatibility of Volatile interfaces between any two releases,
including patches. Applications containing these interfaces might fail to function properly in any future release.
Not-an-Interface
The situation occasionally occurs where there exists an entity that could be inferred to be an interface, but actually is
not. Common examples are output from CLIs intended only for human consumption and the exact layout of a GUI.
This classification is a convenience term to be used to clarify such situations where such confusion is identified as
likely. Failure to apply this term to an entity is not an indication that the entity is some form of interface. It only in<hy>
dicates that the potential for confusion was not identified.
Private
A Private interface is an interface provided by a component (or product) intended only for the use of that component.
A Private interface might still be visible to or accessible by other components. Because the use of interfaces private
to another component carries great stability risks, such use is explicitly not supported. Components not supplied by
Sun Microsystems should not use Private interfaces.
Most Private interfaces are not documented. It is an exceptional case when a Private interface is documented. Rea<hy>
sons for documenting a Private interface include, but are not limited to, the intention that the interface might be re<hy>
classified to one of the public stability level classifications in the future or the fact that the interface is inordinately
visible.
Obsolete
Obsolete is a modifier that can appear in conjunction with the above classification levels. The Obsolete modifier in<hy>
dicates an interface that is "deprecated" and/or no longer advised for general use. An existing interface may be
downgraded from some other status (such as Committed or Uncommitted) by the application of the Obsolete modifi<hy>
er to encourage customers to migrate from that interface before it may be removed (or incompatibly changed).
An Obsolete interface is supported in the current release, but is scheduled to be removed in a future (minor) release.
When support of an interface is to be discontinued, Sun will attempt to provide notification before discontinuing
support. Use of an Obsolete interface may produce warning messages.
There are rare instances when it is in the best interest of both Sun and the customer to break the interface stability
commitment. The following list contains the common, known reasons for the interface provider to violate an inter<hy>
face stability commitment, but does not preclude others. 1. Security holes where the vulnerability is inherent in the
interface. 2. Data corruption where the vulnerability is inherent in the interface. 3. Standards violations uncovered
by a change in interpretation or enhancement of conformance tests. 4. An interface specification which isn't con<hy>
trolled by Sun has been changed incompatibly and the vast majority of interface consumers expect the newer inter<hy>
<beginning of page>
face. 5. Not making the incompatible change would be incomprehensible to our customers. One example of this
would to have not incompatibly changed pcfs when the DOS 8.3 naming restrictions were abandoned.
Incompatible changes allowed by exception will always be delivered in the "most major" release vehicle possible.
However, often the consequences of the vulnerabilities or contractual branding requirements will force delivery in a
patch.
In releases up to and including Solaris 10, a different interface classification scheme was used. The following table
summarizes the mapping between the old and new classification schemes.
tab(); cw(1.1i) cw(1.1i) cw(3.3i) lw(1.1i) lw(1.1i) lw(3.3i) OldNewComments _ StandardCommittedT{ An entry in
the attributes table for the Standard attribute type should appear. T} StableCommittedName change. EvolvingUn<hy>
committedActual commitments match. UnstableUncommittedName change. ExternalVolatileT{ Name change with
expansion of allowed usage. T} Obsolete(Obsolete)Was a classification, now a modifier.
The increased importance of Free or Open Source Software motivated the name change from Stable/Unstable to
Committed/Uncommitted. Stable conflicted with the common use of the term in FOSS communities.
Ambiguity in the definition of Evolving was causing difficulty in interpretation. As part of the migration to the new
classification scheme, many formerly Evolving interfaces were upgraded to Committed. However, upon encounter<hy>
ing the term Evolving, Uncommitted should be inferred.
Libraries are classified into categories that define their ability to support multiple threads. Manual pages containing
functions that are of multiple or differing levels describe this in their NOTES or USAGE section.
Safe
Safe is an attribute of code that can be called from a multithreaded application. The effect of calling into a Safe in<hy>
terface or a safe code segment is that the results are valid even when called by multiple threads. Often overlooked is
the fact that the result of this Safe interface or safe code segment can have global consequences that affect all
threads. For example, the action of opening or closing a file from one thread is visible by all the threads within a
process. A multithreaded application has the responsibility for using these interfaces in a safe manner, which is dif<hy>
ferent from whether or not the interface is Safe. For example, a multithreaded application that closes a file that is still
in use by other threads within the application is not using the close(2) interface safely.
Unsafe
An Unsafe library contains global and static data that is not protected. It is not safe to use unless the application ar<hy>
ranges for only one thread at time to execute within the library. Unsafe libraries might contain functions that are
Safe; however, most of the library's functions are unsafe to call. Some functions that are Unsafe have reentrant coun<hy>
terparts that are MT-Safe. Reentrant functions are designated by the _r suffix appended to the function name.
MT-Safe
An MT-Safe library is fully prepared for multithreaded access. It protects its global and static data with locks, and
can provide a reasonable amount of concurrency. A library can be safe to use, but not MT-Safe. For example, sur<hy>
rounding an entire library with a monitor makes the library Safe, but it supports no concurrency so it is not consid<hy>
ered MT-Safe. An MT-Safe library must permit a reasonable amount of concurrency. (This definition's purpose is to
give precision to what is meant when a library is described as Safe. The definition of a Safe library does not specify
if the library supports concurrency. The MT-Safe definition makes it clear that the library is Safe, and supports some
concurrency. This clarifies the Safe definition, which can mean anything from being single threaded to being any de<hy>
gree of multithreaded.)
Async-Signal-Safe
Async-Signal-Safe refers to particular library functions that can be safely called from a signal handler. A thread that
is executing an Async-Signal-Safe function will not deadlock with itself if interrupted by a signal. Signals are only a
problem for MT-Safe functions that acquire locks.
Async-Signal-Safe functions are also MT-Safe. Signals are disabled when locks are acquired in Async-Signal-Safe
functions. These signals prevent a signal handler that might acquire the same lock from being called.
<beginning of page>
MT-Safe with Exceptions
See the NOTES or USAGE sections of these pages for a description of the exceptions.
Safe with Exceptions
See the NOTES or USAGE sections of these pages for a description of the exceptions.
Fork-Safe
The fork(2) function replicates only the calling thread in the child process. The fork1(2) function exists for compati<hy>
bility with the past and is synonymous with fork(). If a thread other than the one performing the fork holds a lock
when fork() is called, the lock will still be held in the child process but there will be no lock owner since the owning
thread was not replicated. A child calling a function that attempts to acquire the lock will deadlock itself.
When fork() is called, a Fork-Safe library arranges to have all of its internal locks held only by the thread perform<hy>
ing the fork. This is usually accomplished with pthread_atfork(3C), which is called when the library is initialized.
The forkall(2) function provides the capability for the rare case when a process needs to replicate all of its threads
when performing a fork. No pthread_atfork() actions are performed when forkall() is called. There are dangers as<hy>
sociated with calling forkall(). If some threads in a process are performing I/O operations when another thread calls
forkall(), they will continue performing the same I/O operations in both the parent and child processes, possibly
causing data corruption. For this and other race-condition reasons, the use of forkall() is discouraged.
In all Solaris releases prior to Solaris 10, the behavior of fork() depended on whether or not the application was
linked with -lpthread (POSIX threads, see standards(5)). If linked with -lpthread, fork() behaved like fork1();
otherwise it behaved like forkall(). To avoid any confusion concerning the behavior of fork(), applications can
specifically call fork1() or forkall() as appropriate.
Cancel-Safety
If a multithreaded application uses pthread_cancel(3C) to cancel (that is, kill) a thread, it is possible that the target
thread is killed while holding a resource, such as a lock or allocated memory. If the thread has not installed the ap<hy>
propriate cancellation cleanup handlers to release the resources appropriately (see pthread_cancel(3C)), the appli<hy>
cation is "cancel-unsafe", that is, it is not safe with respect to cancellation. This unsafety could result in deadlocks
due to locks not released by a thread that gets cancelled, or resource leaks; for example, memory not being freed on
thread cancellation. All applications that use pthread_cancel(3C) should ensure that they operate in a Cancel-Safe
environment. Libraries that have cancellation points and which acquire resources such as locks or allocate memory
dynamically, also contribute to the cancel-unsafety of applications that are linked with these libraries. This intro<hy>
duces another level of safety for libraries in a multithreaded program: Cancel-Safety. There are two sub-categories of
Cancel-Safety: Deferred-Cancel-Safety, and Asynchronous-Cancel-Safety. An application is considered to be De<hy>
ferred-Cancel-Safe when it is Cancel-Safe for threads whose cancellation type is PTHREAD_CANCEL_DE<hy>
FERRED. An application is considered to be Asynchronous-Cancel-Safe when it is Cancel-Safe for threads whose
cancellation type is PTHREAD_CANCEL_ASYNCHRONOUS. Deferred-Cancel-Safety is easier to achieve than
Asynchronous-Cancel-Safety, since a thread with the deferred cancellation type can be cancelled only at well-de<hy>
fined cancellation points, whereas a thread with the asynchronous cancellation type can be cancelled anywhere.
Since all threads are created by default to have the deferred cancellation type, it might never be necessary to worry
about asynchronous cancel safety. Most applications and libraries are expected to always be Asynchronous-Cancel-
Unsafe. An application which is Asynchronous-Cancel-Safe is also, by definition, Deferred-Cancel-Safe.
Many interfaces are defined and controlled as industry standards. When this is the case, the controlling body and/or
public, versioned document is noted in this section.
Programmers producing portable applications should rely on the interface descriptions present in the standard or
specification to which the application is intended to conform, rather than the manual page descriptions of interfaces
based upon a public standard. When the standard or specification allows alternative implementation choices, the
manual page usually only describes the alternative implemented by Sun. The manual page also describes any com<hy>
patible extensions to the base definition of Standard interfaces provided by Sun.
No endorsement of the referenced controlling body or document should be inferred by its presence as a "Standard"
entry. The controlling body may be a very formal organization, as in ISO or ANSII, a less formal, but generally ac<hy>
cepted organization such as IETF, or as informal as the sole contributor in the case of FOSS (Free or Open Source
Software).
<beginning of page>
uname(1), pkgadd(1M), Intro(3), standards(5)
audio810.7d <beginning of page>
audio810 <-> Intel ICH series, nVidia nForce series and AMD 8111 audio core support
The audio810 driver provides support for AC 97 audio controllers embedded in Intel ICH, nVidia nForce, and AMD
8111 chips.
/kernel/drv/audio810 32-bit kernel driver module
/kernel/drv/amd64/audio810 64-bit x86 kernel driver module
/kernel/drv/audio810.conf audio810 driver configuration file
See attributes(5) for a descriptions of the following attributes:
tab() box; cw(1.83i) |cw(3.67i) lw(1.83i) |lw(3.67i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitecturePC-
based systems _ AvailabilitySUNWad810 _ Interface StabilityUncommitted
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
AMD-8111 HyperTransport I/O Hub Data Sheet <em> Advanced Micro Devices Inc.
ALC655 Specification <em> Realtek Inc.
Some laptops (including Sony VAIO, among others), have their on-board amplifier powered down by default, mean<hy>
ing that audio is suppressed even if hardware and the audio810 driver are working normally. To correct this, set the
ac97-invert-amp=1 property in the /kernel/drv/audio810.conf to power-up the amplifier.
In addition to being logged, the following messages may appear on the system console:
play-interrupts too low
record-interrupts too low The interrupt rate in audio810.conf is set too low. It has been reset to the rate specified
in the message. Update audio810.conf to a higher interrupt rate.
play-interrupts too high
record-interrupts too high The interrupt rate set inaudio810.conf is set too   high.It has been reset to the rate
specified in the message. Update audio810.confto a lower interrupt rate.
audiop16x.7d <beginning of page>
audiop16x <-> Creative Sound Blaster Live! OEM support
The audiop16x driver provides support for the Creative Sound Blaster Live! products based on the P16X device.
These chips are also known as the EMU10K1X device, not to be confused with the EMU10K1.
Add-in boards known to work with this driver are Sound Blaster Live! cards with model numbers SB0200 or
SB0213.
This device is capable of 5.1 surround sound.
/kernel/drv/audiop16x
32-bit kernel driver module
/kernel/drv/amd64/audiop16x
64-bit x86 kernel driver module
/kernel/drv/sparcv9/audiop16x
64-bit SPARC kernel driver module
See attributes(5) for a descriptions of the following attributes:
tab() box; cw(1.83i) |cw(3.67i) lw(1.83i) |lw(3.67i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86,
SPARC _ AvailabilitySUNWaudiop16x
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
audiovia97.7d <beginning of page>
audiovia97 <-> Via 82C686 audio device support
The audiovia97 driver provides support for the integrated audio device found in the Via 82C686 southbridge
chipset, found on certain motherboards.
/kernel/drv/audiovia97 32-bit kernel driver module
See attributes(5) for a descriptions of the following attributes:
tab() box; cw(2.52i) |cw(2.98i) lw(2.52i) |lw(2.98i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureVia
82C686-based systems _ AvailabilitySUNWaudiovia97
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
audit_event.4 <beginning of page>
audit_event <-> audit event definition and class mapping
/etc/security/audit_event
/etc/security/audit_event is a user-configurable ASCII system file that stores event definitions used in the audit sys<hy>
tem. As part of this definition, each event is mapped to one or more of the audit classes defined in audit_class(4).
See audit_control(4) and audit_user(4) for information about changing the preselection of audit classes in the audit
system. Programs can use the getauevent(3BSM) routines to access audit event information.
The fields for each event entry are separated by colons. Each event is separated from the next by a NEWLINE.Each
entry in the audit_event file has the form:
 number:name:description:flags
The fields are defined as follows:
number Event number.
Event number ranges are assigned as follows:
0 Reserved as an invalid event number.
1-2047 Reserved for the Solaris Kernel events.
2048-32767 Reserved for the Solaris TCB programs.
32768-65535 Available for third party TCB applications.
System administrators must not add, delete, or modify (except to change the class mapping), events with an event
number less than 32768. These events are reserved by the system.
name Event name.
description Event description.
flags Flags specifying classes to which the event is mapped. Classes are comma separated, without spaces.
Obsolete events are commonly assigned to the special class no (invalid) to indicate they are no longer generated. Ob<hy>
solete events are retained to process old audit trail files. Other events which are not obsolete may also be assigned to
the no class.
Example 1 Using the audit_event File
The following is an example of some audit_event file entries:
 7:AUE_EXEC:exec(2):ps,ex
 79:AUE_OPEN_WTC:open(2) - write,creat,trunc:fc,fd,fw
 6152:AUE_login:login - local:lo
 6153:AUE_logout:logout:lo
 6154:AUE_telnet:login - telnet:lo
 6155:AUE_rlogin:login - rlogin:lo
See attributes(5) for descriptions of the following attributes:
<beginning of page>
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability
See below.
The file format stability is Committed. The file content is Uncommitted.
/etc/security/audit_event
bsmconv(1M), getauevent(3BSM), audit_class(4), audit_control(4), audit_user(4)
Part VII, Solaris Auditing, in System Administration Guide: Security Services
This functionality is available only if Solaris Auditing has been enabled. See bsmconv(1M) for more information.
audit_syslog.5 <beginning of page>
audit_syslog <-> realtime conversion of Solaris audit data to syslog messages
/usr/lib/security/audit_syslog.so
The audit_syslog plugin module for Solaris audit, /usr/lib/security/audit_syslog.so, provides realtime conversion
of Solaris audit data to syslog-formatted (text) data and sends it to a syslog daemon as configured in syslog.conf(4).
The plugin's path is specified in the audit configuration file, audit_control(4).
Messages to syslog are written if selected via the plugin option in audit_control. Syslog messages are generated
with the facility code of LOG_AUDIT (audit in syslog.conf(4)) and severity of LOG_NOTICE. Audit syslog mes<hy>
sages contain data selected from the tokens described for the binary audit log. (See audit.log(4)). As with all syslog
messages, each line in a syslog file consists of two parts, a syslog header and a message.
The syslog header contains the date and time the message was generated, the host name from which it was sent, au<hy>
ditd to indicate that it was generated by the audit daemon, an ID field used internally by syslogd, and audit.notice
indicating the syslog facility and severity values. The syslog header ends with the characters ], that is, a closing
square bracket and a space.
The message part starts with the event type from the header token. All subsequent data appears only if contained in
the original audit record and there is room in the 1024-byte maximum length syslog line. In the following example,
the backslash (\) indicates a continuation; actual syslog messages are contained on one line:
 Oct 31 11:38:08 smothers auditd: [ID 917521 audit.notice] chdir(2) ok\
 session 401 by joeuser as root:other from myultra obj /export/home
In the preceding example, chdir(2) is the event type. Following this field is additional data, described below. This
data is omitted if it is not contained in the source audit record.
ok or failed Comes from the return or exit token.
session <#> <#> is the session ID from the subject token.
by <name> <name> is the audit ID from the subject token.
as <name>:<group> <name> is the effective user ID and <group> is the effective group ID from the subject token.
in <zone name> The zone name. This field is generated only if the zonename audit policy is set.
from <terminal> <terminal> is the text machine address from the subject token.
obj <path> <path> is the path from the path token The path can be truncated from the left if necessary to fit it on
the line. Truncation is indicated by leading ellipsis (...).
proc_uid <owner> <owner> is the effective user ID of the process owner.
proc_auid <owner> <owner> is the audit ID of the process owner.
The following are example syslog messages:
 Nov 4 8:27:07 smothers auditd: [ID 175219 audit.notice] \
 system booted
 Nov 4 9:28:17 smothers auditd: [ID 752191 audit.notice] \
 login - rlogin ok session 401 by joeuser as joeuser:staff from myultra
<beginning of page>
 Nov 4 10:29:27 smothers auditd: [ID 521917 audit.notice] \
 access(2) ok session 255 by janeuser as janeuser:staff from \
 129.146.89.30 obj /etc/passwd
The p_flag attribute, specified by means of the plugin directive (see audit_control(4)), is used to further filter audit
data being sent to the syslog daemon beyond the classes specified through the flags and naflags lines of audit_con<hy>
trol and through the user-specific lines of audit_user(4). The parameter is a comma-separated list; each item repre<hy>
sents an audit class (see audit_class(4)) and is specified using the same syntax used in audit_control for the flags
and naflags lines. The default (no p_flags listed) is that no audit records are generated. Example 1 One Use of the
plugin Line
In the specification shown below, the plugin line (in conjunction with flags and naflags) is used to allow class
records for lo but allows class records for am for failures only. Omission of the fm class records results in no fm
class records being output. The pc parameter has no effect because you cannot add classes to those defined by means
of flags and naflags and by audit_user(4). You can only remove them.
 flags: lo,am,fm
 naflags: lo
 plugin: name=audit_syslog.so; p_flags=lo,-am
Example 2 Use of all
In the specification shown below, with one exception, all allows all flags defined by means of flags and naflags (and
audit_user(4)). The exception the am metaclass, which is equivalent to ss,as,ua, which is modified to output all ua
events but only failure events for ss and as.
 flags: lo,am
 naflags: lo
 plugin: name=audit_syslog.so; p_flags=all,^+ss,^+as
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT LevelMT-
Safe _ Interface StabilitySee below.
The message format and message content are Uncommitted. The configuration parameters are Committed.
auditd(1M), audit_class(4), audit_control(4), syslog.conf(4), attributes(5)
System Administration Guide: Security Services
Use of the plugin configuration line to include audit_syslog.so requires that /etc/syslog.conf is configured to store
syslog messages of facility audit and severity notice or above in a file intended for Solaris audit records. An exam<hy>
ple of such a line in syslog.conf is:
 audit.notice /var/audit/audit.log
Messages from syslog are sent to remote syslog servers by means of UDP, which does not guarantee delivery or en<hy>
sure the correct order of arrival of messages.
If the parameters specified for the plugin line result in no classes being preselected, an error is reported by means of
a syslog alert with the LOG_DAEMON facility code.
The time field in the syslog header is generated by syslog(3C) and only approximates the time given in the binary
<beginning of page>
audit log. Normally the time field shows the same whole second or at most a few seconds difference.
auto_ef.1 <beginning of page>
auto_ef <-> auto encoding finder
/usr/bin/auto_ef [-e encoding_list] [-a] [-l level]
 [file ...]
/usr/bin/auto_ef -h
The auto_ef utility identifies the encoding of a given file. The utility judges the encoding by using the iconv code
conversion, determining whether a certain code conversion was successful with the file, and also by performing fre<hy>
quency analyses on the character sequences that appear in the file.
The auto_ef utility might produce unexpected output if the string is binary, a character table, a localized digit list, or
a chronogram, or if the string or file is very small in size (for example, less than one 100 bytes).
ASCII
ISO-2022-JP JIS
eucJP Japanese EUC
PCK Japanese PC Kanji, CP932, Shift JIS
UTF-8
ko_KR.euc Korean EUC
ko_KR.cp949 Unified Hangul
ISO-2022-KR ISO-2022 Korean
zh_CN.iso2022-CN ISO-2022 CN/CN-EXT
zh_CN.euc Simplified Chinese EUC, GB2312
GB18030 Simplified Chinese GB18030/GBK
zh_TW-big5 BIG5
zh_TW-euc Traditional Chinese EUC
zh_TW.hkscs Hong Kong BIG5
iso-8859-1 West European, and similar
iso-8859-2 East European, and similar
iso-8859-5 Cyrillic, and similar
iso-8859-6 Arabic
iso-8859-7 Greek
<beginning of page>
iso-8859-8 Hebrew
CP1250 windows-1250, corresponding to ISO-8859-2
CP1251 windows-1251, corresponding to ISO-8859-5
CP1252 windows-1252, corresponding to ISO-8859-1
CP1253 windows-1253, corresponding to ISO-8859-7
CP1255 windows-1255, corresponding to ISO-8859-8
koi8-r corresponding to iso-8859-5
By default, auto_ef returns a single, most likely encoding for text in a specified file. To get all possible encodings for
the file, use the -a option.
Also by default, auto_ef uses the fastest process to examine the file. For more accurate results, use the -l option.
To examine data with a limited set of encodings, use the -e option.
The following options are supported:
-a Shows all possible encodings in order of possibility, with scores in the range between 0.0 and 1.0. A higher score
means a higher possibility. For example,
 example% auto_ef -a test_file
 eucJP 0.89
 zh_CN.euc 0.04
 ko_KR.euc 0.01
Without this option, only one encoding with the highest score is shown.
-e encoding_list Examines data only with specified encodings. For example, when encoding_list is specified as
"ko_KR.euc:ko_KR.cp949", auto_ef examines text only with CP949 and ko_KR.euc. Without this option, au<hy>
to_ef examines text with all encodings. Multiple encodings can be specified by separating the encodings using a
colon (:).
-h Shows the usage message.
-l level Specifies the level of judgment. The value of level can be 0, 1, 2, or 3. Level 3 produces the best result but
can be slow. Level 0 is fastest but results can be less accurate than in higher levels. The default is level 0.
The following operands are supported:
file File name to examine.
Example 1 Examining encoding of a file
 example% auto_ef file_name
Example 2 Examining encoding of a file at level 2.
<beginning of page>
 example% auto_ef -l 2 file_name
Example 3 Examining encoding of a file with only eucJP or ko_KR.euc
 example% auto_ef -e "eucJP:ko_KR.euc" file_name
The following exit values are returned:
0 Successful completion
1 An error occurred.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wautoef _ Interface StabilitySee below.
Interface Stability of output format, when option -a is specified, is Evolving. Other interfaces are Stable.
auto_ef(3EXT), libauto_ef(3LIB), attributes(5)
International Language Environments Guide
awk.1 <beginning of page>
awk <-> pattern scanning and processing language
/usr/bin/awk [-f progfile] [-Fc] [' prog '] [parameters]
 [filename]...
/usr/xpg4/bin/awk [-FcERE] [-v assignment]... 'program' -f progfile...
 [argument]...
The /usr/xpg4/bin/awk utility is described on the nawk(1) manual page.
The /usr/bin/awk utility scans each input filename for lines that match any of a set of patterns specified in prog. The
prog string must be enclosed in single quotes ( a<aa>) to protect it from the shell. For each pattern in prog there can be
an associated action performed when a line of a filename matches the pattern. The set of pattern-action statements
can appear literally as prog or in a file specified with the -f progfile option. Input files are read in order; if there are
no files, the standard input is read. The file name '<mi>' means the standard input.
The following options are supported:
-f progfile awk uses the set of patterns it reads from progfile.
-Fc Uses the character c as the field separator (FS) character. See the discussion of FS below.
Each input line is matched against the pattern portion of every pattern-action statement; the associated action is per<hy>
formed for each matched pattern. Any filename of the form var=value is treated as an assignment, not a filename,
and is executed at the time it would have been opened if it were a filename. Variables assigned in this manner are not
available inside a BEGIN rule, and are assigned after previously specified files have been read.
An input line is normally made up of fields separated by white spaces. (This default can be changed by using the FS
built-in variable or the -Fc option.) The default is to ignore leading blanks and to separate fields by blanks and/or tab
characters. However, if FS is assigned a value that does not include any of the white spaces, then leading blanks are
not ignored. The fields are denoted $1, $2, ...; $0 refers to the entire line.
A pattern-action statement has the form:
 pattern { action }
Either pattern or action can be omitted. If there is no action, the matching line is printed. If there is no pattern, the
action is performed on every input line. Pattern-action statements are separated by newlines or semicolons.
Patterns are arbitrary Boolean combinations ( !, ||, &&, and parentheses) of relational expressions and regular ex<hy>
pressions. A relational expression is one of the following:
 expression relop expression
 expression matchop regular_expression
where a relop is any of the six relational operators in C, and a matchop is either ~ (contains) or !~ (does not contain).
An expression is an arithmetic expression, a relational expression, the special expression
 var in array
or a Boolean combination of these.
Regular expressions are as in egrep(1). In patterns they must be surrounded by slashes. Isolated regular expressions
in a pattern apply to the entire line. Regular expressions can also occur in relational expressions. A pattern can con<hy>
sist of two patterns separated by a comma; in this case, the action is performed for all lines between the occurrence
of the first pattern to the occurrence of the second pattern.
The special patterns BEGIN and END can be used to capture control before the first input line has been read and af<hy>
ter the last input line has been read respectively. These keywords do not combine with any other patterns.
<beginning of page>
Built-in variables include:
FILENAME name of the current input file
FS input field separator regular expression (default blank and tab)
NF number of fields in the current record
NR ordinal number of the current record
OFMT output format for numbers (default %.6g)
OFS output field separator (default blank)
ORS output record separator (default new-line)
RS input record separator (default new-line)
An action is a sequence of statements. A statement can be one of the following:
 if ( expression ) statement [ else statement ]
 while ( expression ) statement
 do statement while ( expression )
 for ( expression ; expression ; expression ) statement
 for ( var in array ) statement
 break
 continue
 { [ statement ] ... }
 expression # commonly variable = expression
 print [ expression-list ] [ >expression ]
 printf format [ ,expression-list ] [ >expression ]
 next # skip remaining patterns on this input line
 exit [expr] # skip the rest of the input; exit status is expr
Statements are terminated by semicolons, newlines, or right braces. An empty expression-list stands for the whole
input line. Expressions take on string or numeric values as appropriate, and are built using the operators +, <mi>, *, /,
%, ^ and concatenation (indicated by a blank). The operators ++, <mi><mi>, +=, <mi>=, *=, /=, %=, ^=, >, >=, <, <=, ==, !=,
and ?: are also available in expressions. Variables can be scalars, array elements (denoted x[i]), or fields. Variables
are initialized to the null string or zero. Array subscripts can be any string, not necessarily numeric; this allows for a
form of associative memory. String constants are quoted (""), with the usual C escapes recognized within.
The print statement prints its arguments on the standard output, or on a file if >expression is present, or on a pipe if
'|cmd' is present. The output resulted from the print statement is terminated by the output record separator with each
argument separated by the current output field separator. The printf statement formats its expression list according
to the format (see printf(3C)).
The arithmetic functions are as follows:
cos(x) Return cosine of x, where x is in radians. (In /usr/xpg4/bin/awk only. See nawk(1).)
sin(x) Return sine of x, where x is in radians. (In /usr/xpg4/bin/awk only. See nawk(1).)
exp(x) Return the exponential function of x.
<beginning of page>
log(x) Return the natural logarithm of x.
sqrt(x) Return the square root of x.
int(x) Truncate its argument to an integer. It is truncated toward 0 when x > 0.
The string functions are as follows:
index(s, t)
Return the position in string s where string t first occurs, or 0 if it does not occur at all.
int(s)
truncates s to an integer value. If s is not specified, $0 is used.
length(s)
Return the length of its argument taken as a string, or of the whole line if there is no argument.
split(s, a, fs)
Split the string s into array elements a[1], a[2], ... a[n], and returns n. The separation is done with the regular ex<hy>
pression fs or with the field separator FS if fs is not given.
sprintf(fmt, expr, expr,...)
Format the expressions according to the printf(3C) format given by fmt and returns the resulting string.
substr(s, m, n)
returns the n-character substring of s that begins at position m.
The input/output function is as follows:
getline Set $0 to the next input record from the current input file. getline returns 1 for successful input, 0 for end of
file, and <mi>1 for an error.
See largefile(5) for the description of the behavior of awk when encountering files greater than or equal to 2 Gbyte (
2^31 bytes). Example 1 Printing Lines Longer Than 72 Characters
The following example is an awk script that can be executed by an awk -f examplescript style command. It prints
lines longer than seventy two characters:
 length > 72
Example 2 Printing Fields in Opposite Order
The following example is an awk script that can be executed by an awk -f examplescript style command. It prints
the first two fields in opposite order:
 { print $2, $1 }
Example 3 Printing Fields in Opposite Order with the Input Fields Separated
<beginning of page>
The following example is an awk script that can be executed by an awk -f examplescript style command. It prints
the first two input fields in opposite order, separated by a comma, blanks or tabs:
 BEGIN { FS = ",[ \t]*|[ \t]+" }
  { print $2, $1 }
Example 4 Adding Up the First Column, Printing the Sum and Average
The following example is an awk script that can be executed by an awk -f examplescript style command. It adds
up the first column, and prints the sum and average:
 { s += $1 }
 END { print "sum is", s, " average is", s/NR }
Example 5 Printing Fields in Reverse Order
The following example is an awk script that can be executed by an awk -f examplescript style command. It prints
fields in reverse order:
 { for (i = NF; i > 0; <mi><mi>i) print $i }
Example 6 Printing All lines Between start/stop Pairs
The following example is an awk script that can be executed by an awk -f examplescript style command. It prints
all lines between start/stop pairs.
 /start/, /stop/
Example 7 Printing All Lines Whose First Field is Different from the Previous One
The following example is an awk script that can be executed by an awk -f examplescript style command. It prints
all lines whose first field is different from the previous one.
 $1 != prev { print; prev = $1 }
Example 8 Printing a File and Filling in Page numbers
The following example is an awk script that can be executed by an awk -f examplescript style command. It prints a
file and fills in page numbers starting at 5:
 /Page/ { $2 = n++; }
    { print }
Example 9 Printing a File and Numbering Its Pages
Assuming this program is in a file named prog, the following example prints the file input numbering its pages
starting at 5:
 example% awk -f prog n=5 input
See environ(5) for descriptions of the following environment variables that affect the execution of awk: LANG,
<beginning of page>
LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, NLSPATH, and PATH.
LC_NUMERIC Determine the radix character used when interpreting numeric input, performing conversions be<hy>
tween numeric and string values and formatting numeric output. Regardless of locale, the period character (the deci<hy>
mal-point character of the POSIX locale) is the decimal-point character recognized in processing awk programs (in<hy>
cluding assignments in command-line arguments).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wesu _ CSINot Enabled
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wxcu4 _ CSIEnabled _ Interface StabilityStandard
egrep(1), grep(1), nawk(1), sed(1), printf(3C), attributes(5), environ(5), largefile(5), standards(5)
Input white space is not preserved on output if fields are involved.
There are no explicit conversions between numbers and strings. To force an expression to be treated as a number,
add 0 to it. To force an expression to be treated as a string, concatenate the null string ("") to it.
basename.1 <beginning of page>
basename, dirname <-> deliver portions of path names
/usr/bin/basename string [suffix]
/usr/xpg4/bin/basename string [suffix]
dirname string
The basename utility deletes any prefix ending in / and the suffix (if present in string) from string, and prints the re<hy>
sult on the standard output. It is normally used inside substitution marks (``) within shell procedures.
The suffix is a pattern defined on the expr(1) manual page.
The suffix is a string with no special significance attached to any of the characters it contains.
The dirname utility delivers all but the last level of the path name in string. Example 1 Setting environment vari<hy>
ables
The following example, invoked with the argument /home/sms/personal/mail sets the environment variable NAME
to the file named mail and the environment variable MYMAILPATH to the string /home/sms/personal:
 example% NAME=`basename $HOME/personal/mail`
 example% MYMAILPATH=`dirname $HOME/personal/mail`
Example 2 Compiling a file and moving the output
This shell procedure, invoked with the argument /usr/src/bin/cat.c, compiles the named file and moves the output to
cat in the current directory:
 example% cc $1
 example% mv a.out `basename $1 .c`
See environ(5) for descriptions of the following environment variables that affect the execution of basename and
dirname: LANG, LC_ALL, LC_CTYPE, LC_MESSAGES, and NLSPATH.
The following exit values are returned:
0 Successful completion.
>0 An error occurred.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wxcu4 _ Interface StabilityStandard
expr(1), basename(3C), attributes(5), environ(5), standards(5)
bcopy.9f <beginning of page>
bcopy <-> copy data between address locations in the kernel
#include <sys/types.h>
#include <sys/sunddi.h>
void bcopy(const void *from, void *to, size_t bcount);
Architecture independent level 1 (DDI/DKI).
from Source address from which the copy is made.
to Destination address to which copy is made.
bcount The number of bytes moved.
The bcopy() function copies bcount bytes from one kernel address to another. If the input and output addresses over<hy>
lap, the command executes, but the results may not be as expected.
Note that bcopy() should never be used to move data in or out of a user buffer, because it has no provision for han<hy>
dling page faults. The user address space can be swapped out at any time, and bcopy() always assumes that there
will be no paging faults. If bcopy() attempts to access the user buffer when it is swapped out, the system will panic.
It is safe to use bcopy() to move data within kernel space, since kernel space is never swapped out.
The bcopy() function can be called from user, interrupt, or kernel context. Example 1 Copying data between ad<hy>
dress locations in the kernel:
An I/O request is made for data stored in a RAM disk. If the I/O operation is a read request, the data is copied from
the RAM disk to a buffer (line 8). If it is a write request, the data is copied from a buffer to the RAM disk (line 15).
bcopy() is used since both the RAM disk and the buffer are part of the kernel address space.
  1 #define RAMDNBLK 1000 /* blocks in the RAM disk */
  2 #define RAMDBSIZ 512 /* bytes per block */
  3 char ramdblks[RAMDNBLK][RAMDBSIZ]; /* blocks forming RAM
  /* disk
  ...
  4
  5 if (bp->b_flags & B_READ) /* if read request, copy data */
  6 /* from RAM disk data block */
  7 /* to system buffer */
  8 bcopy(&ramdblks[bp->b_blkno][0], bp->b_un.b_addr,
  9 bp->b_bcount);
 10
 11 else /* else write request, */
 12 /* copy data from a */
 13 /* system buffer to RAM disk */
 14 /* data block */
 15 bcopy(bp->b_un.b_addr, &ramdblks[bp->b_blkno][0],
 16 bp->b_bcount);
copyin(9F), copyout(9F)
Writing Device Drivers
The from and to addresses must be within the kernel space. No range checking is done. If an address outside of the
kernel space is selected, the driver may corrupt the system in an unpredictable way.
bgets.3gen <beginning of page>
bgets <-> read stream up to next delimiter
cc [ flag ... ] file ... -lgen [ library ... ]
#include <libgen.h>
char *bgets(char *buffer, size_t count, FILE *stream,
 const char *breakstring);
The bgets() function reads characters from stream into buffer until either count is exhausted or one of the characters
in breakstring is encountered in the stream. The read data is terminated with a null byte ('\0') and a pointer to the
trailing null is returned. If a breakstring character is encountered, the last non-null is the delimiter character that ter<hy>
minated the scan.
Note that, except for the fact that the returned value points to the end of the read string rather than to the beginning,
the call
 bgets(buffer, sizeof buffer, stream, "\n");
is identical to
 fgets (buffer, sizeof buffer, stream);
There is always enough room reserved in the buffer for the trailing null character.
If breakstring is a null pointer, the value of breakstring from the previous call is used. If breakstring is null at the
first call, no characters will be used to delimit the string.
NULL is returned on error or end-of-file. Reporting the condition is delayed to the next call if any characters were
read but not yet returned. Example 1 Example of the bgets() function.
The following example prints the name of the first user encountered in /etc/passswd, including a trailing ":"
 #include <stdio.h>
 #include<libgen.h>
 int main()
 {
  char buffer[8];
  FILE *fp;
  if ((fp = fopen("/etc/passwd","r")) == NULL) {
  perror("/etc/passwd");
  return 1;
  }
  if (bgets(buffer, 8, fp, ":") == NULL) {
  perror("bgets");
  return 1;
  }
  (void) puts(buffer);
  return 0;
 }
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT-LevelMT-Safe
gets(3C), attributes(5)
When compiling multithread applications, the _REENTRANT flag must be defined on the compile line. This flag
<beginning of page>
should only be used in multithreaded applications.
bioinit.9f <beginning of page>
bioinit <-> initialize a buffer structure
#include <sys/ddi.h>
#include <sys/sunddi.h>
void bioinit(struct buf *bp);
Solaris DDI specific (Solaris DDI).
bp Pointer to the buffer header structure.
The bioinit() function initializes a buf(9S) structure. A buffer structure contains state information which has to be
initialized if the memory for the buffer was allocated using kmem_alloc(9F). This is not necessary for a buffer allo<hy>
cated using getrbuf(9F) because getrbuf() will call bioinit() directly.
The bioinit() function can be called from any context. Example 1 Using bioinit()
   
 struct buf *bp = kmem_alloc(biosize(), KM_SLEEP);
 bioinit(bp);
 /* use buffer */
biofini(9F), bioreset(9F), biosize(9F), getrbuf(9F), kmem_alloc(9F), buf(9S)
Writing Device Drivers
blk2scsa.7d <beginning of page>
blk2scsa <-> SCSA block device emulation
The blk2scsa module provides support services for generic block devices so that they appear to the system as de<hy>
vices on a virtual SCSI bus, thus allowing them to be serviced by the sd(7D) SCSI disk driver. The blk2scsa device
supports the SCSI-2 command set for Direct Access Devices. The blk2scsa device supports multiple LUNs per
physical device and creates a separate child device for each LUN. All child nodes attach to sd(7D).
Disk block special file names are located in /dev/dsk. Raw file names are located in /dev/rdsk. See sd(7D).
See dkio(7I)
See sd(7D).
Device special files for the storage device are created in the same way as those for a SCSI disk. See sd(7D) for more
information.
/dev/dsk/cntndnsn
Block files for disks.
/dev/rdsk/ctndnsn
Raw files for disks.
/kernel/misc/blk2scsa
32-bit ELF kernel module (x86).
/kernel/misc/amd64/blk2scsa
64-bit ELF kernel module (x86).
/kernel/misc/sparcv9/blk2scsa
64-bit ELF kernel module (SPARC).
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC, x86 _ AvailabilitySUNWckr
eject(1), rmformat(1), rmmount(1), cfgadm_scsi(1M), fdisk(1M), mount(1M), umount(1M), scsi(4), vfstab(4),
attributes(5), sd(7D), dkio(7I), pcfs(7FS)
802.11b Standard for Wireless Local Area Networks (WLANs) - IEEE
border.3xcurses <beginning of page>
border, box, wborder <-> add a single-byte border to a window
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library... ]
#include <curses.h>
int border(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl,
 chtype tr, chtype bl, chtype br);
int wborder(WINDOW *win, chtype ls, chtype rs, chtype ts, chtype bs,
 chtype tl,chtype tr, chtype bl, chtype br);
int box(WINDOW *win, chtype verch, chtype horch);
The border() and wborder() functions draw a border around the specified window. All parameters must be single-
byte characters whose rendition can be expressed using only constants beginning with ACS_. A parameter with the
value of 0 is replaced by the default value.
tab() box; cw(1.83i) cw(1.83i) cw(1.83i) cw(1.83i) cw(1.83i) cw(1.83i) Constant Values for Borders _ ParameterDe<hy>
fault ConstantDefault Character _ verch ACS_VLINE| horch ACS_HLINE- lsACS_VLINE| rsACS_VLINE|
tsACS_HLINE- bsACS_HLINE- blACS_BLCORNER+ brACS_BRCORNER+ tlACS_ULCORNER+
trACS_URCORNER+
The call
 box(win,
 verch, horch)
is a short form for
 wborder(win,
 verch, verch,
 horch, horch, 0, 0, 0,
 0)
When the window is boxed, the bottom and top rows and right and left columns overwrite existing text.
ls Is the character and rendition used for the left side of the border.
rs Is the character and rendition used for the right side of the border.
ts Is the character and rendition used for the top of the border.
bs Is the character and rendition used for the bottom of the border.
tl Is the character and rendition used for the top-left corner of the border.
tr Is the character and rendition used for the top-right corner of the border.
bl Is the character and rendition used for the bottom-left corner of the border.
<beginning of page>
br Is the character and rendition used for the bottom-right corner of the border.
win Is the pointer to the window in which the border or box is to be drawn.
verch Is the character and rendition used for the left and right columns of the box.
horch Is the character and rendition used for the top and bottom rows of the box.
On success, these functions return OK. Otherwise, they return ERR.
None.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
add_wch(3XCURSES), addch(3XCURSES), attr_get(3XCURSES), attroff(3XCURSES), border_set(3XCURS<hy>
ES), libcurses(3XCURSES), attributes(5), standards(5)
break.1 <beginning of page>
break, continue <-> shell built-in functions to escape from or advance within a controlling while, for, foreach, or until
loop
break [n]
continue [n]
break
continue
*break [n]
*continue [n]
+break [n]
+continue [n]
The break utility exits from the enclosing for or while loop, if any. If n is specified, break n levels.
The continue utility resumes the next iteration of the enclosing for or while loop. If n is specified, resume at the n-th
enclosing loop.
The break utility resumes execution after the end of the nearest enclosing foreach or while loop. The remaining
commands on the current line are executed. This allows multilevel breaks to be written as a list of break commands,
all on one line.
The continue utility continues execution of the next iteration of the nearest enclosing while or foreach loop.
The break utility exits from the enclosed for, while, until, or select loop, if any. If n is specified, then break n lev<hy>
els. If n is greater than the number of enclosing loops, the outermost enclosing loop shall be exited.
The continue utility resumes the next iteration of the enclosed for, while, until, or select loop. If n is specified then
resume at the n-th enclosed loop. If n is greater than the number of enclosing loops, the outermost enclosing loop
shall be used.
On this manual page, ksh(1) commands that are preceded by one or two * (asterisks) are treated specially in the fol<hy>
lowing ways: 1. Variable assignment lists preceding the command remain in effect when the command completes.
2. I/O redirections are processed after variable assignments. 3. Errors cause a script that contains them to abort. 4.
Words that follow a command preceded by ** that are in the format of a variable assignment are expanded with the
same rules as a variable assignment. This means that tilde substitution is performed after the = sign, and also that
word splitting and file name generation are not performed.
break is a shell special built-in that exits the smallest enclosing for, select, while, or until loop. It also exits the nth
enclosing loop if n is specified. Execution continues at the command following the loop or loops.
If n is specified, it must be a positive integer <>=>1. If n is larger than the number of enclosing loops, the last enclosing
loop is exited.
continue is a shell special built-in that continues execution at the top of the smallest enclosing for, select, while, or
until loop, if any; or of the top of the nth enclosing loop if n is specified.
If n is specified, it must be a positive integer <>=>1. If n is larger than the number of enclosing loops, the last enclosing
loop is used.
On this manual page, ksh93(1) commands that are preceded by one or two + symbols are special built-in commands
and are treated the following ways: 1. Variable assignment lists preceding the command remain in effect when the
command completes. 2. I/O redirections are processed after variable assignments. 3. Errors cause a script that con<hy>
tains them to abort. 4. Built-in commands are not valid function names. 5. Words following a command preceded
by ++ that are in the format of a variable assignment are expanded with rules as a variable assignment. This means
that tilde substitution is performed after the = sign and field splitting and file name generation are not performed.
See attributes(5) for descriptions of the following attributes:
<beginning of page>
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
csh(1), exit(1), ksh(1), ksh93(1), sh(1), attributes(5)
btohex.3tsol <beginning of page>
btohex, bsltoh, bcleartoh, bsltoh_r, bcleartoh_r, h_alloc, h_free <-> convert binary label to hexadecimal
cc [flag...] file... -ltsol [library...]
#include <tsol/label.h>
char *bsltoh(const m_label_t *label);
char *bcleartoh(const m_label_t *clearance);
char *bsltoh_r(const m_label_t *label, char *hex);
char *bcleartoh_r(const m_label_t *clearance, char *hex);
char *h_alloc(const unsigned char type);
void h_free(char *hex);
These functions convert binary labels into hexadecimal strings that represent the internal value.
The bsltoh() and bsltoh_r() functions convert a binary sensitivity label into a string of the form:
 [0xsensitivity_label_hexadecimal_value]
The bcleartoh() and bcleartoh_r() functions convert a binary clearance into a string of the form:
 0xclearance_hexadecimal_value
The h_alloc() function allocates memory for the hexadecimal value type for use by bsltoh_r() and bcleartoh_r().
Valid values for type are:
SUN_SL_ID label is a binary sensitivity label.
SUN_CLR_ID label is a binary clearance.
The h_free() function frees memory allocated by h_alloc().
These functions return a pointer to a string that contains the result of the translation, or (char *)0 if the parameter is
not of the required type.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Obsolete _ MT-LevelMT-Safe with exceptions
The bsltoh(), bcleartoh(), bsltoh_r(), bcleartoh_r(), h_alloc(), and h_free() functions are Obsolete. Use the la<hy>
bel_to_str(3TSOL) function instead.
The bsltoh() and bcleartoh() functions share the same statically allocated string storage. They are not MT-Safe.
Subsequent calls to any of these functions will overwrite that string with the newly translated string. The bsltoh_r()
and bcleartoh_r() functions should be used in multithreaded applications.
atohexlabel(1M), hextoalabel(1M),label_to_str(3TSOL), libtsol(3LIB), attributes(5), labels(5)
The functionality described on this manual page is available only if the system is configured with Trusted Exten<hy>
sions.
a64l.3c <beginning of page>
a64l, l64a <-> convert between long integer and base-64 ASCII string
#include <stdlib.h>
long a64l(const char *s);
char *l64a(long l);
These functions maintain numbers stored in base-64 ASCII characters that define a notation by which long integers
can be represented by up to six characters. Each character represents a "digit" in a radix-64 notation.
The characters used to represent "digits" are as follows:
tab() box; lw(2.76i) |lw(2.74i) lw(2.76i) |lw(2.74i) CharacterDigit _ .0 /1 0-92-11 A-Z12-37 a-z38-63
The a64l() function takes a pointer to a null-terminated base-64 representation and returns a corresponding long val<hy>
ue. If the string pointed to by s contains more than six characters, a64l() uses the first six.
The a64l() function scans the character string from left to right with the least significant digit on the left, decoding
each character as a 6-bit radix-64 number.
The l64a() function takes a long argument and returns a pointer to the corresponding base-64 representation. If the
argument is 0, l64a() returns a pointer to a null string.
The value returned by l64a() is a pointer into a static buffer, the contents of which are overwritten by each call. In
the case of multithreaded applications, the return value is a pointer to thread specific data.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStandard _ MT-LevelMT-Safe
attributes(5), standards(5)
accept.1m <beginning of page>
accept, reject <-> accept or reject print requests
accept destination...
reject [-r reason] destination...
accept allows the queueing of print requests for the named destinations.
reject prevents queueing of print requests for the named destinations.
Use lpstat -a to check if destinations are accepting or rejecting print requests.
Generally, accept and reject are run on the print server to control local print queues. Under some configurations, ac<hy>
cept and reject are run on client systems when IPP is being used to communicate between client and server.
The following options are supported for reject:
-r reason Assigns a reason for rejection of print requests for destination.
reason is reported by lpstat -a. By default, reason is unknown reason for existing destinations, and new printer for
destinations added to the system but not yet accepting requests. Enclose reason in quotes if it contains blanks.
The following operands are supported:
destination The name of the destination accepting or rejecting print requests. Destination specifies the name of a
printer or class of printers (see lpadmin(1M)). Specify destination using atomic name or URI-style (scheme://end<hy>
point) names. See printers.conf(4) for information regarding the naming conventions for destinations.
The following exit values are returned:
0 Successful completion.
non-zero An error occurred.
/etc/printers.conf System printer configuration database
$HOME/.printers User-configurable printer database
ou=printers LDAP version of /etc/printers.conf
printers.conf.byname NIS version of /etc/printers.conf
printers.org_dir NIS+ version of /etc/printers.conf
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wlp-cmds _ CSIEnabled. See NOTES. _ Interface StabilityObsolete
enable(1), lp(1), lpstat(1), lpadmin(1M), lpsched(1M), printers.conf(4), attributes(5)
accept and reject affect only queueing on the print server's spooling system. Requests made from a client system re<hy>
main queued in the client system's queueing mechanism until they are cancelled or accepted by the print server's
spooling system.
<beginning of page>
accept is CSI-enabled except for the destination name.
When IPP is in use, the user is prompted for a passphrase if the remote print service is configured to require authen<hy>
tication.
acct.1m <beginning of page>
acct, acctdisk, acctdusg, accton, acctwtmp, closewtmp, utmp2wtmp <-> overview of accounting and miscellaneous ac<hy>
counting commands
/usr/lib/acct/acctdisk
/usr/lib/acct/acctdusg [-u filename] [-p filename]
/usr/lib/acct/accton [filename]
/usr/lib/acct/acctwtmp reason filename
/usr/lib/acct/closewtmp
/usr/lib/acct/utmp2wtmp
Accounting software is structured as a set of tools (consisting of both C programs and shell procedures) that can be
used to build accounting systems. acctsh(1M) describes the set of shell procedures built on top of the C programs.
Connect time accounting is handled by various programs that write records into /var/adm/wtmpx, as described in
utmpx(4). The programs described in acctcon(1M) convert this file into session and charging records, which are
then summarized by acctmerg(1M).
Process accounting is performed by the system kernel. Upon termination of a process, one record per process is writ<hy>
ten to a file (normally /var/adm/pacct). The programs in acctprc(1M) summarize this data for charging purposes;
acctcms(1M) is used to summarize command usage. Current process data may be examined using acctcom(1).
Process accounting records and connect time accounting records (or any accounting records in the tacct format de<hy>
scribed in acct.h(3HEAD)) can be merged and summarized into total accounting records by acctmerg (see tacct
format in acct.h(3HEAD)). prtacct (see acctsh(1M)) is used to format any or all accounting records.
acctdisk reads lines that contain user ID, login name, and number of disk blocks and converts them to total account<hy>
ing records that can be merged with other accounting records. acctdisk returns an error if the input file is corrupt or
improperly formatted.
acctdusg reads its standard input (usually from find / -print) and computes disk resource consumption (including
indirect blocks) by login.
accton without arguments turns process accounting off. If filename is given, it must be the name of an existing file,
to which the kernel appends process accounting records (see acct(2) and acct.h(3HEAD)).
acctwtmp writes a utmpx(4) record to filename. The record contains the current time and a string of characters that
describe the reason. A record type of ACCOUNTING is assigned (see utmpx(4)) reason must be a string of 11 or
fewer characters, numbers, $, or spaces. For example, the following are suggestions for use in reboot and shutdown
procedures, respectively:
 acctwtmp "acctg on" /var/adm/wtmpx
 acctwtmp "acctg off" /var/adm/wtmpx
For each user currently logged on, closewtmp puts a false DEAD_PROCESS record in the /var/adm/wtmpx file.
runacct (see runacct(1M)) uses this false DEAD_PROCESS record so that the connect accounting procedures can
track the time used by users logged on before runacct was invoked.
For each user currently logged on, runacct uses utmp2wtmp to create an entry in the file /var/adm/wtmpx, created
by runacct. Entries in /var/adm/wtmpx enable subsequent invocations of runacct to account for connect times of
users currently logged in.
The following options are supported:
-u filename Places in filename records consisting of those filenames for which acctdusg charges no one (a potential
source for finding users trying to avoid disk charges).
-p filename Specifies a password file, filename. This option is not needed if the password file is /etc/passwd.
<beginning of page>
If any of the LC_* variables (LC_TYPE, LC_MESSAGES, LC_TIME, LC_COLLATE, LC_NUMERIC, and
LC_MONETARY) (see environ(5)) are not set in the environment, the operational behavior of acct for each corre<hy>
sponding locale category is determined by the value of the LANG environment variable. If LC_ALL is set, its con<hy>
tents are used to override both the LANG and the other LC_* variables. If none of the above variables are set in the
environment, the "C" (U.S. style) locale determines how acct behaves.
LC_CTYPE Determines how acct handles characters. When LC_CTYPE is set to a valid value, acct can display
and handle text and filenames containing valid characters for that locale. acct can display and handle Extended Unix
Code (EUC) characters where any character can be 1, 2, or 3 bytes wide. acct can also handle EUC characters of 1,
2, or more column widths. In the "C" locale, only characters from ISO 8859-1 are valid.
LC_TIME Determines how acct handles date and time formats. In the "C" locale, date and time handling follows
the U.S. rules.
/etc/passwd Used for login name to user ID conversions.
/usr/lib/acct Holds all accounting commands listed in sub-class 1M of this manual.
/var/adm/pacct Current process accounting file.
/var/adm/wtmpx History of user access and administration information..
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Availability<hy>
SUNWaccu
acctcom(1), acctcms(1M), acctcon(1M), acctmerg(1M), acctprc(1M), acctsh(1M), fwtmp(1M), runacct(1M), ac<hy>
ct(2), acct.h(3HEAD), passwd(4), utmpx(4), attributes(5), environ(5)

acctcom.1 <beginning of page>
acctcom <-> search and print process accounting files
acctcom [-abfhikmqrtv] [-C sec] [-e time] [-E time]
 [-g group] [-H factor] [-I chars] [-l line]
 [-n pattern] [-o output-file] [-O sec] [-s time]
 [-S time] [-u user] [filename]...
The acctcom utility reads filenames, the standard input, or /var/adm/pacct, in the form described by ac<hy>
ct.h(3HEAD) and writes selected records to standard output. Each record represents the execution of one process.
The output shows the COMMAND NAME, USER, TTYNAME, START TIME, END TIME, REAL (SEC),
CPU (SEC), MEAN SIZE (K), and optionally, F (the fork()/exec() flag: 1 for fork() without exec()), STAT (the
system exit status), HOG FACTOR, KCORE MIN, CPU FACTOR, CHARS TRNSFD, and BLOCKS READ
(total blocks read and written).
A `#' is prepended to the command name if the command was executed with super-user privileges. If a process is
not associated with a known terminal, a `?' is printed in the TTYNAME field.
If no filename is specified, and if the standard input is associated with a terminal or /dev/null (as is the case when
using `&' in the shell), /var/adm/pacct is read; otherwise, the standard input is read.
If any filename arguments are given, they are read in their respective order. Each file is normally read forward, that
is, in chronological order by process completion time. The file /var/adm/pacct is usually the current file to be exam<hy>
ined; a busy system may need several such files of which all but the current file are found in /var/adm/pacctincr.
The following options are supported:
-a Show some average statistics about the processes selected. The statistics will be printed after the output records.
-b Read backwards, showing latest commands first. This option has no effect when standard input is read.
-f Print the fork()/exec() flag and system exit status columns in the output. The numeric output for this option will
be in octal.
-h Instead of mean memory size, show the fraction of total available CPU time consumed by the process during its
execution. This "hog factor" is computed as (total CPU time)/(elapsed time).
-i Print columns containing the I/O counts in the output.
-k Instead of memory size, show total kcore-minutes.
-m Show mean core size (the default).
-q Do not print any output records, just print the average statistics as with the -a option.
-r Show CPU factor (user-time/(system-time + user-time)).
-t Show separate system and user CPU times.
-v Exclude column headings from the output.
-C sec Show only processes with total CPU time (system-time + user-time) exceeding sec seconds.
-e time Select processes existing at or before time.
<beginning of page>
-E time Select processes ending at or before time. Using the same time for both -S and -E shows the processes that
existed at time.
-g group Show only processes belonging to group. The group may be designated by either the group ID or group
name.
-H factor Show only processes that exceed factor, where factor is the "hog factor" as explained in option -h above.
-I chars Show only processes transferring more characters than the cutoff number given by chars.
-l line Show only processes belonging to terminal /dev/term/line.
-n pattern Show only commands matching pattern that may be a regular expression as in regcmp(3C), except +
means one or more occurrences.
-o output-file Copy selected process records in the input data format to output-file; suppress printing to standard out<hy>
put.
-O sec Show only processes with CPU system time exceeding sec seconds.
-s time Select processes existing at or after time, given in the format hr[:min[:sec]].
-S time Select processes starting at or after time.
-u user Show only processes belonging to user. The user may be specified by a user ID, a login name that is then
converted to a user ID, `#' (which designates only those processes executed with superuser privileges), or `?'
(which designates only those processes associated with unknown user IDs).
/etc/group system group file
/etc/passwd system password file
/var/adm/pacctincr active processes accounting file
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Availability<hy>
SUNWaccu _ CSIEnabled
ps(1), acct(1M), acctcms(1M), acctcon(1M), acctmerg(1M), acctprc(1M), acctsh(1M), fwtmp(1M), runac<hy>
ct(1M), su(1M), acct(2), regcmp(3C), acct.h(3HEAD), utmp(4), attributes(5)
System Administration Guide: Basic Administration
acctcom reports only on processes that have terminated; use ps(1) for active processes.
acctprc.1m <beginning of page>
acctprc, acctprc1, acctprc2 <-> process accounting
/usr/lib/acct/acctprc
/usr/lib/acct/acctprc1 [ctmp]
/usr/lib/acct/acctprc2
acctprc reads the standard input and converts it to total accounting records (see the tacct record in acct.h(3HEAD)).
acctprc divides CPU time into prime time and non-prime time and determines mean memory size (in memory seg<hy>
ment units). acctprc then summarizes the tacct records, according to user IDs, and adds login names corresponding
to the user IDs. The summarized records are then written to the standard output. acctprc1 reads input in the form de<hy>
scribed by acct.h(3HEAD), adds login names corresponding to user IDs, then writes for each process an ASCII line
giving user ID, login name, prime CPU time (tics), non-prime CPU time (tics), and mean memory size (in memory
segment units). If ctmp is given, it should contain a list of login sessions sorted by user ID and login name. If this
file is not supplied, it obtains login names from the password file, just as acctprc does. The information in ctmp
helps it distinguish between different login names that share the same user ID.
From the standard input, acctprc2 reads records in the form written by acctprc1, summarizes them according to us<hy>
er ID and name, then writes the sorted summaries to the standard output as total accounting records. Example 1 Ex<hy>
amples of acctprc.
The acctprc command is typically used as shown below:
 example% acctprc < /var/adm/pacct > ptacct
The acctprc1 and acctprc2s commands are typically used as shown below:
 example% acctprc1 ctmp </var/adm/pacct
 example% acctprc2 > ptacct
/etc/passwd system password file
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Availability<hy>
SUNWaccu
acctcom(1), acct(1M), acctcms(1M), acctcon(1M), acctmerg(1M), acctsh(1M), cron(1M), fwtmp(1M), runac<hy>
ct(1M), acct(2), acct.h(3HEAD), utmpx(4), attributes(5)
Although it is possible for acctprc1 to distinguish among login names that share user IDs for commands run from a
command line, it is difficult for acctprc1 to make this distinction for commands invoked in other ways. A command
run from cron(1M) is an example of where acctprc1 might have difficulty. A more precise conversion can be done
using the acctwtmp program in acct(1M). acctprc does not distinguish between users with identical user IDs.
A memory segment of the mean memory size is a unit of measure for the number of bytes in a logical memory seg<hy>
ment on a particular processor.
During a single invocation of any given command, the acctprc, acctprc1, and acctprc2 commands can process a
maximum of <bu> 6000 distinct sessions <bu> 1000 distinct terminal lines <bu> 2000 distinct login names
If at some point the actual number of any one of these items exceeds the maximum, the command will not succeed.
acl_check.3sec <beginning of page>
acl_check <-> check the validity of an ACL
cc [ flag... ] file... -lsec [ library... ]
#include <sys/acl.h>
int acl_check(acl_t *aclp, int isdir);
The acl_check() function checks the validity of an ACL pointed to by aclp. The isdir argument checks the validity
of an ACL that will be applied to a directory. The ACL can be either a POSIX draft ACL as supported by UFS or
NFSv4 ACL as supported by ZFS or NFSV4.
When the function verifies a POSIX draft ACL, the rules followed are described in aclcheck(3SEC). For NFSv4
ACL, the ACL is verified against the following rules: <bu> The inheritance flags are valid. <bu> The ACL must have at least
one ACL entry and no more than {MAX_ACL_ENTRIES}. <bu> The permission field contains only supported per<hy>
missions. <bu> The entry type is valid. <bu> The flag fields contain only valid flags as supported by NFSv4/ZFS.
If any of the above rules are violated, the function fails with errno set to EINVAL.
If the ACL is valid, acl_check() returns 0. Otherwise errno is set to EINVAL and the return value is set to one of
the following:
EACL_INHERIT_ERROR There are invalid inheritance flags specified.
EACL_FLAGS_ERROR There are invalid flags specified on the ACL that don't map to supported flags in
NFSV4/ZFS ACL model.
EACL_ENTRY_ERROR The ACL contains an unknown value in the type field.
EACL_MEM_ERROR The system cannot allocate any memory.
EACL_INHERIT_NOTDIR Inheritance flags are only allowed for ACLs on directories.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
acl(2), aclcheck(3SEC), aclsort(3SEC), acl(5), attributes(5)
aclsort.3sec <beginning of page>
aclsort <-> sort an ACL
cc [ flag ... ] file ... -lsec [ library ... ]
#include <sys/acl.h>
int aclsort(int nentries, int calclass, aclent_t *aclbufp);
The aclbufp argument points to a buffer containing ACL entries. The nentries argument specifies the number of
ACL entries in the buffer. The calclass argument, if non-zero, indicates that the CLASS_OBJ (ACL mask) permis<hy>
sions should be recalculated. The union of the permission bits associated with all ACL entries in the buffer other
than CLASS_OBJ, OTHER_OBJ, and USER_OBJ is calculated. The result is copied to the permission bits asso<hy>
ciated with the CLASS_OBJ entry.
The aclsort() function sorts the contents of the ACL buffer as follows: <bu> Entries will be in the order USER_OBJ,
USER, GROUP_OBJ, GROUP, CLASS_OBJ (ACL mask), OTHER_OBJ, DEF_USER_OBJ, DEF_USER,
DEF_GROUP_OBJ, DEF_GROUP, DEF_CLASS_OBJ (default ACL mask), and DEF_OTHER_OBJ. <bu> En<hy>
tries of type USER, GROUP, DEF_USER, and DEF_GROUP will be sorted in increasing order by ID.
The aclsort() function will succeed if all of the following are true: <bu> There is exactly one entry each of type US<hy>
ER_OBJ, GROUP_OBJ, CLASS_OBJ (ACL mask), and OTHER_OBJ. <bu> There is exactly one entry each of
type DEF_USER_OBJ, DEF_GROUP_OBJ, DEF_CLASS_OBJ (default ACL mask), and DEF_OTHER_OBJ
if there are any default entries. <bu> Entries of type USER, GROUP, DEF_USER, or DEF_GROUP may not contain
duplicate entries. A duplicate entry is one of the same type containing the same numeric ID.
Upon successful completion, the function returns 0. Otherwise, it returns <mi>1.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyEvolving _ MT-LevelUnsafe
acl(2), aclcheck(3SEC), attributes(5)
acltotext.3sec <beginning of page>
acltotext, aclfromtext <-> convert internal representation to or from external representation
cc [ flag... ] file... -lsec [ library... ]
#include <sys/acl.h>
char *acltotext(aclent_t *aclbufp, int aclcnt);
aclent_t *aclfromtext(char *acltextp, int *aclcnt);
The acltotext() function converts an internal ACL representation pointed to by aclbufp into an external ACL repre<hy>
sentation. The space for the external text string is obtained using malloc(3C). The caller is responsible for freeing
the space upon completion..
The aclfromtext() function converts an external ACL representation pointed to by acltextp into an internal ACL
representation. The space for the list of ACL entries is obtained using malloc(3C). The caller is responsible for
freeing the space upon completion. The aclcnt argument indicates the number of ACL entries found.
An external ACL representation is defined as follows:
<acl_entry>[,<acl_entry>]...
Each <acl_entry> contains one ACL entry. The external representation of an ACL entry contains two or three colon-
separated fields. The first field contains the ACL entry tag type. The entry type keywords are defined as:
user This ACL entry with no UID specified in the ACL entry ID field specifies the access granted to the owner of
the object. Otherwise, this ACL entry specifies the access granted to a specific user-name or user-id number.
group This ACL entry with no GID specified in the ACL entry ID field specifies the access granted to the owning
group of the object. Otherwise, this ACL entry specifies the access granted to a specific group-name or group-id
number.
other This ACL entry specifies the access granted to any user or group that does not match any other ACL entry.
mask This ACL entry specifies the maximum access granted to user or group entries.
default:user This ACL entry with no uid specified in the ACL entry ID field specifies the default access granted to
the owner of the object. Otherwise, this ACL entry specifies the default access granted to a specific user-name or
user-ID number.
default:group This ACL entry with no gid specified in the ACL entry ID field specifies the default access granted
to the owning group of the object. Otherwise, this ACL entry specifies the default access granted to a specific group-
name or group-ID number.
default:other This ACL entry specifies the default access for other entry.
default:mask This ACL entry specifies the default access for mask entry.
The second field contains the ACL entry ID, as follows:
uid This field specifies a user-name, or user-ID if there is no user-name associated with the user-ID number.
gid This field specifies a group-name, or group-ID if there is no group-name associated with the group-ID number.
empty This field is used by the user and group ACL entry types.
<beginning of page>
The third field contains the following symbolic discretionary access permissions:
r read permission
w write permission
x execute/search permission
<mi> no access
Upon successful completion, the acltotext() function returns a pointer to a text string. Otherwise, it returns NULL.
Upon successful completion, the aclfromtext() function returns a pointer to a list of ACL entries. Otherwise, it re<hy>
turns NULL.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyEvolving _ MT-LevelUnsafe
acl(2), malloc(3C), attributes(5)
ad.5 <beginning of page>
ad <-> Active Directory as a naming repository
Solaris clients can obtain naming information from Active Directory (AD) servers.
The Solaris system must first join an AD domain and then add the ad keyword to the appropriate entries in the nss<hy>
witch.conf(4) file. The Solaris system joins the AD domain by using the kclient(1M) utility. The AD name service
only supports the naming databases for passwd and group.
Windows users are not able to log in. The user_attr(4) database has no entries for Windows users, and the pass<hy>
wd(1) command does not support the synchronization of user passwords with AD.
The Solaris AD client uses auto-discovery techniques to find AD directory servers, such as domain controllers and
global catalog servers. The client also uses the LDAP v3 protocol to access naming information from AD servers.
The AD server schema requires no modification because the AD client works with native AD schema. The Solaris
AD client uses the idmap(1M) service to map between Windows security identifiers (SIDs) and Solaris user identi<hy>
fiers (UIDs) and group identifiers (GIDs). User names and group names are taken from the sAMAccountName at<hy>
tribute of the AD user and group objects and then tagged with the domain where the objects reside. The domain
name is separated from the user name or group name by the @ character.
The client uses the SASL/GSSAPI/KRB5 security model. The kclient utility is used to join the client to AD. During
the join operation, kclient configures Kerberos v5 on the client. See kclient(1M).
/etc/nsswitch.conf Configuration file for the name-service switch.
/etc/nsswitch.ad Sample configuration file for the name-service switch configured with ad, dns and files.
/usr/lib/nss_ad.so.1 Name service switch module for AD.
passwd(1), svcs(1), idmap(1M), idmapd(1M), kclient(1M), svcadm(1M), svccfg(1M), svccfg(1M), nss<hy>
witch.conf(4), user_attr(4), smf(5)
addbadsec.1m <beginning of page>
addbadsec <-> map out defective disk blocks
addbadsec [-p] [-a blkno [blkno]...] [-f filename] raw_device
addbadsec is used by the system administrator to map out bad disk blocks. Normally, these blocks are identified
during surface analysis, but occasionally the disk subsystem reports unrecoverable data errors indicating a bad block.
A block number reported in this way can be fed directly into addbadsec, and the block will be remapped. addbad<hy>
sec will first attempt hardware remapping. This is supported on SCSI drives and takes place at the disk hardware
level. If the target is an IDE drive, then software remapping is used. In order for software remapping to succeed, the
partition must contain an alternate slice and there must be room in this slice to perform the mapping.
It should be understood that bad blocks lead to data loss. Remapping a defective block does not repair a damaged
file. If a bad block occurs to a disk-resident file system structure such as a superblock, the entire slice might have to
be recovered from a backup.
The following options are supported:
-a Adds the specified blocks to the hardware or software map. If more than one block number is specified, the entire
list should be quoted and block numbers should be separated by white space.
-f Adds the specified blocks to the hardware or software map. The bad blocks are listed, one per line, in the specified
file.
-p Causes addbadsec to print the current software map. The output shows the defective block and the assigned alter<hy>
nate. This option cannot be used to print the hardware map.
The following operand is supported:
raw_device The address of the disk drive (see FILES).
The raw device should be /dev/rdsk/c?[t?]d?p0. See disks(1M) for an explanation of SCSI and IDE device naming
conventions.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86 _
AvailabilitySUNWcsu
disks(1M), diskscan(1M), fdisk(1M), fmthard(1M), format(1M), attributes(5)
The format(1M) utility is available to format, label, analyze, and repair SCSI disks. This utility is included with the
addbadsec, diskscan(1M), fdisk(1M), and fmthard(1M) commands available for x86. To format an IDE disk, use
the DOS "format" utility; however, to label, analyze, or repair IDE disks on x86 systems, use the Solaris for<hy>
mat(1M) utility.
add_drv.1m <beginning of page>
add_drv <-> add a new device driver to the system
add_drv [-b basedir] [-c class_name]
 [-i 'identify_name...'] [-m 'permission','...']
 [-p 'policy'] [-P privilege] [-n] [-f] [-v] device_driver
The add_drv command is used to inform the system about newly installed device drivers.
Each device on the system has a name associated with it. This name is represented by the name property for the de<hy>
vice. Similarly, the device may also have a list of driver names associated with it. This list is represented by the com<hy>
patible property for the device.
The system determines which devices will be managed by the driver being added by examining the contents of the
name property and the compatible property (if it exists) on each device. If the value in the name property does not
match the driver being added, each entry in the compatible property is tried, in order, until either a match occurs or
there are no more entries in the compatible property.
In some cases, adding a new driver may require a reconfiguration boot. See the NOTES section.
Aliases might require quoting (with double-quotes) if they contain numbers. See EXAMPLES.
add_drv and update_drv(1M) read the /etc/minor_perm file to obtain permission information. The permission
specified is applied to matching minor nodes created when a device bound to the driver is attached. A minor node's
permission may be manually changed by chmod(1). For such nodes, the specified permissions apply, overriding the
default  permissions specified via add_drv or update_drv(1M).
The format of the /etc/minor_perm file is as follows:
 name:minor_name permissions owner group
minor_name may be the actual name of the minor node, or contain shell metacharacters to represent several minor
nodes (see sh(1)).
For example:
 sd:* 0640 root sys
 zs:[a-z],cu 0600 uucp uucp
 mm:kmem 0640 root bin
The first line sets all devices exported by the sd node to 0640 permissions, owned by root, with group sys. In the
second line, devices such as a,cu and z,cu exported by the zs driver are set to 0600 permission, owned by uucp,
with group uucp. In the third line the kmem device exported by the mm driver is set to 0640 permission, owned by
root, with group bin.
When running add_drv from within the context of a package's postinstall script, you must consider whether the
package is being added to a system image or to a running system. When a package is being installed on a system im<hy>
age, such as occurs with the Live Upgrade or flash features (see live_upgrade(5) and flarcreate(1M)), the
BASEDIR variable refers to the image's base directory. In this situation, add_drv should be invoked with -b
$BASEDIR. This causes add_drv only to update the image's system files; a reboot of the system or client would be
required to make the driver operational.
When a package is being installed on the running system itself, the system files need to be updated, as in the case
above. However, the running kernel can be informed of the existence of the new driver without requiring a reboot. To
accomplish this, the postinstall script must invoke add_drv without the -b option. Accordingly, postinstall scripts
invoking add_drv should be written thusly:
 if [ "${BASEDIR:=/}" = "/" ]
 then
  ADD_DRV="add_drv"
 else
  ADD_DRV="add_drv -b ${BASEDIR}"
 fi
<beginning of page>
 $ADD_DRV [<options>] <driver>
...or, alternatively:
 if [ "${BASEDIR:=/}" != "/" ]
 then
  BASEDIR_OPT="-b $BASEDIR"
 fi
  add_drv $BASEDIR_OPT [<options>] <driver>
The -b option is described below.
-b basedir Installs the driver on the system with a root directory of basedir rather than installing on the system ex<hy>
ecuting add_drv. This option is typically used in package post-installation scripts when the package is not being in<hy>
stalled on the system executing the pkgadd command. The system using basedir as its root directory must reboot to
complete the driver installation. Note -
The root file system of any non-global zones must not be referenced with the -b option. Doing so might damage the
global zone's file system, might compromise the security of the global zone, and might damage the non-global
zone's file system. See zones(5).
-c class_name The driver being added to the system exports the class class_name.
-f Normally if a reconfiguration boot is required to complete the configuration of the driver into the system, add_drv
will not add the driver. The force flag forces add_drv to add the driver even if a reconfiguration boot is required. See
the -v flag.
-i 'identify_name' A white-space separated list of aliases for the driver device_driver.
-m 'permission' Specify the file system permissions for device nodes created by the system on behalf of de<hy>
vice_driver.
-n Do not try to load and attach device_driver, just modify the system configuration files for the device_driver.
-p 'policy' Specify an additional device security policy.
The device security policy constists of several whitespace separated tokens:
 {minorspec {token=value}+}+
minorspec is a simple wildcard pattern for a minor device. A single * matches all minor devices. Only one * is al<hy>
lowed in the pattern.
Patterns are matched in the following order: <bu> entries without a wildcard <bu> entries with wildcards, longest wildcard
first The following tokens are defined: read_priv_set and write_priv_set. read_priv_set defines the privileges that
need to be asserted in the effective set of the calling process when opening a device for reading. write_priv_set de<hy>
fines the privileges that need to be asserted in the effective set of the calling process when opening a device for writ<hy>
ing. See privileges(5).
A missing minor spec is interpreted as a *.
-P 'privilege' Specify additional, comma separated, privileges used by the driver. You can also use specific privileges
in the device's policy.
<beginning of page>
-v The verbose flag causes add_drv to provide additional information regarding the success or failure of a driver's
configuration into the system. See the EXAMPLES section.
Example 1 Adding SUNW Example Driver to the System
The following example adds the SUNW,example driver to a 32-bit system, with an alias name of SUNW,alias. It as<hy>
sumes the driver has already been copied to /usr/kernel/drv.
 example# add_drv -m '* 0666 bin bin','a 0644 root sys' \
  -p 'a write_priv_set=sys_config * write_priv_set=none' \
  -i 'SUNW,alias' SUNW,example
Every minor node created by the system for the SUNW,example driver will have the permission 0666, and be
owned by user bin in the group bin, except for the minor device a, which will be owned by root, group sys, and
have a permission of 0644. The specified device policy requires no additional privileges to open all minor nodes, ex<hy>
cept minor device a, which requires the sys_config privilege when opening the device for writing.
Example 2 Adding Driver to the Client /export/root/sun1
The following example adds the driver to the client /export/root/sun1. The driver is installed and loaded when the
client machine, sun1, is rebooted. This second example produces the same result as the first, except the changes are
on the diskless client, sun1, and the client must be rebooted for the driver to be installed.
 example# add_drv -m '* 0666 bin bin','a 0644 root sys' \
  -i 'SUNW,alias' -b /export/root/sun1 \
  SUNW,example
See the note in the description of the -b option, above, specifying the caveat regarding the use of this option with the
Solaris zones feature.
Example 3 Adding Driver for a Device Already Managed by an Existing Driver
The following example illustrates the case where a new driver is added for a device that is already managed by an
existing driver. Consider a device that is currently managed by the driver dumb_framebuffer. The name and com<hy>
patible properties for this device are as follows:
 name="display"
 compatible="whizzy_framebuffer", "dumb_framebuffer"
If add_drv is used to add the whizzy_framebuffer driver, the following will result.
 example# add_drv whizzy_framebuffer
 Error: Could not install driver (whizzy_framebuffer)
 Device managed by another driver.
If the -v flag is specified, the following will result.
 example# add_drv -v whizzy_framebuffer
 Error: Could not install driver (whizzy_framebuffer)
 Device managed by another driver.
 Driver installation failed because the following
 entries in /devices would be affected:
<beginning of page>
  /devices/iommu@f,e0000000/sbus@f,e0001000/display[:*]
  (Device currently managed by driver "dumb_framebuffer")
 The following entries in /dev would be affected:
  /dev/fbs/dumb_framebuffer0
If the -v and -f flags are specified, the driver will be added resulting in the following.
 example# add_drv -vf whizzy_framebuffer
 A reconfiguration boot must be performed to complete the
 installation of this driver.
 The following entries in /devices will be affected:
  /devices/iommu@f,e0000000/sbus@f,e0001000/display[:*]
  (Device currently managed by driver "dumb_framebuffer"
 The following entries in /dev will be affected:
  /dev/fbs/dumb_framebuffer0
The above example is currently only relevant to devices exporting a generic device name.
Example 4 Use of Double Quotes in Specifying Driver Alias
The following example shows the use of double quotes in specifying a driver alias that contains numbers.
 example# add_drv -i '"pci10c5,25"' smc
add_drv returns 0 on success and 1 on failure.
/kernel/drv
32-bit boot device drivers
/kernel/drv/sparcv9
64-bit SPARC boot device drivers
/kernel/drv/amd64
64-bit x86 boot device drivers
/usr/kernel/drv
other 32-bit drivers that could potentially be shared between platforms
/usr/kernel/drv/sparcv9
other 64-bit SPARC drivers that could potentially be shared between platforms
/usr/kernel/drv/amd64
other 64-bit x86 drivers that could potentially be shared between platforms
<beginning of page>
/platform/`uname -i`/kernel/drv
32-bit platform-dependent drivers
/platform/`uname -i`/kernel/drv/sparcv9
64-bit SPARC platform-dependent drivers
/platform/`uname -i`/kernel/drv/amd64
64-bit x86 platform-dependent drivers
/etc/driver_aliases
driver aliases file
/etc/driver_classes
driver classes file
/etc/minor_perm
minor node permissions
/etc/name_to_major
major number binding
/etc/security/device_policy
device policy
/etc/security/extra_privs
device privileges
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
boot(1M), chmod(1), devfsadm(1M), flarcreate(1M), kernel(1M), modinfo(1M), rem_drv(1M), up<hy>
date_drv(1M), driver.conf(4), system(4), attributes(5), live_upgrade(5), privileges(5), devfs(7FS), ddi_cre<hy>
ate_minor_node(9F)

It is possible to add a driver for a device already being managed by a different driver, where the driver being added
appears in the device's compatible list before the current driver. In such cases, a reconfiguration boot is required
(see boot(1M) and kernel(1M)). After the reconfiguration boot, device links in /dev and references to these files
may no longer be valid (see the -v flag). If a reconfiguration boot would be required to complete the driver installa<hy>
tion, add_drv will fail unless the -f option is specified. See Example 3 in the EXAMPLES section.
With the introduction of the device policy several drivers have had their minor permissions changed and a device
policy instated. The typical network driver should use the following device policy:
<beginning of page>
 add_drv -p 'read_priv_set=net_rawaccess\
  write_priv_set=net_rawaccess' -m '* 666 root sys'\
  mynet
This document does not constitute an API. /etc/minor_perm, /etc/name_to_major, /etc/driver_classes, and /de<hy>
vices may not exist or may have different contents or interpretations in a future release. The existence of this notice
does not imply that any other documentation that lacks this notice constitutes an API.
/etc/minor_perm can only be updated by add_drv(1M), rem_drv(1M) or update_drv(1M).
In the current version of add_drv, the use of double quotes to specify an alias is optional when used from the com<hy>
mand line. However, when using add_drv from packaging scripts, you should continue to use double quotes to
specify an alias.
Previous versions of add_drv accepted a pathname for device_driver. This feature is no longer supported and results
in failure.
addseverity.3c <beginning of page>
addseverity <-> build a list of severity levels for an application for use with fmtmsg
#include <fmtmsg.h>
int addseverity(int severity, const char *string);
The addseverity() function builds a list of severity levels for an application to be used with the message formatting
facility fmtmsg(). The severity argument is an integer value indicating the seriousness of the condition. The string
argument is a pointer to a string describing the condition (string is not limited to a specific size).
If addseverity() is called with an integer value that has not been previously defined, the function adds that new
severity value and print string to the existing set of standard severity levels.
If addseverity() is called with an integer value that has been previously defined, the function redefines that value
with the new print string. Previously defined severity levels may be removed by supplying the null string. If add<hy>
severity() is called with a negative number or an integer value of 0, 1, 2, 3, or 4, the function fails and returns <mi>1.
The values 0<mi>4 are reserved for the standard severity levels and cannot be modified. Identifiers for the standard lev<hy>
els of severity are:
MM_HALT Indicates that the application has encountered a severe fault and is halting. Produces the print string
HALT.
MM_ERROR Indicates that the application has detected a fault. Produces the print string ERROR.
MM_WARNING Indicates a condition that is out of the ordinary, that might be a problem, and should be watched.
Produces the print string WARNING.
MM_INFO Provides information about a condition that is not in error. Produces the print string INFO.
MM_NOSEV Indicates that no severity level is supplied for the message.
Severity levels may also be defined at run time using the SEV_LEVEL environment variable (see fmtmsg(3C)).
Upon successful completion, addseverity() returns MM_OK. Otherwise it returns MM_NOTOK. Example 1 Ex<hy>
ample of addseverity() function.
When the function call
 addseverity(7,"ALERT")
is followed by the call
 fmtmsg(MM_PRINT, "UX:cat", 7, "invalid syntax", "refer to manual",
 "UX:cat:001")
the resulting output is
 UX:cat: ALERT: invalid syntax
 TO FIX: refer to manual UX:cat:001
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT-LevelSafe
<beginning of page>
fmtmsg(1), fmtmsg(3C), gettxt(3C), printf(3C), attributes(5)
adjtime.2 <beginning of page>
adjtime <-> correct the time to allow synchronization of the system clock
#include <sys/time.h>
int adjtime(struct timeval *delta, struct timeval *olddelta);
The adjtime() function adjusts the system's notion of the current time as returned by gettimeofday(3C), advancing
or retarding it by the amount of time specified in the struct timeval pointed to by delta.
The adjustment is effected by speeding up (if that amount of time is positive) or slowing down (if that amount of
time is negative) the system's clock by some small percentage, generally a fraction of one percent. The time is al<hy>
ways a monotonically increasing function. A time correction from an earlier call to adjtime() may not be finished
when adjtime() is called again.
If delta is 0, then olddelta returns the status of the effects of the previous adjtime() call with no effect on the time
correction as a result of this call. If olddelta is not a null pointer, then the structure it points to will contain, upon
successful return, the number of seconds and/or microseconds still to be corrected from the earlier call. If olddelta is
a null pointer, the corresponding information will not be returned.
This call may be used in time servers that synchronize the clocks of computers in a local area network. Such time
servers would slow down the clocks of some machines and speed up the clocks of others to bring them to the aver<hy>
age network time.
Only a processes with appropriate privileges can adjust the time of day.
The adjustment value will be silently rounded to the resolution of the system clock.
Upon successful completion, adjtime() returns 0. Otherwise, it returns <mi>1 and sets errno to indicate the error.
The adjtime() function will fail if:
EFAULT The delta or olddelta argument points outside the process's allocated address space, or olddelta points to a
region of the process's allocated address space that is not writable.
EINVAL The tv_usec member of delta is not within valid range (<mi>1000000 to 1000000).
EPERM The {PRIV_SYS_TIME} privilege is not asserted in the effective set of the calling process.
Additionally, the adjtime() function will fail for 32-bit interfaces if:
EOVERFLOW The size of the tv_sec member of the timeval structure pointed to by olddelta is too small to con<hy>
tain the correct number of seconds.
date(1), gettimeofday(3C), privileges(5)
ahci.7d <beginning of page>
ahci <-> Advanced Host Controller Interface SATA controller driver
sata@unit-address
The ahci driver is a SATA framework-compliant HBA driver that supports SATA HBA controllers that are compati<hy>
ble with the Advanced Host Controller Interface 1.0 specification. AHCI is an Intel-developed protocol that de<hy>
scribes the register-level interface for host controllers for serial ATA 1.0a and Serial ATA II. The AHCI 1.0 specifica<hy>
tion describes the interface between the system software and the host controller hardware.
The ahci driver currently supports the Intel ICH6/7/8/9/10, VIA vt8251 and JMicron AHCI controllers which are
compliant with the Advanced Host Controller Interface 1.0 specification. The Intel ICH6/7/8/9 and VIA vt8251 con<hy>
trollers support standard SATA features. The ahci driver currently supports hard disk, ATAPI DVD, ATAPI tape, AT<hy>
API disk (i.e. Dell RD1000), hotplug, NCQ (Native command queuing) and Port multipliers (Silicon Image
3726/4726). Power management is not yet supported.
The ahci module contains no user configurable parameters.
/kernel/drv/ahci
32-bit ELF kernel module (x86).
/kernel/drv/amd64/ahci
64-bit ELF kernel module (x86).
See attributes(5) for descriptions of the following attribute:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86 _
AvailabilitySUNWahci
cfgadm(1M), cfgadm_sata(1M), prtconf(1M), sata(7D)
Advanced Host Controller Interface 1.0
Writing Device Drivers
To bind the ahci driver to your controller, choose the [AHCI] BIOS option.
Note that booting is not supported if toggle exists between the [IDE] and [AHCI] BIOS options
aio_fsync.3c <beginning of page>
aio_fsync <-> asynchronous file synchronization
#include <aio.h>
int aio_fsync(int op, struct aiocb *aiocbp);
The aio_fsync() function asynchronously forces all I/O operations associated with the file indicated by the file de<hy>
scriptor aio_fildes member of the aiocb structure referenced by the aiocbp argument and queued at the time of the
call to aio_fsync() to the synchronized I/O completion state. The function call returns when the synchronization re<hy>
quest has been initiated or queued to the file or device (even when the data cannot be synchronized immediately).
If op is O_DSYNC, all currently queued I/O operations are completed as if by a call to fdatasync(3C); that is, as de<hy>
fined for synchronized I/O data integrity completion. If op is O_SYNC, all currently queued I/O operations are com<hy>
pleted as if by a call to fsync(3C); that is, as defined for synchronized I/O file integrity completion. If the
aio_fsync() function fails, or if the operation queued by aio_fsync() fails, then, as for fsync(3C) and fdatasync(3C),
outstanding I/O operations are not guaranteed to have been completed.
If aio_fsync() succeeds, then it is only the I/O that was queued at the time of the call to aio_fsync() that is guaran<hy>
teed to be forced to the relevant completion state. The completion of subsequent I/O on the file descriptor is not
guaranteed to be completed in a synchronized fashion.
The aiocbp argument refers to an asynchronous I/O control block. The aiocbp value may be used as an argument to
aio_error(3C) and aio_return(3C) in order to determine the error status and return status, respectively, of the asyn<hy>
chronous operation while it is proceeding. When the request is queued, the error status for the operation is EIN<hy>
PROGRESS. When all data has been successfully transferred, the error status will be reset to reflect the success or
failure of the operation. If the operation does not complete successfully, the error status for the operation will be set
to indicate the error. The aio_sigevent member determines the asynchronous notification to occur when all opera<hy>
tions have achieved synchronized I/O completion (see signal.h(3HEAD)). All other members of the structure refer<hy>
enced by aiocbp are ignored. If the control block referenced by aiocbp becomes an illegal address prior to asynchro<hy>
nous I/O completion, then the behavior is undefined.
If the aio_fsync() function fails or the aiocbp indicates an error condition, data is not guaranteed to have been suc<hy>
cessfully transferred.
If aiocbp is NULL, then no status is returned in aiocbp, and no signal is generated upon completion of the operation.
The aio_fsync() function returns 0 to the calling process if the I/O operation is successfully queued; otherwise, the
function returns <mi>1 and sets errno to indicate the error.
The aio_fsync() function will fail if:
EAGAIN The requested asynchronous operation was not queued due to temporary resource limitations.
EBADF The aio_fildes member of the aiocb structure referenced by the aiocbp argument is not a valid file descrip<hy>
tor open for writing.
EINVAL The system does not support synchronized I/O for this file.
EINVAL A value of op other than O_DSYNC or O_SYNC was specified.
In the event that any of the queued I/O operations fail, aio_fsync() returns the error condition defined for read(2)
and write(2). The error will be returned in the error status for the asynchronous fsync(3C) operation, which can be
retrieved using aio_error(3C).
The aio_fsync() function has a transitional interface for 64-bit file offsets. See lf64(5).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe _ StandardSee standards(5).
<beginning of page>
fcntl(2), open(2), read(2), write(2), aio_error(3C), aio_return(3C), aio.h(3HEAD), fcntl.h(3HEAD), fdata<hy>
sync(3C), fsync(3C), signal.h(3HEAD), attributes(5), lf64(5), standards(5)
aio_req.9s <beginning of page>
aio_req <-> asynchronous I/O request structure
#include <sys/uio.h>
#include <sys/aio_req.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
Solaris DDI specific (Solaris DDI)
An aio_req structure describes an asynchronous I/O request.
 struct uio*aio_uio; /* uio structure describing the I/O request */
The aio_uio member is a pointer to a uio(9S) structure, describing the I/O transfer request.
aread(9E), awrite(9E), aphysio(9F), uio(9S)
aio_waitn.3c <beginning of page>
aio_waitn <-> wait for completion of asynchronous I/O operations
#include <aio.h>
int aio_waitn(struct aiocb *list[], uint_t nent,
 uint_t *nwait, const struct timespec *timeout);
The aio_waitn() function suspends the calling thread until at least the number of requests specified by nwait have
completed, until a signal interrupts the function, or if timeout is not NULL, until the time interval specified by time<hy>
out has passed.
To effect a poll, the timeout argument should be non-zero, pointing to a zero-valued timespec structure.
The list argument is an array of uninitialized I/O completion block pointers to be filled in by the system before
aio_waitn() returns. The nent argument indicates the maximum number of elements that can be placed in list[] and
is limited to _AIO_LISTIO_MAX = 4096.
The nwait argument points to the minimum number of requests aio_waitn() should wait for. Upon returning, the
content of nwait is set to the actual number of requests in the aiocb list, which can be greater than the initial value
specified in nwait. The aio_waitn() function attempts to return as many requests as possible, up to the number of
outstanding asynchronous I/Os but less than or equal to the maximum specified by the nent argument. As soon as the
number of outstanding asynchronous I/O requests becomes 0, aio_waitn() returns with the current list of completed
requests.
The aiocb structures returned will have been used in initiating an asynchronous I/O request from any thread in the
process with aio_read(3C), aio_write(3C), or lio_listio(3C).
If the time interval expires before the expected number of I/O operations specified by nwait are completed,
aio_waitn() returns the number of completed requests and the content of the nwait pointer is updated with that num<hy>
ber.
If aio_waitn() is interrupted by a signal, nwait is set to the number of completed requests.
The application can determine the status of the completed asynchronous I/O by checking the associated error and re<hy>
turn status using aio_error(3C) and aio_return(3C), respectively.
Upon successful completion, aio_waitn() returns 0. Otherwise, it returns -1 and sets errno to indicate the error.
The aio_waitn() function will fail if:
EAGAIN There are no outstanding asynchronous I/O requests.
EFAULT The list[], nwait, or timeout argument points to an address outside the address space of the process. The
errno variable is set to EFAULT only if this condition is detected by the application process.
EINTR The execution of aio_waitn() was interrupted by a signal.
EINVAL The timeout element tv_sec or tv_nsec is < 0, nent is set to 0 or > _AIO_LISTIO_MAX, or nwait is either
set to 0 or is > nent.
ENOMEM There is currently not enough available memory. The application can try again later.
ETIME The time interval expired before nwait outstanding requests have completed.
The aio_waitn() function has a transitional interface for 64-bit file offsets. See lf64(5).
See attributes(5) for descriptions of the following attributes:
<beginning of page>
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelSafe
aio.h(3HEAD), aio_error(3C), aio_read(3C), aio_write(3C), lio_listio(3C), aio_return(3C), attributes(5), lf64(5)
alias.4 <beginning of page>
alias <-> alias table file of encoding names
/usr/lib/iconv/alias
This file contains the alias table of encoding names for iconv_open(3C).
The format of the alias table is as follows:
 "%s %s\n", <variant encoding name>, <canonical encoding name>
The string specified for the variant encoding name is case-insensitive. A line beginning with '#' is treated as a com<hy>
ment.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyEvolving
iconv(3C), iconv_close(3C), iconv_open(3C), attributes(5)
allocb.9f <beginning of page>
allocb <-> allocate a message block
#include <sys/stream.h>
mblk_t *allocb(size_t size, uint_t pri);
Architecture independent level 1 (DDI/DKI).
The allocb() function tries to allocate a STREAMS message block. Buffer allocation fails only when the system is
out of memory. If no buffer is available, the bufcall(9F) function can help a module recover from an allocation fail<hy>
ure.
A STREAMS message block is composed of three structures. The first structure is a message block (mblk_t). See
msgb(9S). The mblk_t structure points to a data block structure (dblk_t). See datab(9S). Together these two struc<hy>
tures describe the message type (if applicable) and the size and location of the third structure, the data buffer. The
data buffer contains the data for this message block. The allocated data buffer is at least double-word aligned, so it
can hold any C data structure.
The fields in the mblk_t structure are initialized as follows:
b_cont set to NULL
b_rptr points to the beginning of the data buffer
b_wptr points to the beginning of the data buffer
b_datap points to the dblk_t structure
The fields in the dblk_t structure are initialized as follows:
db_base points to the first byte of the data buffer
db_lim points to the last byte + 1 of the buffer
db_type set to M_DATA
The following figure identifies the data structure members that are affected when a message block is allocated.
Printed copy or docs.sun.com shows a figure that identifies the data structure members that are affected when a mes<hy>
sage block is allocated
size The number of bytes in the message block.
pri Priority of the request (no longer used).
Upon success, allocb() returns a pointer to the allocated message block of type M_DATA. On failure, allocb() re<hy>
turns a NULL pointer.
The allocb() function can be called from user, interrupt, or kernel context. Example 1 allocb() Code Sample
Given a pointer to a queue (q) and an error number (err), the send_error() routine sends an M_ERROR type mes<hy>
sage to the stream head.
If a message cannot be allocated, NULL is returned, indicating an allocation failure (line 8). Otherwise, the message
<beginning of page>
type is set to M_ERROR (line 10). Line 11 increments the write pointer (bp->b_wptr) by the size (one byte) of
the data in the message.
A message must be sent up the read side of the stream to arrive at the stream head. To determine whether q points to
a read queue or to a write queue, the q->q_flag member is tested to see if QREADR is set (line 13). If it is not set, q
points to a write queue, and in line 14 the RD(9F) function is used to find the corresponding read queue. In line 15,
the putnext(9F) function is used to send the message upstream, returning 1 if successful.
 1 send_error(q,err)
 2 queue_t *q;
 3 unsigned char err;
 4 {
 5 mblk_t *bp;
 6
 7 if ((bp = allocb(1, BPRI_HI)) == NULL) /* allocate msg. block */
 8 return(0);
 9
 10 bp->b_datap->db_type = M_ERROR; /* set msg type to M_ERROR */
 11 *bp->b_wptr++ = err; /* increment write pointer */
 12
 13 if (!(q->q_flag & QREADR)) /* if not read queue */
 14 q = RD(q); /* get read queue */
 15 putnext(q,bp); /* send message upstream */
 16 return(1);
 17 }
RD(9F), bufcall(9F), esballoc(9F), esbbcall(9F), putnext(9F), testb(9F), datab(9S), msgb(9S)
Writing Device Drivers
STREAMS Programming Guide
The pri argument is no longer used, but is retained for compatibility with existing drivers.
a.out.4 <beginning of page>
a.out <-> Executable and Linking Format (ELF) files
#include <elf.h>
The file name a.out is the default output file name from the link editor, ld(1). The link editor will make an a.out ex<hy>
ecutable if there were no errors in linking. The output file of the assembler, as(1), also follows the format of the
a.out file although its default file name is different.
Programs that manipulate ELF files may use the library that elf(3ELF) describes. An overview of the file format fol<hy>
lows. For more complete information, see the references given below.
tab() box; cw(2.69i) |cw(2.81i) lw(2.69i) |lw(2.81i) Linking ViewExecution View _ ELF headerELF header _ Pro<hy>
gram header tableProgram header table optional _ Section 1Segment 1 _ . . . _ Section nSegment 2 _ . . . _ . . .. . . _
Section header tableSection header table optional
An ELF header resides at the beginning and holds a ``road map'' describing the file's organization. Sections hold the
bulk of object file information for the linking view: instructions, data, symbol table, relocation information, and so
on. Segments hold the object file information for the program execution view. As shown, a segment may contain one
or more sections.
A program header table, if present, tells the system how to create a process image. Files used to build a process im<hy>
age (execute a program) must have a program header table; relocatable files do not need one. A section header table
contains information describing the file's sections. Every section has an entry in the table; each entry gives informa<hy>
tion such as the section name, the section size, etc. Files used during linking must have a section header table; other
object files may or may not have one.
Although the figure shows the program header table immediately after the ELF header, and the section header table
following the sections, actual files may differ. Moreover, sections and segments have no specified order. Only the
ELF header has a fixed position in the file.
When an a.out file is loaded into memory for execution, three logical segments are set up: the text segment, the data
segment (initialized data followed by uninitialized, the latter actually being initialized to all 0's), and a stack. The
text segment is not writable by the program; if other processes are executing the same a.out file, the processes will
share a single text segment.
The data segment starts at the next maximal page boundary past the last text address. If the system supports more
than one page size, the ``maximal page'' is the largest supported size. When the process image is created, the part of
the file holding the end of text and the beginning of data may appear twice. The duplicated chunk of text that appears
at the beginning of data is never executed; it is duplicated so that the operating system may bring in pieces of the file
in multiples of the actual page size without having to realign the beginning of the data section to a page boundary.
Therefore, the first data address is the sum of the next maximal page boundary past the end of text plus the remain<hy>
der of the last text address divided by the maximal page size. If the last text address is a multiple of the maximal
page size, no duplication is necessary. The stack is automatically extended as required. The data segment is extended
as requested by the brk(2) system call.
as(1), ld(1), brk(2), elf(3ELF)
ANSI C Programmer's Guide
apropos.1 <beginning of page>
apropos <-> locate commands by keyword lookup
apropos keyword...
The apropos utility displays the man page name, section number, and a short description for each man page whose
NAME line contains keyword. This information is contained in the /usr/share/man/windex database created by cat<hy>
man(1M). If catman(1M) was not run, or was run with the -n option, apropos fails. Each word is considered sepa<hy>
rately and the case of letters is ignored. Words which are part of other words are considered; for example, when
looking for `compile', apropos finds all instances of `compiler' also.
apropos is actually just the -k option to the man(1) command. Example 1 To find a man page whose NAME line
contains a keyword
Try
 example% apropos password
and
 example% apropos editor
If the line starts `filename(section) ...' you can run
 man -s section filename
to display the man page for filename.
Example 2 To find the man page for the subroutine printf()
Try
 example% apropos format
and then
 example% man -s 3s printf
to get the manual page on the subroutine printf().
/usr/share/man/windex table of contents and keyword database
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wdoc _ CSIEnabled
<beginning of page>
man(1), whatis(1), catman(1M), attributes(5)
/usr/share/man/windex: No such file or directory
This database does not exist. catman(1M) must be run to create it.
arcmsr.7d <beginning of page>
arcmsr <-> SAS and SATA HBA driver for Areca Hardware Raid devices
The arcmsr host bus adapter driver is a SCSA-compliant nexus driver that supports Areca Technology SAS and SA<hy>
TA RAID devices.
Supported SATA RAID cards:
 ARC-1110 pci17d3,1110
 ARC-1120 pci17d3,1120
 ARC-1130 pci17d3,1130
 ARC-1160 pci17d3,1160
 ARC-1170 pci17d3,1170
 ARC-1201 pci17d3,1201
 ARC-1210 pci17d3,1210
 ARC-1220 pci17d3,1220
 ARC-1230 pci17d3,1230
 ARC-1260 pci17d3,1260
 ARC-1270 pci17d3,1270
 ARC-1280 pci17d3,1280
Supported SAS RAID cards:
 ARC-1380 pci17d3,1380
 ARC-1381 pci17d3,1381
 ARC-1680 pci17d3,1680
 ARC-1681 pci17d3,1681
There are no user configurable parameters available. Please configure your hardware through the host system BIOS.
/kernel/drv/arcmsr 32-bit ELF kernel module.
/kernel/drv/amd64/arcmsr 64-bit kernel module (x64 only).
/kernel/drv/arcmsr.conf Driver configuration file (contains no user-configurable options).
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86,
x64 only _ AvailabilitySUNWarcmsr
prtconf(1M), attributes(5), scsi_hba_attach_setup(9F), scsi_sync_pkt(9F), scsi_transport(9F), scsi_inquiry(9S),
scsi_device(9S), scsi_pkt(9S)
Small Computer System Interface-2 (SCSI-2)
http://www.areca.com.tw/products/main.htm
http://developer.intel.com/design/iio/index.htm <em>(Intel Corp IO processors provide the underlying RAID engine for
the supported devices).
arp.1m <beginning of page>
arp <-> address resolution display and control
arp hostname
arp -a [-n]
arp -d hostname
arp -f filename
arp -s hostname ether_address [temp] [pub] [trail]
 [permanent]
The arp program displays and modifies the Internet-to-MAC address translation tables used by the address resolu<hy>
tion protocol (see arp(7P)).
With no flags, the program displays the current ARP entry for hostname. The host may be specified by name or by
number, using Internet dot notation.
Options that modify the ARP translation tables (-d, -f, and -s) can be used only when the invoked command is grant<hy>
ed the sys_net_config privilege. See privileges(5).
-a Display all of the current ARP entries. The definition for the flags in the table are:
d Unverified; this is a local IP address that is currently undergoing Duplicate Address Detection. ARP will not re<hy>
spond to requests for this address until Duplicate Address Detection completes.
o Old; this entry is aging away. If IP requests it again, a new ARP query will be generated. This state is used for de<hy>
tecting peer address changes.
y Delayed; periodic address defense and conflict detection was unable to send a packet due to internal network use
limits for non-traffic-related messages (100 packets per hour per interface). This occurs only on interfaces with very
large numbers of aliases.
A Authority; this machine is authoritative for this IP address. ARP will not accept updates from other machines for
this entry.
L Local; this is a local IP address configured on one of the machine's logical interfaces. ARP will defend this ad<hy>
dress if another node attempts to claim it.
M Mapping; only used for the multicast entry for 224.0.0.0
P Publish; includes IP address for the machine and the addresses that have explicitly been added by the -s option.
ARP will respond to ARP requests for this address.
S Static; entry cannot be changed by learned information. This indicates that the permanent flag was used when
creating the entry.
U Unresolved; waiting for ARP response.
You can use the -n option with the -a option to disable the automatic numeric IP address-to-name translation. Use
arp -an or arp -na to display numeric IP addresses. The arp -a option is equivalent to:
 # netstat -p -f inet
...and -an and -na are equivalent to:
<beginning of page>
 # netstat -pn -f inet
-d Delete an entry for the host called hostname.
Note that ARP entries for IPMP (IP Network Multipathing) data and test addresses are managed by the kernel and
thus cannot be deleted.
-f Read the file named filename and set multiple entries in the ARP tables. Entries in the file should be of the form:
 hostname MACaddress [temp] [pub] [trail] [permanent]
See the -s option for argument definitions.
-s Create an ARP entry for the host called hostname with the MAC address MACaddress. For example, an Ethernet
address is given as six hexadecimal bytes separated by colons. The entry will not be subject to deletion by aging un<hy>
less the word temp is specified in the command. If the word pub is specified, the entry will be published, which
means that this system will respond to ARP requests for hostname even though the hostname is not its own. The
word permanent indicates that the system will not accept MAC address changes for hostname from the network.
Solaris does not implement trailer encapsulation, and the word trail is accepted on entries for compatibility only.
arp -s can be used for a limited form of proxy ARP when a host on one of the directly attached networks is not
physically present on a subnet. Another machine can then be configured to respond to ARP requests using arp -s.
This is useful in certain SLIP configurations.
Non-temporary proxy ARP entries for an IPMP (IP Network Multipathing) group are automatically managed by the
kernel. Specifically, if the hardware address in an entry matches the hardware address of an IP interface in an IPMP
group, and the IP address is not local to the system, this will be regarded as an IPMP proxy ARP entry. This entry
will have its hardware address automatically adjusted in order to keep the IP address reachable so long as the IPMP
group has not entirely failed.
ARP entries must be consistent across an IPMP group. Therefore, ARP entries cannot be associated with individual
underlying IP interfaces in an IPMP group, and must instead be associated with the corresponding IPMP IP inter<hy>
face.
Note that ARP entries for IPMP data and test addresses are managed by the kernel and thus cannot be changed.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
ifconfig(1M), netstat(1M), attributes(5), privileges(5), arp(7P)
ascii.5 <beginning of page>
ascii <-> map of ASCII character set
cat /usr/pub/ascii
/usr/pub/ascii is a map of the ASCII character set, to be printed as needed. It contains octal and hexadecimal values
for each character. While not included in that file, a chart of decimal values is also shown here.
  Octal <mi> Character
 000 NUL 001 SOH 002 STX 003 ETX 004 EOT 005 ENQ 006 ACK 007 BEL
 010 BS 011 HT 012 NL 013 VT 014 NP 015 CR 016 SO 017 SI
 020 DLE 021 DC1 022 DC2 023 DC3 024 DC4 025 NAK 026 SYN 027 ETB
 030 CAN 031 EM 032 SUB 033 ESC 034 FS 035 GS 036 RS 037 US
 040 SP 041 ! 042 " 043 # 044 $ 045 % 046 & 047 '
 050 ( 051 ) 052 * 053 + 054 , 055 <mi> 056 . 057 /
 060 0 061 1 062 2 063 3 064 4 065 5 066 6 067 7
 070 8 071 9 072 : 073 ; 074 < 075 = 076 > 077 ?
 100 @ 101 A 102 B 103 C 104 D 105 E 106 F 107 G
 110 H 111 I 112 J 113 K 114 L 115 M 116 N 117 O
 120 P 121 Q 122 R 123 S 124 T 125 U 126 V 127 W
 130 X 131 Y 132 Z 133 [ 134 \ 135 ] 136 ^ 137 _
 140 ` 141 a 142 b 143 c 144 d 145 e 146 f 147 g
 150 h 151 i 152 j 153 k 154 l 155 m 156 n 157 o
 160 p 161 q 162 r 163 s 164 t 165 u 166 v 167 w
 170 x 171 y 172 z 173 { 174 | 175 } 176 ~ 177 DEL
  Hexadecimal <mi> Character
 00 NUL 01 SOH 02 STX 03 ETX 04 EOT 05 ENQ 06 ACK 07 BEL
 08 BS 09 HT 0A NL 0B VT 0C NP 0D CR 0E SO 0F SI
 10 DLE 11 DC1 12 DC2 13 DC3 14 DC4 15 NAK 16 SYN 17 ETB
 18 CAN 19 EM 1A SUB 1B ESC 1C FS 1D GS 1E RS 1F US
 20 SP 21 ! 22 " 23 # 24 $ 25 % 26 & 27 '
 28 ( 29 ) 2A * 2B + 2C , 2D <mi> 2E . 2F /
 30 0 31 1 32 2 33 3 34 4 35 5 36 6 37 7
 38 8 39 9 3A : 3B ; 3C < 3D = 3E > 3F ?
 40 @ 41 A 42 B 43 C 44 D 45 E 46 F 47 G
 48 H 49 I 4A J 4B K 4C L 4D M 4E N 4F O
 50 P 51 Q 52 R 53 S 54 T 55 U 56 V 57 W
 58 X 59 Y 5A Z 5B [ 5C \ 5D ] 5E ^ 5F _
 60 ` 61 a 62 b 63 c 64 d 65 e 66 f 67 g
 68 h 69 i 6A j 6B k 6C l 6D m 6E n 6F o
 70 p 71 q 72 r 73 s 74 t 75 u 76 v 77 w
 78 x 79 y 7A z 7B { 7C | 7D } 7E ~ 7F DEL
  Decimal <mi> Character
  0 NUL 1 SOH 2 STX 3 ETX 4 EOT 5 ENQ 6 ACK 7 BEL
  8 BS 9 HT 10 NL 11 VT 12 NP 13 CR 14 SO 15 SI
  16 DLE 17 DC1 18 DC2 19 DC3 20 DC4 21 NAK 22 SYN 23 ETB
  24 CAN 25 EM 26 SUB 27 ESC 28 FS 29 GS 30 RS 31 US
  32 SP 33 ! 34 " 35 # 36 $ 37 % 38 & 39 '
  40 ( 41 ) 42 * 43 + 44 , 45 <mi> 46 . 47 /
  48 0 49 1 50 2 51 3 52 4 53 5 54 6 55 7
  56 8 57 9 58 : 59 ; 60 < 61 = 62 > 63 ?
  64 @ 65 A 66 B 67 C 68 D 69 E 70 F 71 G
  72 H 73 I 74 J 75 K 76 L 77 M 78 N 79 O
  80 P 81 Q 82 R 83 S 84 T 85 U 86 V 87 W
  88 X 89 Y 90 Z 91 [ 92 \ 93 ] 94 ^ 95 _
  96 ` 97 a 98 b 99 c 100 d 101 e 102 f 103 g
 104 h 105 i 106 j 107 k 108 l 109 m 110 n 111 o
 112 p 113 q 114 r 115 s 116 t 117 u 118 v 119 w
<beginning of page>
 120 x 121 y 122 z 123 { 124 | 125 } 126 ~ 127 DEL
/usr/pub/ascii On-line chart of octal and hexadecimal values for the ASCII character set.
ASSERT.9f <beginning of page>
ASSERT, assert <-> expression verification
#include <sys/debug.h>
void ASSERT(EX);
Architecture independent level 1 (DDI/DKI).
EX boolean expression.
The ASSERT() macro checks to see if the expression EX is true. If it is not, then ASSERT() causes an error mes<hy>
sage to be logged to the console and the system to panic. ASSERT() works only if the preprocessor symbol DE<hy>
BUG is defined.
The ASSERT() macro can be used from user, interrupt, or kernel context.
Writing Device Drivers
ata.7d <beginning of page>
ata <-> AT attachment disk driver
ide@unit-address
The ata driver supports disk and ATAPI CD/DVD devices conforming to the AT Attachment specification including
IDE interfaces. Support is provided for both parallel ATA (PATA) and serial ATA (SATA) interfaces.
Refer to the Solaris x86 Hardware Compatibility List for a list of supported controllers.
A PCI IDE controller can operate in compatibility mode or in PCI-native mode. If more than one controller is
present in the system, only one can operate in compatibility mode.
If two PATA drives share the same controller, you must set one to master and the other to slave. If both a PATA disk
drive and a PATA CD-ROM drive utilize the same controller, you can designate the disk drive as the master with the
CD-ROM drive as the slave, although this is not mandatory.
Supported settings for the primary controller when in compatibility mode are: <bu> IRQ Level: 14 <bu> I/O Address: 0x1F0
Supported settings for the secondary controller when in compatibility mode are: <bu> IRQ Level: 15 <bu> I/O Address:
0x170 Note -
When in PCI-native mode, the IRQ and I/O address resources are configured by the system BIOS. <bu> This driver does
not support any RAID features present on a PATA/SATA controller. As a result, you should configure BIOS to select
IDE mode rather than RAID mode. Some systems may require updating BIOS to allow switching modes. <bu> On some
systems, the SATA controller must have option ROM enabled or BIOS will not consider SATA drives as bootable
devices. <bu> Panasonic LK-MC579B and the Mitsumi FX34005 IDE CD-ROM drives are not supported and cannot be
used to install the Solaris operating environment. <bu> CMD-604 is unable to handle simultaneous I/O on both IDE in<hy>
terfaces. This defect causes the Solaris software to hang if both interfaces are used. Use only the primary IDE inter<hy>
face at address 0x1F0. <bu> NEC CDR-260/CDR-260R/CDR-273 and Sony CDU-55E ATAPI CD-ROM drives might
fail during installation. <bu> Sony CDU-701 CD-ROM drives must be upgraded to use firmware version 1.0r or later to
support booting from the CD.
A Compact Flash(CF) card can work as an ATA disk through a CF-to-ATA adapter. If both card and adapter imple<hy>
ment Compact Flash Version 2.0, DMA is supported. If either of them does not, you should set ata-disk-dma-en<hy>
abled to '0.'
The ata driver properties are usually set in ata.conf. However, it may be convenient, or in some cases necessary, for
you to set some of the DMA related properties as a system global boot environment property. You set or modify
properties in the boot environment immediately prior to booting the Solaris kernel using the GRUB boot loader ker<hy>
nel boot command line. You can also set boot environment properties using the eeprom(1M) command or by editing
the bootenv.rc configuration file. If a property is set in both the driver's ata.conf file and the boot environment, the
ata.conf property takes precedence.
Property modifications other than with the GRUB kernel boot command line are not effective until you reboot the
system. Property modifications via the GRUB kernel boot command line do not persist across future boots.
Direct Memory Access is enabled for disks and atapi CD/DVD by default. If you want to disable DMA when boot<hy>
ing from a CD/DVD, you must first set atapi-cd-dma-enabled to 0 using the GRUB kernel boot command line.
ata-dma-enabled This property is examined before the DMA properties discussed below. If it is set to '0,' DMA is
disabled for all ATA/ATAPI devices, and no further property checks are made. If this property is absent or is set to
'1,' DMA status is determined by further examining one of the other properties listed below.
ata-disk-dma-enabled This property is examined only for ATA disk devices, and only if ata-dma-enabled is not set
to '0.'
If ata-disk-dma-enabled set to '0,' DMA is disabled for all ATA disks in the system. If this property is absent or set
to '1,' DMA is enabled for all ATA disks and no further property checks are made. If needed, this property should be
created by the administrator using the GRUB kernel boot command line or the eeprom(1M) command.
atapi-cd-dma-enabled This property is examined only for ATAPI CD/DVD devices, and only if ata-dma-enabled is
not set to '0.'
If atapi-cd-dma-enabled is absent or set to '0,' DMA is disabled for all ATAPI CD/DVD's. If set to '1,' DMA is en<hy>
<beginning of page>
abled and no further property checks are made.
The Solaris installation program creates this property in the boot environment with a value of '1.' It can be changed
with the GRUB kernel boot command line or eeprom(1M) as shown in the Example section of this manpage.
atapi-other-dma-enabled This property is examined only for non-CD/DVD ATAPI devices such as ATAPI tape
drives, and only if ata-dma-enabled is not set to '0.'
If atapi-other-dma-enabled is set to '0,' DMA is disabled for all non-CD/DVD ATAPI devices. If this property is ab<hy>
sent or set to '1,' DMA is enabled and no further property checks are made.
If needed, this property should be created by the administrator using the GRUB kernel boot command line or the
eeprom(1M) command.
drive0_block_factor
drive1_block_factor ATA controllers support some amount of buffering (blocking). The purpose is to interrupt the
host when an entire buffer full of data has been read or written instead of using an interrupt for each sector. This re<hy>
duces interrupt overhead and significantly increases throughput. The driver interrogates the controller to find the buf<hy>
fer size. Some controllers hang when buffering is used, so the values in the configuration file are used by the driver
to reduce the effect of buffering (blocking). The values presented may be chosen from 0x1, 0x2, 0x4, 0x8 and 0x10.
The values as shipped are set to 0x1, and they can be tuned to increase performance.
If your controller hangs when attempting to use higher block factors, you may be unable to reboot the system. For
x86 based systems, it is recommended that tuning be performed using a duplicate of the /platform/i86pc/kernel di<hy>
rectory subtree. This ensures that a bootable kernel subtree exists in the event of a failed test.
ata-revert-to-defaults
revert<em><diskmodel> When rebooting or shutting down, the driver can set a feature which allows the drive to return
to the power-on settings when the drive receives a software reset (SRST) sequence. If this property is present and set
to 1, the driver will set the feature to revert to defaults during reset. Setting this property to 1 may prevent some sys<hy>
tems from soft-rebooting and would require cycling the power to boot the system. If this property is not present the
system will not set the feature to revert to defaults during reset.
To determine the string to substitute for <diskmodel>, boot your system (you may have to press the reset button or
power-cycle) and then view /var/adm/messages. Look for the string "IDE device at targ" or "ATAPI device at targ."
The next line will contain the word "model" followed by the model number and a comma. Ignore all characters ex<hy>
cept letters, digits, ".", "_", and "-". Change uppercase letters to lower case. If the string revert-<diskmodel> is
longer than 31 characters, use only the first 31 characters.
Example 1 Sample ata Configuration File
 # for higher performance - set block factor to 16
  drive0_block_factor=0x1 drive1_block_factor=0x1
  max_transfer=0x100
  flow_control="dmult" queue="qsort" disk="dadk" ;
Example 2 Revert to defaults property
 revert-st320420a=1;
Output of /var/adm/messages:
 Aug 17 06:49:43 caesar ata:[ID 640982 kern.info] IDE device at targ 0,
  lun 0 lastlun 0x0
 Aug 17 06:49:43 caesar ata:[ID 521533 kern.info] model ST320420A, stat
Example 3 Change DMA property using GRUB
To change a DMA property using the GRUB kernel boot command line:
1. Reset the system. 2. Press "e" to interrupt the timeout. 3. Select the kernel line. 4. Press "e." 5. If there is no
existing -B option:
<beginning of page>
Add: -B atapi-cd-dma-enabled=1
else...
Add: atapi-cd-dma-enabled=1 to the end of the current -B option. For example:-B foo=bar,atapi-cd-dma-enabled=1.
6. Press Enter to commit the edited line to memory. (Does not write to the disk and is non-persistent). 7. Press 'b'
to boot the modified entry. Example 4 Change DMA Property with eeprom(1M)
To enable DMA for optical devices while the Solaris kernel is running with the eeprom(1M) system command:
 eeprom 'atapi-cd-dma-enabled=1'
/platform/i86pc/kernel/drv/ata
Device driver.
/platform/i86pc/kernel/drv/ata.conf
Configuration file.
/boot/solaris/bootenv.rc
Boot environment variables file for Solaris x86. eeprom(1M) can be used to modify properties in this file.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86
eeprom(1M), attributes(5), grub(5)
INCITS T13 ATA/ATAPI-7 specifications
atexit.3c <beginning of page>
atexit <-> register a function to run at process termination or object unloading
#include <stdlib.h>
int atexit(void (*func)(void));
The atexit() function registers the function pointed to by func to be called without arguments on normal termination
of the program or when the object defining the function is unloaded.
Normal termination occurs by either a call to the exit(3C) function or a return from main(). Object unloading occurs
when a call to dlclose(3C) results in the object becoming unreferenced.
The number of functions that may be registered with atexit() is limited only by available memory (refer to the
_SC_ATEXIT_MAX argument of sysconf(3C)).
After a successful call to any of the exec(2) functions, any functions previously registered by atexit() are no longer
registered.
On process exit, functions are called in the reverse order of their registration. On object unloading, any functions be<hy>
longing to an unloadable object are called in the reverse order of their registration.
Upon successful completion, the atexit() function returns 0. Otherwise, it returns a non-zero value.
The atexit() function may fail if:
ENOMEM Insufficient storage space is available.
The functions registered by a call to atexit() must return to ensure that all registered functions are called.
There is no way for an application to tell how many functions have already been registered with atexit().
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelSafe
exec(2), dlclose(3C), exit(3C), sysconf(3C), attributes(5)
atomic_add.3c <beginning of page>
atomic_add, atomic_add_8, atomic_add_char, atomic_add_16, atomic_add_short, atomic_add_32, atomic_add_int,
atomic_add_long, atomic_add_64, atomic_add_ptr, atomic_add_8_nv, atomic_add_char_nv, atomic_add_16_nv,
atomic_add_short_nv, atomic_add_32_nv, atomic_add_int_nv, atomic_add_long_nv, atomic_add_64_nv, atom<hy>
ic_add_ptr_nv <-> atomic add operations
#include <atomic.h>
void atomic_add_8(volatile uint8_t *target, int8_t delta);
void atomic_add_char(volatile uchar_t *target, signed char delta);
void atomic_add_16(volatile uint16_t *target, int16_t delta);
void atomic_add_short(volatile ushort_t *target, short delta);
void atomic_add_32(volatile uint32_t *target, int32_t delta);
void atomic_add_int(volatile uint_t *target, int delta);
void atomic_add_long(volatile ulong_t *target, long delta);
void atomic_add_64(volatile uint64_t *target, int64_t delta);
void atomic_add_ptr(volatile void *target, ssize_t delta);
uint8_t atomic_add_8_nv(volatile uint8_t *target, int8_t delta);
uchar_t atomic_add_char_nv(volatile uchar_t *target, signed char delta);
uint16_t atomic_add_16_nv(volatile uint16_t *target, int16_t delta);
ushort_t atomic_add_short_nv(volatile ushort_t *target, shortdelta);
uint32_t atomic_add_32_nv(volatile uint32_t *target, int32_t delta);
uint_t atomic_add_int_nv(volatile uint_t *target, int delta);
ulong_t atomic_add_long_nv(volatile ulong_t *target, long delta);
uint64_t atomic_add_64_nv(volatile uint64_t *target, int64_t delta);
void *atomic_add_ptr_nv(volatile void *target, ssize_t delta);
These functions enable the addition of delta to the value stored in target to occur in an atomic manner.
The *_nv() variants of these functions return the new value of target.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
atomic_and(3C), atomic_bits(3C), atomic_cas(3C), atomic_dec(3C), atomic_inc(3C), atomic_or(3C), atom<hy>
ic_swap(3C), membar_ops(3C), attributes(5), atomic_ops(9F)
The *_nv() variants are substantially more expensive on some platforms than the versions that do not return values.
Do not use them unless you need to know the new value atomically (for example, when decrementing a reference
count and checking whether it went to zero).
atomic_bits.3c <beginning of page>
atomic_bits, atomic_set_long_excl, atomic_clear_long_excl <-> atomic set and clear bit operations
#include <atomic.h>
int atomic_set_long_excl(volatile ulong_t *target, uint_t bit);
int atomic_clear_long_excl(volatile ulong_t *target, uint_t bit);
The atomic_set_long_excl() and atomic_clear_long_excl() functions perform an exclusive atomic bit set or clear
operation on target. The value of bit specifies the number of the bit to be modified within target. Bits are numbered
from zero to one less than the maximum number of bits in a long. If the value of bit falls outside of this range, the
result of the operation is undefined.
The atomic_set_long_excl() and atomic_clear_long_excl() functions return 0 if bit was successfully set or cleared.
They return -1 if bit was already set or cleared.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
atomic_add(3C), atomic_and(3C), atomic_cas(3C), atomic_dec(3C), atomic_inc(3C), atomic_or(3C), atom<hy>
ic_swap(3C), membar_ops(3C), attributes(5), atomic_ops(9F)
atomic_dec.3c <beginning of page>
atomic_dec, atomic_dec_8, atomic_dec_uchar, atomic_dec_16, atomic_dec_ushort, atomic_dec_32, atom<hy>
ic_dec_uint, atomic_dec_ulong, atomic_dec_64, atomic_dec_ptr, atomic_dec_8_nv, atomic_dec_uchar_nv, atom<hy>
ic_dec_16_nv, atomic_dec_ushort_nv, atomic_dec_32_nv, atomic_dec_uint_nv, atomic_dec_ulong_nv, atom<hy>
ic_dec_64_nv, atomic_dec_ptr_nv <-> atomic decrement operations
#include <atomic.h>
void atomic_dec_8(volatile uint8_t *target);
void atomic_dec_uchar(volatile uchar_t *target);
void atomic_dec_16(volatile uint16_t *target);
void atomic_dec_ushort(volatile ushort_t *target);
void atomic_dec_32(volatile uint32_t *target);
void atomic_dec_uint(volatile uint_t *target);
void atomic_dec_ulong(volatile ulong_t *target);
void atomic_dec_64(volatile uint64_t *target);
void atomic_dec_ptr(volatile void *target);
uint8_t atomic_dec_8_nv(volatile uint8_t *target);
uchar_t atomic_dec_uchar_nv(volatile uchar_t *target);
uint16_t atomic_dec_16_nv(volatile uint16_t *target);
ushort_t atomic_dec_ushort_nv(volatile ushort_t *target);
uint32_t atomic_dec_32_nv(volatile uint32_t *target);
uint_t atomic_dec_uint_nv(volatile uint_t *target);
ulong_t atomic_dec_ulong_nv(volatile ulong_t *target);
uint64_t atomic_dec_64_nv(volatile uint64_t *target);
void *atomic_dec_ptr_nv(volatile void *target);
These functions enable the decrementing (by one) of the value stored in target to occur in an atomic manner.
The *_nv() variants of these functions return the new value of target.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
atomic_add(3C), atomic_and(3C), atomic_bits(3C), atomic_cas(3C), atomic_inc(3C), atomic_or(3C), atom<hy>
ic_swap(3C), membar_ops(3C), attributes(5), atomic_ops(9F)
The *_nv() variants are substantially more expensive on some platforms than the versions that do not return values.
Do not use them unless you need to know the new value atomically (for example, when decrementing a reference
count and checking whether it went to zero).
atomic_ops.3c <beginning of page>
atomic_ops <-> atomic operations
#include <atomic.h>
This collection of functions provides atomic memory operations. There are 8 different classes of atomic operations:
atomic_add(3C) These functions provide an atomic addition of a signed value to a variable.
atomic_and(3C) These functions provide an atomic logical 'and' of a value to a variable.
atomic_bits(3C) These functions provide atomic bit setting and clearing within a variable.
atomic_cas(3C) These functions provide an atomic comparison of a value with a variable. If the comparison is
equal, then swap in a new value for the variable, returning the old value of the variable in either case.
atomic_dec(3C) These functions provide an atomic decrement on a variable.
atomic_inc(3C) These functions provide an atomic increment on a variable.
atomic_or(3C) These functions provide an atomic logical 'or' of a value to a variable.
atomic_swap(3C) These functions provide an atomic swap of a value with a variable, returning the old value of the
variable.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
atomic_add(3C), atomic_and(3C), atomic_bits(3C), atomic_cas(3C), atomic_dec(3C), atomic_inc(3C), atom<hy>
ic_or(3C), atomic_swap(3C), membar_ops(3C), attributes(5)
Atomic instructions ensure global visibility of atomically-modified variables on completion. In a relaxed store order
system, this does not guarantee that the visibility of other variables will be synchronized with the completion of the
atomic instruction. If such synchronization is required, memory barrier instructions must be used. See mem<hy>
bar_ops(3C).
Atomic instructions can be expensive since they require synchronization to occur at a hardware level. This means
they should be used with care to ensure that forcing hardware level synchronization occurs a minimum number of
times. For example, if you have several variables that need to be incremented as a group, and each needs to be done
atomically, then do so with a mutex lock protecting all of them being incremented rather than using the atom<hy>
ic_inc(3C) operation on each of them.
atomic_swap.3c <beginning of page>
atomic_swap, atomic_swap_8, atomic_swap_uchar, atomic_swap_16, atomic_swap_ushort, atomic_swap_32, atom<hy>
ic_swap_uint, atomic_swap_ulong, atomic_swap_64, atomic_swap_ptr <-> atomic swap operations
#include <atomic.h>
uint8_t atomic_swap_8(volatile uint8_t *target, uint8_t newval);
uchar_t atomic_swap_uchar(volatile uchar_t *target, uchar_t newval);
uint16_t atomic_swap_16(volatile uint16_t *target, uint16_t newval);
ushort_t atomic_swap_ushort(volatile ushort_t *target, ushort_t newval);
uint32_t atomic_swap_32(volatile uint32_t *target, uint32_t newval);
uint_t atomic_swap_uint(volatile uint_t *target, uint_t newval);
ulong_t atomic_swap_ulong(volatile ulong_t *target, ulong_t newval);
uint64_t atomic_swap_64(volatile uint64_t *target, uint64_t newval);
void *atomic_swap_ptr(volatile void *target, void *newval);
These functions enable a swap operation to occur atomically. The value stored in target is replaced with newval. The
old value is returned by the function.
These functions return the old of *target.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
atomic_add(3C), atomic_and(3C), atomic_bits(3C), atomic_dec(3C), atomic_inc(3C), atomic_or(3C), atom<hy>
ic_cas(3C), membar_ops(3C), attributes(5), atomic_ops(9F)
attach.9e <beginning of page>
attach <-> Attach a device to the system, or resume it
#include <sys/ddi.h>
#include <sys/sunddi.h>
int prefixattach(dev_info_t *dip, ddi_attach_cmd_t cmd);
Solaris DDI specific (Solaris DDI)
dip A pointer to the device's dev_info structure.
cmd Attach type. Possible values are DDI_ATTACH and DDI_RESUME. Other values are reserved. The driver
must return DDI_FAILURE if reserved values are passed to it.
The attach(9E) function is the device-specific initialization entry point. This entry point is required and must be
written.
The DDI_ATTACH command must be provided in the attach(9E) entry point. DDI_ATTACH is used to initialize a
given device instance. When attach(9E) is called with cmd set to DDI_ATTACH, all normal kernel services (such
as kmem_alloc(9F)) are available for use by the driver. Device interrupts are not blocked when attaching a device to
the system.
The attach(9E) function is called once for each instance of the device on the system with cmd set to DDI_AT<hy>
TACH. Until attach(9E) succeeds, the only driver entry point which may be called is getinfo(9E). See the Writing
Device Drivers for more information. The instance number may be obtained using ddi_get_instance(9F).
At attach time, all components of a power-manageable device are assumed to be at unknown levels. Before using the
device, the driver needs to bring the required component(s) to a known power level. The pm_raise_power(9F) func<hy>
tion can be used to set the power level of a component. This function must not be called before data structures refer<hy>
enced in power(9E) have been initialized.
The attach() function may be called with cmd set to DDI_RESUME after detach(9E) has been successfully called
with cmd set to DDI_SUSPEND.
When called with cmd set to DDI_RESUME, attach() must restore the hardware state of a device (power may have
been removed from the device), allow pending requests to continue, and service new requests. In this case, the driver
must not make any assumptions about the state of the hardware, but must restore the state of the device except for
the power level of components.
If the device driver uses the automatic device Power Management interfaces (driver exports the pm-compo<hy>
nents(9P) property), the Power Management framework sets its notion of the power level of each component of a
device to unknown while processing a DDI_RESUME command.
The driver can deal with components during DDI_RESUME in one of the following ways: 1. If the driver can de<hy>
termine the power level of the component without having to power it up (for example, by calling ddi_peek(9F) or
some other device-specific method) then it should notify the power level to the framework by calling pm_pow<hy>
er_has_changed(9F). 2. The driver must also set its own notion of the power level of the component to unknown.
The system will consider the component idle or busy based on the most recent call to pm_idle_component(9F) or
pm_busy_component(9F) for that component. If the component is idle for sufficient time, the framework will call
into the driver's power(9E) entry point to turn the component off. If the driver needs to access the device, then it
must call pm_raise_power(9F) to bring the component up to the level needed for the device access to succeed. The
driver must honor any request to set the power level of the component, since it cannot make any assumption about
what power level the component has (or it should have called pm_power_has_changed(9F) as outlined above). As
a special case of this, the driver may bring the component to a known state because it wants to perform an operation
on the device as part of its DDI_RESUME processing (such as loading firmware so that it can detect hot-plug
events).
The attach() function returns:
DDI_SUCCESS Successful completion
<beginning of page>
DDI_FAILURE Operation failed
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed
cpr(7), pm(7D), pm(9P), pm-components(9P), detach(9E), getinfo(9E), identify(9E), open(9E), power(9E),
probe(9E), ddi_add_intr(9F), ddi_create_minor_node(9F), ddi_get_instance(9F), ddi_map_regs(9F),
kmem_alloc(9F), pm_raise_power(9F)
Writing Device Drivers
attropen.3c <beginning of page>
attropen <-> open a file
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int attropen(const char *path, const char *attrpath, int oflag,
 /* mode_t mode */...);
The attropen() function is similar to the open(2) function except that it takes a second path argument, attrpath, that
identifies an extended attribute file associated with the first path argument. This function returns a file descriptor for
the extended attribute rather than the file named by the initial argument.
The O_XATTR flag is set by default for attropen() and the attrpath argument is always interpreted as a reference to
an extended attribute. Extended attributes must be referenced with a relative path; providing an absolute path results
in a normal file reference.
Refer to open(2).
Refer to open(2).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyEvolving _ MT-LevelSafe
open(2), attributes(5), fsattr(5)
audio.7d <beginning of page>
audio <-> common audio framework
The audio driver provides common support routines for audio devices in Solaris.
The audio framework supports multiple personalities, allowing for devices to be accessed with different program<hy>
ming interfaces.
The audio framework also provides a number of facilities, such as mixing of audio streams, and data format and
sample rate conversion.
The audio framework provides a software mixing engine (audio mixer) for all audio devices, allowing more than one
process to play or record audio at the same time.
The audio mixer supports multi-stream Codecs. These devices have DSP engines that provide sample rate conver<hy>
sion, hardware mixing, and other features. The use of such hardware features is opaque to applications.
It is not possible to disable the mixing function. Applications must not assume that they have exclusive access to the
audio device.
Digital audio data represents a quantized approximation of an analog audio signal waveform. In the simplest case,
these quantized numbers represent the amplitude of the input waveform at particular sampling intervals. To achieve
the best approximation of an input signal, the highest possible sampling frequency and precision should be used.
However, increased accuracy comes at a cost of increased data storage requirements. For instance, one minute of
monaural audio recorded in u-Law format (pronounced mew-law) at 8 KHz requires nearly 0.5 megabytes of stor<hy>
age, while the standard Compact Disc audio format (stereo 16-bit linear PCM data sampled at 44.1 KHz) requires
approximately 10 megabytes per minute.
An audio data format is characterized in the audio driver by four parameters: sample Rate, encoding, precision, and
channels. Refer to the device-specific manual pages for a list of the audio formats that each device supports. In addi<hy>
tion to the formats that the audio device supports directly, other formats provide higher data compression. Applica<hy>
tions can convert audio data to and from these formats when playing or recording.
Sample rate is a number that represents the sampling frequency (in samples per second) of the audio data.
The audio mixer always configures the hardware for the highest possible sample rate for both play and record. This
ensures that none of the audio streams require compute-intensive low pass filtering. The result is that high sample
rate audio streams are not degraded by filtering.
Sample rate conversion can be a compute-intensive operation, dependingon the number of channels and a device's
sample rate. For example, an 8KHz signal can be easily converted to 48KHz, requiring a low cost up sampling by 6.
However, converting from 44.1KHz to 48KHz is computer intensive because it must be up sampled by 160 and then
down sampled by 147. This is only done using integer multipliers.
Applications can greatly reduce the impact of sample rate conversion by carefully picking the sample rate. Applica<hy>
tions should always use the highest sample rate the device supports. An application can also do its own sample rate
conversion (to take advantage of floating point and accelerated instructions) or use small integers for up and down
sampling.
All modern audio devices run at 48 kHz or a multiple thereof, hence just using 48 kHz can be a reasonable compro<hy>
mise if the application is not prepared to select higher sample rates.
An encoding parameter specifies the audiodata representation. u-Law encoding corresponds to CCITT G.711, and is
the standard for voice data used by telephone companies in the United States, Canada, and Japan. A-Law encoding
is also part of CCITT G.711 and is the standard encoding for telephony elsewhere in the world. A-Law and u-Law
audio data are sampled at a rate of 8000 samples per second with 12-bit precision, with the data compressed to 8-bit
samples. The resulting audio data quality is equivalent to that of stan dard analog telephone service.
Linear Pulse Code Modulation (PCM) is an uncompressed, signed audio format in which sample values are directly
proportional to audio signal voltages. Each sample is a 2's complement number that represents a positive or negative
amplitude.
Precision indicates the number of bits used to store each audio sample. For instance, u-Law and A-Law data are
stored with 8-bit precision. PCM data can be stored at various precisions, though 16-bit is the most common.
Multiple channels of audio can be interleaved at sample boundaries. A sample frame consists of a single sample
from each active channel. For example, a sample frame of stereo 16-bit PCM data consists of 2 16-bit samples, cor<hy>
<beginning of page>
responding to the left and right channel data. The audio mixer sets the hardware to the maximum number of chan<hy>
nels supported. If a mono signal is played or recorded, it is mixed on the first two (usually the left and right) channel
only. Silence is mixed on the remaining channels.
The audio mixer supports the following audio formats:
 Encoding Precision Channels
 Signed Linear PCM 32-bit Mono or Stereo
 Signed Linear PCM 16-bit Mono or Stereo
 Signed Linear PCM 8-bit Mono or Stereo
 u-Law 8-bit Mono or Stereo
 A-Law 8-bit Mono or Stereo
The audio mixer converts all audio streams to 24-bit Linear PCM before mixing. After mixing, conversion is made
to the best possible Codec format. The conversion process is not compute intensive and audio applications can
choose the encoding format that best meets their needs.
The mixer discards the low order 8 bits of 32-bit Signed Linear PCM in order to perform mixing. (This is done to al<hy>
low for possible overflows to fit into 32-bits when mixing multiple streams together.) Hence, the maximum effective
precision is 24-bits.
/kernel/drv/audio 32-bit kernel driver module
/kernel/drv/amd64/audio 64-bit x86 kernel driver module
/kernel/drv/sparcv9/audio 64-bit SPARC kernel driver module
/kernel/drv/audio.conf audio configuration file
See attributes(5) for a description of the following attributes:
tab() box; lw(2.75i) |lw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureSPARC,
x86 _ AvailabilitySUNWaudd _ Interface StabilityUncommitted
ioctl(2), attributes(5), audio(7I), dsp(7I)
audioconvert.1 <beginning of page>
audioconvert <-> convert audio file formats
audioconvert [-pF] [-f outfmt] [-o outfile]
 [ [-i infmt] [file]...] ...
audioconvert converts audio data between a set of supported audio encodings and file formats. It can be used to
compress and decompress audio data, to add audio file headers to raw audio data files, and to convert between stan<hy>
dard data encodings, such as -law and linear PCM.
If no filenames are present, audioconvert reads the data from the standard input stream and writes an audio file to
the standard output. Otherwise, input files are processed in order, concatenated, and written to the output file.
Input files are expected to contain audio file headers that identify the audio data format. If the audio data does not
contain a recognizable header, the format must be specified with the -i option, using the rate, encoding, and chan<hy>
nels keywords to identify the input data format.
The output file format is derived by updating the format of the first input file with the format options in the -f specifi<hy>
cation. If -p is not specified, all subsequent input files are converted to this resulting format and concatenated togeth<hy>
er. The output file will contain an audio file header, unless format=raw is specified in the output format options.
Input files may be converted in place by using the -p option. When -p is in effect, the format of each input file is
modified according to the -f option to determine the output format. The existing files are then overwritten with the
converted data.
The file(1) command decodes and prints the audio data format of Sun audio files.
The following options are supported:
-p In Place: The input files are individually converted to the format specified by the -f option and rewritten. If a tar<hy>
get file is a symbolic link, the underlying file will be rewritten. The -o option may not be specified with -p.
-F Force: This option forces audioconvert to ignore any file header for input files whose format is specified by the -i
option. If -F is not specified, audioconvert ignores the -i option for input files that contain valid audio file headers.
-f outfmt Output Format: This option is used to specify the file format and data encoding of the output file. Defaults
for unspecified fields are derived from the input file format. Valid keywords and values are listed in the next section.
-o outfile Output File: All input files are concatenated, converted to the output format, and written to the named out<hy>
put file. If -o and -p are not specified, the concatenated output is written to the standard output. The -p option may
not be specified with -o.
-i infmt Input Format: This option is used to specify the data encoding of raw input files. Ordinarily, the input data
format is derived from the audio file header. This option is required when converting audio data that is not preceded
by a valid audio file header. If -i is specified for an input file that contains an audio file header, the input format
string will be ignored, unless -F is present. The format specification syntax is the same as the -f output file format.
Multiple input formats may be specified. An input format describes all input files following that specification, until a
new input format is specified.
file File Specification: The named audio files are concatenated, converted to the output format, and written out. If no
file name is present, or if the special file name `<mi>' is specified, audio data is read from the standard input.
-? Help: Prints a command line usage message.
The syntax for the input and output format specification is:
keyword=value[,keyword=value ...]
with no intervening whitespace. Unambiguous values may be used without the preceding keyword=.
<beginning of page>
rate The audio sampling rate is specified in samples per second. If a number is followed by the letter k, it is multi<hy>
plied by 1000 (for example, 44.1k = 44100). Standard of the commonly used sample rates are: 8k, 16k, 32k, 44.1k,
and 48k.
channels The number of interleaved channels is specified as an integer. The words mono and stereo may also be
used to specify one and two channel data, respectively.
encoding This option specifies the digital audio data representation. Encodings determine precision implicitly (ulaw
implies 8-bit precision) or explicitly as part of the name (for example, linear16). Valid encoding values are:
ulaw CCITT G.711 -law encoding. This is an 8-bit format primarily used for telephone quality speech.
alaw CCITT G.711 A-law encoding. This is an 8-bit format primarily used for telephone quality speech in Europe.
linear8,
linear16,
linear32 Linear Pulse Code Modulation (PCM) encoding. The name identifies the number of bits of precision. lin<hy>
ear16 is typically used for high quality audio data.
pcm Same as linear16.
g721 CCITT G.721 compression format. This encoding uses Adaptive Delta Pulse Code Modulation (ADPCM)
with 4-bit precision. It is primarily used for compressing -law voice data (achieving a 2:1 compression ratio).
g723 CCITT G.723 compression format. This encoding uses Adaptive Delta Pulse Code Modulation (ADPCM)
with 3-bit precision. It is primarily used for compressing -law voice data (achieving an 8:3 compression ratio). The
audio quality is similar to G.721, but may result in lower quality when used for non-speech data.
The following encoding values are also accepted as shorthand to set the sample rate, channels, and encoding:
voice Equivalent to encoding=ulaw,rate=8k,channels=mono.
cd Equivalent to encoding=linear16,rate=44.1k,channels=stereo.
dat Equivalent to encoding=linear16,rate=48k,channels=stereo.
format This option specifies the audio file format. Valid formats are:
sun Sun compatible file format (the default).
raw Use this format when reading or writing raw audio data (with no audio header), or in conjunction with an off<hy>
set to import a foreign audio file format.
offset (-i only) Specifies a byte offset to locate the start of the audio data. This option may be used to import audio
data that contains an unrecognized file header.
See largefile(5) for the description of the behavior of audioconvert when encountering files greater than or equal to
2 Gbyte ( 2^31 bytes). Example 1 Recording and compressing voice data before storing it
Record voice data and compress it before storing it to a file:
<beginning of page>
 example% audiorecord | audioconvert -f g721 > mydata.au
Example 2 Concatenating two audio files
Concatenate two Sun format audio files, regardless of their data format, and output an 8-bit ulaw, 16 kHz, mono file:
 example% audioconvert -f ulaw,rate=16k,mono -o outfile.au infile1 infile2
Example 3 Converting a directory to Sun format
Convert a directory containing raw voice data files, in place, to Sun format (adds a file header to each file):
 example% audioconvert -p -i voice -f sun *.au
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC, x86 _ AvailabilitySUNWauda _ Interface StabilityEvolving
audioplay(1), audiorecord(1), file(1), attributes(5), largefile(5)
The algorithm used for converting multi-channel data to mono is implemented by simply summing the channels to<hy>
gether. If the input data is perfectly in phase (as would be the case if a mono file is converted to stereo and back to
mono), the resulting data may contain some distortion.
audioixp.7d <beginning of page>
audioixp <-> ATI IXP400 south bridge audio digital controller interface
The audioixp device uses the IXP400 south bridge audio digital controller and a AC-97 Codec to implement the au<hy>
dio device interface.
The audioixp device provides support for the internal speaker, headphone, line out, line in, and microphone.
/kernel/drv/audioixp.conf Driver configuration file
/kernel/drv/audioixp 32-bit kernel driver module
/kernel/drv/amd64/audioixp 64-bit kernel driver module
See attributes(5) for a descriptions of the following attributes:
tab() box; cw(1.83i) |cw(3.67i) lw(1.83i) |lw(3.67i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitecturePC-
based system _ AvailabilitySUNWadixp _ Stability levelUncommitted
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
ATI IXP400 South Bridge Data Sheet
In addition to being logged, the following messages may appear on the system console:
play-interrupts too low
record-interrupts too low The interrupt rate in audioixp.conf is set too low. It has been reset to the rate specified in
the message. Update audioixp.conf to a higher interrupt rate.
play-interrupts too high
record-interrupts too high The interrupt rate set in audioixp.conf is set too high. It has been reset to the rate speci<hy>
fied in the message. Update audioixp.conf to a lower interrupt rate.
audioplay.1 <beginning of page>
audioplay <-> play audio files
audioplay [-iV] [-v vol] [-d dev] [file]...
The audioplay utility copies the named audio files (or the standard input if no filenames are present) to the audio de<hy>
vice. If no input file is specified and standard input is a tty, the program exits with an error message.
The input files must contain a valid audio file header. The encoding information in this header is matched against the
capabilities of the audio device and, if the data formats are incompatible, an error message is printed and the file is
skipped. Compressed ADPCM (G.721) monaural audio data is automatically uncompressed before playing.
Minor deviations in sampling frequency (that is, less than 1%) are ordinarily ignored. This allows, for instance, data
sampled at 8012 Hz to be played on an audio device that only supports 8000 Hz. If the -V option is present, such de<hy>
viations are flagged with warning messages.
The following options are supported:
-d dev Device: The dev argument specifies an alternate audio device to which output should be directed. If the -d op<hy>
tion is not specified, the AUDIODEV environment variable is consulted (see below). Otherwise, /dev/audio is used
as the default audio device.
-i Immediate: If the audio device is unavailable (that is, another process currently has write access), audioplay ordi<hy>
narily waits until it can obtain access to the device. When the -i option is present, audioplay prints an error message
and exits immediately if the device is busy.
-v vol Volume: The output volume is set to the specified value before playing begins, and is reset to its previous level
when audioplay exits. The vol argument is an integer value between 0 and 100, inclusive. If this argument is not
specified, the output volume remains at the level most recently set by any process.
-V Verbose: Prints messages on the standard error when waiting for access to the audio device or when sample rate
deviations are detected.
<mi>\? Help: Prints a command line usage message.
file File Specification: Audio files named on the command line are played sequentially. If no filenames are present,
the standard input stream (if it is not a tty) is played (it, too, must contain an audio file header). The special filename
<mi> can be used to read the standard input stream instead of a file. If a relative path name is supplied, the AU<hy>
DIOPATH environment variable is consulted (see below).
See largefile(5) for the description of the behavior of audioplay when encountering files greater than or equal to 2
Gbyte ( 2^31 bytes).
AUDIODEV The full path name of the audio device to write to, if no -d argument is supplied. If the AUDIODEV
variable is not set, /dev/audio is used.
AUDIOPATH A colon-separated list of directories in which to search for audio files whose names are given by rela<hy>
tive pathnames. The current directory (.) can be specified explicitly in the search path. If the AUDIOPATH variable
is not set, only the current directory is searched.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC, x86 _ AvailabilitySUNWauda _ Interface StabilityCommitted
audioconvert(1), audiorecord(1), mixerctl(1), attributes(5), largefile(5), audio(7I)
<beginning of page>
audioplay currently supports a limited set of audio format conversions. If the audio file is not in a format supported
by the audio device, it must first be converted. For example, to convert to voice format on the fly, use the command:
 example% audioconvert -f voice myfile | audioplay
The format conversion is not always be able to keep up with the audio output. If this is the case, you should convert
to a temporary file before playing the data.
audiots.7d <beginning of page>
audiots <-> Acer Laboratories Inc. M5451 audio processor interface
The audiots device uses the ALI M5451 audio processor and an AC-97 Codec to implement the audio device inter<hy>
face.
The audiots device provides support for the internal speaker, headphone, line out, line in, and microphone.
/kernel/drv/sparcv9/audiots
64-bit audiots driver
/kernel/drv/audiots.conf
audiots driver configuration file
See attributes(5) for a descriptions of the following attributes:
tab() box; cw(1.83i) |cw(3.67i) lw(1.83i) |lw(3.67i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC _ AvailabilitySUNWaudd _ Stability levelUncommitted
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
Acer Laboratories Inc. M5451 PCI Audio Processor Technical Specification
In addition to being logged, the following messages can appear on the system console:
play-interrupts too low
record-interrupts too low The interrupt rate in audiots.conf is set too low. It has been reset to the rate specified in
the message. Update audiots.conf to a higher interrupt rate.
play-interrupts too high
record-interrupts too high The interrupt rate set in audiots.conf is set too high. It has been reset to the rate speci<hy>
fied in the message. Update audiots.conf to a lower interrupt rate.
audit.2 <beginning of page>
audit <-> write a record to the audit log
cc [ flag ... ] file ... -lbsm -lsocket -lnsl [ library... ]
#include <sys/param.h>
#include <bsm/libbsm.h>
int audit(caddr_t record, int length);
The audit() function queues a record for writing to the system audit log. The data pointed to by record is queued for
the log after a minimal consistency check, with the length parameter specifying the size of the record in bytes. The
data should be a well-formed audit record as described by audit.log(4).
The kernel validates the record header token type and length, and sets the time stamp value before writing the
record to the audit log. The kernel does not do any preselection for user-level generated events. If the audit policy is
set to include sequence or trailer tokens, the kernel will append them to the record.
Upon successful completion, 0 is returned. Otherwise, <mi>1 is returned and errno is set to indicate the error.
The audit() function will fail if:
E2BIG The record length is greater than the maximum allowed record length.
EFAULT The record argument points outside the process's allocated address space.
EINVAL The header token in the record is invalid.
ENOTSUP Solaris Audit is not defined for this system.
EPERM The {PRIV_PROC_AUDIT} privilege is not asserted in the effective set of the calling process.
Only privileged processes can successfully execute this call.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
bsmconv(1M), audit(1M), auditd(1M), svcadm(1M), auditon(2), getaudit(2), audit.log(4), attributes(5), privi<hy>
leges(5)
The functionality described in this man page is available only if the Solaris Auditing has been enabled and the audit
daemon auditd(1M) has not been disabled by audit(1M) or svcadm(1M). See bsmconv(1M) for more information.
audit_control.4 <beginning of page>
audit_control <-> control information for system audit daemon
/etc/security/audit_control
The audit_control file contains audit control information used by auditd(1M). Each line consists of a title and a
string, separated by a colon. There are no restrictions on the order of lines in the file, although some lines must ap<hy>
pear only once. A line beginning with `#' is a comment. A line can be continued with the use of the backslash (\)
convention. (See EXAMPLES.)
Directory definition lines list the directories to be used when creating audit files, in the order in which they are to be
used. The format of a directory line is:
dir:directory-name
directory-name is where the audit files will be created. Any valid writable directory can be specified.
The following configuration is recommended:
/etc/security/audit/server/files
where server is the name of a central machine, since audit files belonging to different servers are usually stored in
separate subdirectories of a single audit directory. The naming convention normally has server be a directory on a
server machine, and all clients mount /etc/security/audit/server at the same location in their local file systems. If the
same server exports several different file systems for auditing, their server names will, of course, be different.
There are several other ways for audit data to be arranged: some sites may have needs more in line with storing each
host's audit data in separate subdirectories. The audit structure used will depend on each individual site.
The audit threshold line specifies the percentage of free space that must be present in the file system containing the
current audit file. The format of the threshold line is:
minfree:percentage
where percentage is indicates the amount of free space required. If free space falls below this threshold, the audit
daemon auditd(1M) invokes the shell script audit_warn(1M). If no threshold is specified, the default is 0%.
The plugin definition line selects a plugin to be loaded by the audit daemon for processing audit records.
The format of a plugin line is:
 plugin: keyword1=value1;keyword2=value2;
The following keywords are defined:
name The value is the pathname of the plugin. This specification is required.
qsize The value is the maximum number of records to queue for audit data sent to the plugin. If omitted, the current
hiwater mark (see the -getqctrl of auditconfig(1M)) is used. When this maximum is reached, auditd will either
block or discard data, depending on the audit policy cnt. See auditconfig(1M).
p_* A keyword with the prefix p_ is passed to the plugin defined by the value associated with the name attribute.
These attributes are defined for each plugin. By convention, if the value associated with a plugin attribute is a list,
the list items are separated with commas.
If pathname is a relative path (it does not start with /) the library path will be taken as relative to /usr/lib/securi<hy>
ty/$ISA. The $ISA token is replaced by an implementation-defined directory name that defines the path relative to
the auditd(1M) instruction set architecture.
See audit_syslog(5) for the attributes expected for plugin: name=audit_syslog.so.
No plugin specifier is required for generation of a binary audit log. However, to set a queue size of other than the de<hy>
<beginning of page>
fault, a plugin line with name=audit_binfile.so can be used as described in audit_binfile(5).
You must specify one or more plugins. (In the case of audit_binfile.so, use of dir: or plugin: suffices.)
The audit flags line specifies the default system audit value. This value is combined with the user audit value read
from audit_user(4) to form a user's process preselection mask.
The algorithm for obtaining the process preselection mask is as follows: the audit flags from the flags: line in the au<hy>
dit_control file are added to the flags from the always-audit field in the user's entry in the audit_user file. The flags
from the never-audit field from the user's entry in the audit_user file are then subtracted from the total:
 user's process preselection mask =
  (flags: line + always audit flags) - never audit flags
The format of a flags line is:
flags:audit-flags
where audit-flags specifies which event classes are to be audited. The character string representation of audit-flags
contains a series of flag names, each one identifying a single audit class, separated by commas. A name preceded by
`<mi>' means that the class should be audited for failure only; successful attempts are not audited. A name preceded by
`+' means that the class should be audited for success only; failing attempts are not audited. Without a prefix, the
name indicates that the class is to be audited for both successes and failures. The special string all indicates that all
events should be audited; <mi>all indicates that all failed attempts are to be audited, and +all all successful attempts.
The prefixes ^, ^<mi>, and ^+ turn off flags specified earlier in the string (^<mi> and ^+ for failing and successful attempts, ^
for both). They are typically used to reset flags.
The non-attributable flags line is similar to the flags line, but this one contain the audit flags that define what classes
of events are audited when an action cannot be attributed to a specific user. The format of a naflags line is:
naflags:audit-flags
The flags are separated by commas, with no spaces. See audit_class(4) for a list of the predefined audit classes.
Note that the classes are configurable as also described in audit_class(4).
A line can be continued by appending a backslash (\). Example 1 Sample audit_control File for Specific Host
The following is a sample /etc/security/audit_control file for the machine eggplant.
The file's contents identify server jedgar with two file systems normally used for audit data, another server, global,
used only when jedgar fills up or breaks, and specifies that the warning script is run when the file systems are 80%
filled. It also specifies that all logins, administrative operations are to be audited, whether or not they succeed. All
failures except failures to access object attributes are to be audited.
 dir: /etc/security/jedgar/eggplant
 dir: /etc/security/jedgar.aux/eggplant
 #
 # Last-ditch audit file system when jedgar fills up.
 #
 dir: /etc/security/global/eggplant
 minfree: 20
 flags: lo,ad,-all,^-fm
 naflags: lo,ad
Example 2 Sample audit_control File for syslog and Local Storage
Shown below is a sample /etc/security/audit_control file for syslog and local storage. For the binary log, the output
is all lo and ad records, all failures of class fm and any classes specified by means of audit_user(4). For syslog out<hy>
put, all lo records are output, only failure ad records are output, and no fm records are output. The specification for
the plugin is given in two lines.
<beginning of page>
 dir: /etc/security/jedgar/eggplant
 dir: /etc/security/jedgar.aux/eggplant
 #
 # Last-ditch audit file system when jedgar fills up.
 #
 dir: /etc/security/global/eggplant
 minfree: 20
 flags: lo,ad,-fm
 naflags: lo,ad
 plugin: name=audit_syslog.so;p_flags=lo,+ad;\
 qsize=512
Example 3 Overriding the Default Queue Size
Shown below is a sample /etc/security/audit_control file that overrides the default queue size for binary audit log
file generation.
 dir: /etc/security/jedgar/eggplant
 dir: /etc/security/jedgar.aux/eggplant
 #
 # Last-ditch audit file system when jedgar fills up.
 #
 dir: /etc/security/global/eggplant
 minfree: 20
 flags: lo,ad,-fm
 naflags: lo,ad
 plugin: name=audit_binfile.so; qsize=256
/etc/security/audit_control
/etc/security/audit_warn
/etc/security/audit/*/*/*
/etc/security/audit_user
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability
Obsolete Committed
audit(1M), audit_warn(1M), auditd(1M), bsmconv(1M), audit(2), getfauditflags(3BSM), audit.log(4), au<hy>
dit_class(4), audit_user(4), attributes(5), audit_binfile(5), audit_syslog(5)
Part VII, Solaris Auditing, in System Administration Guide: Security Services
Use of the plugin configuration line to include audit_syslog.so requires that /etc/syslog.conf be configured for audit
data. See audit_syslog(5) for more details.
Configuration changes do not affect audit sessions that are currently running, as the changes do not modify a
process's preselection mask. To change the preselection mask on a running process, use the -setpmask option of the
auditconfig command (see auditconfig(1M)). If the user logs out and logs back in, the new configuration changes
will be reflected in the next audit session.
This file is Obsolete and may be removed and replaced with equivalent functionality in a future release of Solaris.
auditon.2 <beginning of page>
auditon <-> manipulate auditing
cc [ flag... ] file... -lbsm -lsocket -lnsl [ library... ]
#include <sys/param.h>
#include <bsm/libbsm.h>
int auditon(int cmd, caddr_t data, int length);
The auditon() function performs various audit subsystem control operations. The cmd argument designates the par<hy>
ticular audit control command. The data argument is a pointer to command-specific data. The length argument is the
length in bytes of the command-specific data.
The following commands are supported:
A_GETCOND
Return the system audit on/off/disabled condition in the integer pointed to by data. The following values can be re<hy>
turned:
AUC_AUDITING Auditing has been turned on.
AUC_DISABLED Auditing system has not been enabled.
AUC_NOAUDIT Auditing has been turned off.
AUC_NOSPACE Auditing has blocked due to lack of space in audit partition.
A_SETCOND
Set the system's audit on/off condition to the value in the integer pointed to by data. The Solaris Audit subsystem
must be enabled by bsmconv(1M) before auditing can be turned on. The following audit states can be set:
AUC_AUDITING Turns on audit record generation.
AUC_NOAUDIT Turns off audit record generation.
A_GETCLASS
Return the event to class mapping for the designated audit event. The data argument points to the au_evclass_map
structure containing the event number. The preselection class mask is returned in the same structure.
A_SETCLASS
Set the event class preselection mask for the designated audit event. The data argument points to the au_ev<hy>
class_map structure containing the event number and class mask.
A_GETKMASK
Return the kernel preselection mask in the au_mask structure pointed to by data. This is the mask used to preselect
non-attributable audit events.
A_SETKMASK
Set the kernel preselection mask. The data argument points to the au_mask structure containing the class mask.
This is the mask used to preselect non-attributable audit events.
<beginning of page>
A_GETPINFO
Return the audit ID, preselection mask, terminal ID and audit session ID of the specified process in the auditpinfo
structure pointed to by data.
Note that A_GETPINFO can fail if the termial ID contains a network address longer than 32 bits. In this case, the
A_GETPINFO_ADDR command should be used.
A_GETPINFO_ADDR
Returns the audit ID, preselection mask, terminal ID and audit session ID of the specified process in the auditpin<hy>
fo_addr structure pointed to by data.
A_SETPMASK
Set the preselection mask of the specified process. The data argument points to the auditpinfo structure containing
the process ID and the preselection mask. The other fields of the structure are ignored and should be set to NULL.
A_SETUMASK
Set the preselection mask for all processes with the specified audit ID. The data argument points to the auditinfo
structure containing the audit ID and the preselection mask. The other fields of the structure are ignored and should
be set to NULL.
A_SETSMASK
Set the preselection mask for all processes with the specified audit session ID. The data argument points to the au<hy>
ditinfo structure containing the audit session ID and the preselection mask. The other fields of the structure are ig<hy>
nored and should be set to NULL.
A_GETQCTRL
Return the kernel audit queue control parameters. These control the high and low water marks of the number of audit
records allowed in the audit queue. The high water mark is the maximum allowed number of undelivered audit
records. The low water mark determines when threads blocked on the queue are wakened. Another parameter con<hy>
trols the size of the data buffer used to write data to the audit trail. There is also a parameter that specifies a maxi<hy>
mum delay before data is attempted to be written to the audit trail. The audit queue parameters are returned in the
au_qctrl structure pointed to by data.
A_SETQCTRL
Set the kernel audit queue control parameters as described above in the A_GETQCTRL command. The data argu<hy>
ment points to the au_qctrl structure containing the audit queue control parameters. The default and maximum val<hy>
ues 'A/B' for the audit queue control parameters are:
high water 100/10000 (audit records)
low water 10/1024 (audit records)
output buffer size 1024/1048576 (bytes)
delay 20/20000 (hundredths second)
A_GETCWD
Return the current working directory as kept by the audit subsystem. This is a path anchored on the real root, rather
than on the active root. The data argument points to a buffer into which the path is copied. The length argument is
the length of the buffer.
<beginning of page>
A_GETCAR
Return the current active root as kept by the audit subsystem. This path can be used to anchor an absolute path for a
path token generated by an application. The data argument points to a buffer into which the path is copied. The
length argument is the length of the buffer.
A_GETSTAT
Return the system audit statistics in the audit_stat structure pointed to by data.
A_SETSTAT
Reset system audit statistics values. The kernel statistics value is reset if the corresponding field in the statistics
structure pointed to by the data argument is CLEAR_VAL. Otherwise, the value is not changed.
A_GETPOLICY
Return the audit policy flags in the integer pointed to by data.
A_SETPOLICY
Set the audit policy flags to the values in the integer pointed to by data. The following policy flags are recognized:
AUDIT_CNT
Do not suspend processes when audit storage is full or inaccessible. The default action is to suspend processes until
storage becomes available.
AUDIT_AHLT
Halt the machine when a non-attributable audit record can not be delivered. The default action is to count the num<hy>
ber of events that could not be recorded.
AUDIT_ARGV
Include in the audit record the argument list for a member of the exec(2) family of functions. The default action is
not to include this information.
AUDIT_ARGE
Include the environment variables for the execv(2) function in the audit record. The default action is not to include
this information.
AUDIT_SEQ
Add a sequence token to each audit record. The default action is not to include it.
AUDIT_TRAIL
Append a trailer token to each audit record. The default action is not to include it.
AUDIT_GROUP
Include the supplementary groups list in audit records. The default action is not to include it.
AUDIT_PATH
Include secondary paths in audit records. Examples of secondary paths are dynamically loaded shared library mod<hy>
ules and the command shell path for executable scripts. The default action is to include only the primary path from
the system call.
<beginning of page>
AUDIT_WINDATA_DOWN
Include in an audit record any downgraded data moved between windows. This policy is available only if the system
is configured with Trusted Extensions. By default, this information is not included.
AUDIT_WINDATA_UP
Include in an audit record any upgraded data moved between windows. This policy is available only if the system is
configured with Trusted Extensions. By default, this information is not included.
AUDIT_PERZONE
Enable auditing for each local zone. If not set, audit records from all zones are collected in a single log accessible in
the global zone and certain auditconfig(1M) operations are disallowed. This policy can be set only from the global
zone.
AUDIT_ZONENAME
Generate a zone ID token with each audit record.
Upon successful completion, auditon() returns 0. Otherwise, <mi>1 is returned and errno is set to indicate the error.
The auditon() function will fail if:
E2BIG The length field for the command was too small to hold the returned value.
EFAULT The copy of data to/from the kernel failed.
EINVAL One of the arguments was illegal, Solaris Audit has not been installed, or the operation is not valid from a
local zone.
EPERM The {PRIV_SYS_AUDIT} privilege is not asserted in the effective set of the calling process.
Neither the {PRIV_PROC_AUDIT} nor the {PRIV_SYS_AUDIT} privilege is asserted in the effective set of the
calling process and the command is one of A_GETCAR, A_GETCLASS, A_GETCOND, A_GETCWD,
A_GETPINFO, A_GETPOLICY.
The auditon() function can be invoked only by processes with appropriate privileges.
The use of auditon() to change system audit state is permitted only in the global zone. From any other zone audi<hy>
ton() returns <mi>1 with errno set to EPERM. The following auditon() commands are permitted only in the global
zone: A_SETCOND, A_SETCLASS, A_SETKMASK, A_SETQCTRL, A_SETSTAT, A_SETFSIZE, and
A_SETPOLICY. All other auditon() commands are valid from any zone.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
auditconfig(1M), auditd(1M), bsmconv(1M), audit(2), exec(2), audit.log(4), attributes(5), privileges(5)
The functionality described in this man page is available only if the Solaris Auditing has been enabled. See bsm<hy>
conv(1M) for more information.
<beginning of page>
The auditon options that modify or display process-based information are not affected by the "perzone" audit policy.
Those that modify system audit data such as the terminal ID and audit queue parameters are valid only in the global
zone unless the "perzone" policy is set. The "get" options for system audit data reflect the local zone if "perzone" is
set; otherwise they reflects the settings of the global zone.
audit_startup.1m <beginning of page>
audit_startup <-> audit subsystem initialization script
/etc/security/audit_startup
The audit_startup script is used to initialize the audit subsystem before the audit deamon is started. This script is
configurable by the system administrator, and currently consists of a series of auditconfig(1M) commands to set the
system default policy, and download the initial event to class mapping.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Obsolete Committed
auditconfig(1M), auditd(1M), bsmconv(1M), attributes(5)
See the section on Solaris Auditing in System Administration Guide: Security Services.
The functionality described in this man page is available only if the Basic Security Module (BSM) has been enabled.
See bsmconv(1M) for more information.
This command is Obsolete and may be removed and replaced with equivalent functionality in a future release of So<hy>
laris.
audit_warn.1m <beginning of page>
audit_warn <-> audit daemon warning script
/etc/security/audit_warn [option [arguments]]
The audit_warn utility processes warning or error messages from the audit daemon. When a problem is encoun<hy>
tered, the audit daemon, auditd(1M) calls audit_warn with the appropriate arguments. The option argument speci<hy>
fies the error type.
The system administrator can specify a list of mail recipients to be notified when an audit_warn situation arises by
defining a mail alias called audit_warn in aliases(4). The users that make up the audit_warn alias are typically the
audit and root users.
The following options are supported:
allhard count
Indicates that the hard limit for all filesystems has been exceeded count times. The default action for this option is to
send mail to the audit_warn alias only if the count is 1, and to write a message to the machine console every time. It
is recommended that mail not be sent every time as this could result in a the saturation of the file system that con<hy>
tains the mail spool directory.
allsoft
Indicates that the soft limit for all filesystems has been exceeded. The default action for this option is to send mail to
the audit_warn alias and to write a message to the machine console.
auditoff
Indicates that someone other than the audit daemon changed the system audit state to something other than
AUC_AUDITING. The audit daemon will have exited in this case. The default action for this option is to send mail
to the audit_warn alias and to write a message to the machine console.
ebusy
Indicates that the audit daemon is already running. The default action for this option is to send mail to the au<hy>
dit_warn alias and to write a message to the machine console.
getacdir count
Indicates that there is a problem getting the directory list or plugin list from audit_control(4). The audit daemon
will hang in a sleep loop until the file is fixed. The default action for this option is to send mail to the audit_warn
alias only if count is 1, and to write a message to the machine console every time. It is recommended that mail not
be sent every time as this could result in a the saturation of the file system that contains the mail spool directory.
hard filename
Indicates that the hard limit for the file has been exceeded. The default action for this option is to send mail to the
audit_warn alias and to write a message to the machine console.
nostart
Indicates that auditing could not be started. The default action for this option is to send mail to the audit_warn alias
and to write a message to the machine console. Some administrators may prefer to modify audit_warn to reboot the
system when this error occurs.
plugin name error count text
Indicates that an error occurred during execution of the auditd plugin name. The default action for this option is to
send mail to the audit_warn alias only if count is 1, and to write a message to the machine console every time.
(Separate counts are kept for each error type.) It is recommended that mail not be sent every time as this could result
in the saturation of the file system that contains the mail spool directory. The text field provides the detailed error
message passed from the plugin. The error field is one of the following strings:
<beginning of page>
load_error Unable to load the plugin name.
sys_error The plugin name is not executing due to a system error such as a lack of resources.
config_error No plugins loaded (including the binary file plugin, audit_binfile(5)) due to configuration errors in
audit_control(4). The name string is -- to indicate that no plugin name applies.
retry The plugin name reports it has encountered a temporary failure. For example, the audit_binfree.so plugin uses
retry to indicate that all directories are full.
no_memory The plugin name reports a failure due to lack of memory.
invalid The plugin name reports it received an invalid input.
failure The plugin name has reported an error as described in text.
postsigterm
Indicates that an error occurred during the orderly shutdown of the audit daemon. The default action for this option
is to send mail to the audit_warn alias and to write a message to the machine console.
soft filename
Indicates that the soft limit for filename has been exceeded. The default action for this option is to send mail to the
audit_warn alias and to write a message to the machine console.
tmpfile
Indicates that the temporary audit file already exists indicating a fatal error. The default action for this option is to
send mail to the audit_warn alias and to write a message to the machine console.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsr _ Interface StabilityEvolving
The interface stability is evolving. The file content is unstable.
audit(1M), auditd(1M), bsmconv(1M), aliases(4), audit.log(4), audit_control(4), attributes(5)
See the section on Solaris Auditing in System Administration Guide: Security Services.
This functionality is available only if the Solaris Auditing feature has been enabled. See bsmconv(1M) for more in<hy>
formation.
If the audit policy perzone is set, the /etc/security/audit_warn script for the local zone is used for notifications
from the local zone's instance of auditd. If the perzone policy is not set, all auditd errors are generated by the glob<hy>
al zone's copy of /etc/security/audit_warn.
auths.1 <beginning of page>
auths <-> print authorizations granted to a user
auths [ user ]...
The auths command prints on standard output the authorizations that you or the optionally-specified user or role
have been granted. Authorizations are rights that are checked by certain privileged programs to determine whether a
user may execute restricted functionality.
Each user may have zero or more authorizations. Authorizations are represented by fully-qualified names, which
identify the organization that created the authorization and the functionality that it controls. Following the Java con<hy>
vention, the hierarchical components of an authorization are separated by dots (.), starting with the reverse order In<hy>
ternet domain name of the creating organization, and ending with the specific function within a class of authoriza<hy>
tions.
An asterisk (*) indicates all authorizations in a class.
A user's authorizations are looked up in user_attr(4) and in the /etc/security/policy.conf file (see policy.conf(4)).
Authorizations may be specified directly in user_attr(4) or indirectly through prof_attr(4). Authorizations may also
be assigned to every user in the system directly as default authorizations or indirectly as default profiles in the
/etc/security/policy.conf file. Example 1 Sample output
The auths output has the following form:
 example% auths tester01 tester02
 tester01 : solaris.system.date,solaris.jobs.admin
 tester02 : solaris.system.*
 example%
Notice that there is no space after the comma separating the authorization names in tester01.
The following exit values are returned:
0 Successful completion.
1 An error occurred.
/etc/user_attr
/etc/security/auth_attr
/etc/security/policy.conf
/etc/security/prof_attr
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
profiles(1), roles(1), getauthattr(3SECDB), auth_attr(4), policy.conf(4), prof_attr(4), user_attr(4), attributes(5)
autofs.4 <beginning of page>
autofs <-> file containing parameter values for automountd daemon and automount command
/etc/default/autofs
The autofs file resides in directory /etc/default and supplies default parameters for the automountd(1M) daemon
and the automount(1M) command.
The autofs file format is ASCII; comment lines begin with the crosshatch (#) character. Parameters consist of a
keyword followed by an equal sign followed by the parameter value, of the form:
 keyword=value
As shipped, the parameters in the autofs file are commented out. As root, you must uncomment a keyword-value
line to make the value for that parameter take effect.
Administrators can make changes to the startup parameters for automountd by logging in as root and editing the
autofs file. Changes made to autofs values on an automount or automountd command line override values in
/etc/default/autofs. The /etc/default/autofs file is preserved across operating system upgrades.
The following parameters are currently supported in the autofs file:
AUTOMOUNT_TIMEOUT=<num>
Specifies a duration, in seconds, that a file system is to remain mounted when not in use. The default value is 600
(10 minutes). Equivalent to the -t option in automount.
AUTOMOUNT_VERBOSE=TRUE | FALSE
Verbose mode. Causes you to be notified of non-critical events, suchs as autofs mounts and unmounts. The default
value is FALSE. Equivalent to the -v option in automount.
AUTOMOUNTD_VERBOSE=TRUE | FALSE
Verbose mode. Causes status messages to be logged to /var/svc/log/system-filesystem-autofs:default.log. (See
smf(5).) The default value is FALSE. Equivalent to the -v option in automountd.
AUTOMOUNTD_NOBROWSE=<num>
Turn on or off browsing for all autofs mount points. The default value is FALSE. Equivalent to the -n option in au<hy>
tomountd.
AUTOMOUNTD_TRACE=<num>
Expands each RPC call and logs it to /var/svc/log/system-filesystem-autofs:default.log. (See smf(5).) The default
value, 0, turns off such tracing. Starting with 1, with each higher value, the verbosity of trace output increases.
AUTOMOUNTD_ENV=<name>=<value>
Environment variables. Each environment variable-value pairing must be on its own line. You can specify multiple
such pairings. There are no environment variable settings supplied. For example: AUTO<hy>
MOUNTD_ENV=DAY=TUES
automount(1M), automountd(1M), smf(5)
au_user_mask.3bsm <beginning of page>
au_user_mask <-> get user's binary preselection mask
cc [ flag... ] file... -lbsm -lsocket -lnsl [ library... ]
#include <bsm/libbsm.h>
int au_user_mask(char *username, au_mask_t *mask_p);
The au_user_mask() function reads the default, system wide audit classes from audit_control(4), combines them
with the per-user audit classes from the audit_user(4) database, and updates the binary preselection mask pointed to
by mask_p with the combined value.
The audit flags in the flags field of the audit_control(4) database and the always-audit-flags and never-audit-flags
from the audit_user(4) database represent binary audit classes. These fields are combined by au_preselect(3BSM)
as follows:
mask = ( flags + always-audit-flags) <mi> never-audit-flags
The au_user_mask() function fails only if both the both the audit_control(4) and the audit_user(4) database en<hy>
tries could not be retrieved. This allows for flexible configurations.
Upon successful completion, au_user_mask() returns 0. It fails and returns <mi>1 if both the audit_control(4) and the
audit_user(4) database entries could not be retrieved.
/etc/security/audit_control
file containing default parameters read by the audit daemon, auditd(1M)
/etc/security/audit_user
file that stores per-user audit event mask
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
login(1), bsmconv(1M), getaudit(2), setaudit(2), au_preselect(3BSM), getacinfo(3BSM), getauusernam(3BSM),
audit_control(4), audit_user(4), attributes(5)
The au_user_mask() function should be called by programs like login(1) which set a process's preselection mask
with setaudit(2). getaudit(2) should be used to obtain audit characteristics for the current process.
The functionality described on this manual page is available only if the Solaris Auditing has been enabled. See
bsmconv(1M) for more information.
backq.9f <beginning of page>
backq <-> get pointer to the queue behind the current queue
#include <sys/stream.h>
queue_t *backq(queue_t *cq);
Architecture independent level 1 (DDI/DKI).
cq The pointer to the current queue. queue_t is an alias for the queue(9S) structure.
The backq() function returns a pointer to the queue preceding cq (the current queue). If cq is a read queue, backq()
returns a pointer to the queue downstream from cq, unless it is the stream end. If cq is a write queue, backq() returns
a pointer to the next queue upstream from cq, unless it is the stream head.
If successful, backq() returns a pointer to the queue preceding the current queue. Otherwise, it returns NULL.
The backq() function can be called from user, interrupt, or kernel context.
queue(9S)
Writing Device Drivers
STREAMS Programming Guide
bart_rules.4 <beginning of page>
bart_rules <-> bart rules file
The bart_rules file is a text file that is used by the bart(1M) command. The rules file determines which files to vali<hy>
date and which file attributes of those files to ignore.
Some lines are ignored by the manifest comparison tool. Ignored lines include blank lines, lines that consist only of
white space, and comments that begin with #.
The rules file supports three directives: CHECK, IGNORE, and a subtree directive, which is an absolute path name
and optional pattern matching modifiers. Each CHECK, IGNORE, and subtree directive must be on a separate line.
Bart supports continuation of long lines using a backslash (\). The rules file uses the directives to create logical
blocks.
The syntax for the rules file is as follows:
 [IGNORE attribute...]*
 [CHECK] [attribute...]*
 subtree1 [pattern...]*
 [IGNORE attribute...]*
 [CHECK] [attribute...]*
 subtree2 [pattern...]*
 subtree3 [pattern...]*
 subtree4 [pattern...]*
 [IGNORE attribute...]*
 [CHECK] [attribute...]*
 ...
Rule blocks are composed of statements that are created by using directives and arguments.
There are three types of blocks:
Global Block The first block in the file. The block is considered ``global'' if it specifies CHECK and IGNORE
statements, but no previous subtree statement. A global block pertains to all subsequent blocks.
Local block A block that specifies CHECK and IGNORE statements as well as a subtree directive. The rules in
this block pertain to files and directories found in the specified subtree.
Heir block A block that contains a null CHECK statement, no arguments. This block inherits the global CHECK
statements and IGNORE statements.
The order in which CHECK and IGNORE statements appear in blocks is important. The bart command processes
CHECK and IGNORE statements in the order in which they are read, with later statements overriding earlier state<hy>
ments.
Subtree specifications must appear one per line. Each specification must begin with an absolute path name. Option<hy>
ally, each specification can be followed by pattern-matching arguments.
When a file system being tracked belongs to more than one subtree directive, bart performs the following resolution
steps: <bu> Applies the CHECK and IGNORE statements set in the global block. Note that all CHECK and IGNORE
statements are processed in order. <bu> Finds the last subtree directive that matches the file. <bu> Processes the CHECK
and IGNORE statements that belong to the last matching subtree directive. These statements are processed in the
order in which they are read, overriding global settings.
There are two types of pattern matching statements
AND For a given subtree directive, all pattern matching statements are logically ANDed with the subtree. Patterns
have the following syntax: <bu> Wildcards are permitted for both the subtree and pattern matching statements. <bu> The ex<hy>
clamation point (!) character represents logical NOT. <bu> A pattern that terminates with a slash is a subtree. The ab<hy>
sence of a slash indicates that the pattern is not a directory. The subtree itself does not require an end slash. For ex<hy>
ample, the following subtree example includes the contents of /home/nickiso/src except for object files, core files,
<beginning of page>
and all of the SCCS subtrees. Note that directory names that terminate with .o and directories named core are not
excluded because the patterns specified do not terminate with /.
 /home/nickiso/src !*.o !core !SCCS/
 CHECK all
OR Group multiple subtree directives together. Such subtree directives are logically ORed together.
 /home/nickiso/src !*.o !core
 /home/nickiso/Mail
 /home/nickiso/docs *.sdw
 CHECK all
 IGNORE mtime lnmtime dirmtime
The files included in the previous example are as follows: <bu> Everything under /home/nickiso/src except for *.o and
core files <bu> Everything under /home/nickiso/Mail <bu> All files under /home/nickiso/docs that end in *.sdw For these
files, all attributes are checked except for modification times.
The bart command uses CHECK and IGNORE statements to define which attributes to track or ignore. Each at<hy>
tribute has an associated keyword.
The attribute keywords are as follows:
acl ACL attributes for the file. For a file with ACL attributes, this field contains the output from acltotext().
all All attributes.
contents Checksum value of the file. This attribute is only specified for regular files. If you turn off context checking
or if checksums cannot be computed, the value of this field is -.
dest Destination of a symbolic link.
devnode Value of the device node. This attribute is for character device files and block device files only.
dirmtime Modification time in seconds since 00:00:00 UTC, January 1, 1970 for directories.
gid Numerical group ID of the owner of this entry.
lnmtime Creation time for links.
mode Octal number that represents the permissions of the file.
mtime Modification time in seconds since 00:00:00 UTC, January 1, 1970 for files.
size File size in bytes.
type Type of file.
uid Numerical user ID of the owner of this entry.
Example 1 Sample Rules File
<beginning of page>
The following is a sample rules file:
 # Global rules, track everything except dirmtime.
 CHECK all
 IGNORE dirmtime
 # The files in /data* are expected to change, so don't bother
 # tracking the attributes expected to change.
 # Furthermore, by specifying ``IGNORE contents,'' you save
 # time and resources.
 /data*
 IGNORE contents mtime size
 /home/nickiso f* bar/
 IGNORE acl
 # For /usr, apply the global rules.
 /usr
 CHECK
 # Note: Since /usr/tmp follows the /usr block, the /usr/tmp
 # subtree is subjected to the ``IGNORE all.''
 /usr/tmp
 /home/nickiso *.o
 /home/nickiso core
 /home/nickiso/proto
 IGNORE all
The following files are cataloged based on the sample rules file:
<bu> All attributes, except for dirmtime, mtime, size, and contents, are tracked for files under the /data* subtrees. <bu>
Files under the /usr subtree, except for /usr/tmp, are cataloged by using the global rules. <bu> If the /home/nick<hy>
iso/foo.c file exists, its attributes, except for acl and dirmtime, are cataloged. <bu> All .o and core files under
/home/nickiso, as well as the /home/nickiso/proto and /usr/tmp subtrees, are ignored. <bu> If the /home/nick<hy>
iso/bar/foo.o file exists, it is ignored because it is subject to the last block.
bart(1M), bart_manifest(4), attributes(5)
baudrate.3xcurses <beginning of page>
baudrate <-> return terminal baud rate
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library... ]
#include <curses.h>
int baudrate(void);
The baudrate() function returns the terminal's data communication line and output speed in bits per second (for ex<hy>
ample, 9600).
The baudrate() function returns the output speed of the terminal.
None.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
libcurses(3XCURSES), attributes(5), standards(5)
bcmp.9f <beginning of page>
bcmp <-> compare two byte arrays
#include <sys/types.h>
#include <sys/ddi.h>
int bcmp(const void *s1, const void *s2, size_t len);
Architecture independent level 1 (DDI/DKI).
s1 Pointer to the first character string.
s2 Pointer to the second character string.
len Number of bytes to be compared.
The bcmp() function compares two byte arrays of length len.
The bcmp() function returns 0 if the arrays are identical, or 1 if they are not.
The bcmp() function can be called from user, interrupt, or kernel context.
strcmp(9F)
Writing Device Drivers
Unlike strcmp(9F), bcmp() does not terminate when it encounters a null byte.
beep.3xcurses <beginning of page>
beep, flash <-> activate audio-visual alarm
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library... ]
#include <curses.h>
int beep(void);
int flash(void);
The beep() and flash() functions produce an audio and visual alarm on the terminal, respectively. If the terminal has
the capability, beep() sounds a bell or beep and flash() flashes the screen. One alarm is substituted for another if the
terminal does not support the capability called (see terminfo(4) bel and flash capabilities). For example, a call to
beep() for a terminal without that capability results in a flash.
These functions always return OK.
None.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
libcurses(3XCURSES), terminfo(4), attributes(5), standards(5)
bfs.1 <beginning of page>
bfs <-> big file scanner
/usr/bin/bfs [-] filename
The bfs command is (almost) like ed(1) except that it is read-only and processes much larger files. Files can be up to
1024K bytes and 32K lines, with up to 512 characters, including new-line, per line (255 for 16-bit machines). bfs is
usually more efficient than ed(1) for scanning a file, since the file is not copied to a buffer. It is most useful for iden<hy>
tifying sections of a large file where csplit(1) can be used to divide it into more manageable pieces for editing.
Normally, the size of the file being scanned is printed, as is the size of any file written with the w (write) command.
The optional <mi> suppresses printing of sizes. Input is prompted with * if P and a carriage return are typed, as in ed(1).
Prompting can be turned off again by inputting another P and carriage return. Note that messages are given in re<hy>
sponse to errors if prompting is turned on.
All address expressions described under ed(1) are supported. In addition, regular expressions may be surrounded
with two symbols besides / and ?:
> indicates downward search without wrap-around, and
< indicates upward search without wrap-around.
There is a slight difference in mark names; that is, only the letters a through z may be used, and all 26 marks are re<hy>
membered.
The e, g, v, k, p, q, w, =, !, and null commands operate as described under ed(1). Commands such as <mi><mi><mi>, +++<mi>,
+++=, <mi>12, and +4p are accepted. Note that 1,10p and 1,10 will both print the first ten lines. The f command only
prints the name of the file being scanned; there is no remembered file name. The w command is independent of out<hy>
put diversion, truncation, or crunching (see the xo, xt, and xc commands, below). The following additional com<hy>
mands are available:
xf file
Further commands are taken from the named file. When an end-of-file is reached, an interrupt signal is received or
an error occurs, reading resumes with the file containing the xf. The xf commands may be nested to a depth of 10.
xn
List the marks currently in use (marks are set by the k command).
xo [file]
Further output from the p and null commands is diverted to the named file, which, if necessary, is created mode 666
(readable and writable by everyone), unless your umask setting (see umask(1)) dictates otherwise. If file is missing,
output is diverted to the standard output. Note that each diversion causes truncation or creation of the file.
: label
This positions a label in a command file. The label is terminated by new-line, and blanks between the : (colon) and
the start of the label are ignored. This command may also be used to insert comments into a command file, since la<hy>
bels need not be referenced.
( . , . )xb/regular expression/label
A jump (either upward or downward) is made to label if the command succeeds. It fails under any of the following
conditions: 1. Either address is not between 1 and $. 2. The second address is less than the first. 3. The regular ex<hy>
pression does not match at least one line in the specified range, including the first and last lines. On success, . (dot)
is set to the line matched and a jump is made to label. This command is the only one that does not issue an error
message on bad addresses, so it may be used to test whether addresses are bad before other commands are executed.
Note that the command, xb/^/ label, is an unconditional jump.
The xb command is allowed only if it is read from someplace other than a terminal. If it is read from a pipe, only a
downward jump is possible.
<beginning of page>
xt number
Output from the p and null commands is truncated to, at most, number characters. The initial number is 255.
xv[digit][spaces][value]
The variable name is the specified digit following the xv. The commands xv5100 or xv5 100 both assign the value
100 to the variable 5. The command xv61,100p assigns the value 1,100p to the variable 6. To reference a variable,
put a % in front of the variable name. For example, using the above assignments for variables 5 and 6:
 1,%5p
 1,%5
 %6
will all print the first 100 lines.
g/%5/p
would globally search for the characters 100 and print each line containing a match. To escape the special meaning
of %, a \ must precede it.
g/".*\%[cds]/p
could be used to match and list %c, %d, or %s formats (for example, "printf"-like statements) of characters, decimal
integers, or strings. Another feature of the xv command is that the first line of output from a UNIX system command
can be stored into a variable. The only requirement is that the first character of value be an !. For example:
 .w junk
 xv5!cat junk
 !rm junk
 !echo "%5"
 xv6!expr %6 + 1
would put the current line into variable 35, print it, and increment the variable 36 by one. To escape the special
meaning of ! as the first character of value, precede it with a \.
xv7\!date
stores the value !date into variable 7.
xbz label
xbn label
These two commands will test the last saved return code from the execution of a UNIX system command (!com<hy>
mand) or nonzero value, respectively, to the specified label. The two examples below both search for the next five
lines containing the string size:
Example 1:
 xv55
 : l
 /size/
 xv5!expr %5 <mi> 1
 !if 0%5 != 0 exit 2
 xbn l
Example 2:
 xv45
<beginning of page>
 : l
 /size/
 xv4!expr %4 <mi> 1
 !if 0%4 = 0 exit 2
 xbz l
xc [switch]
If switch is 1, output from the p and null commands is crunched; if switch is 0, it is not. Without an argument, xc re<hy>
verses switch. Initially, switch is set for no crunching. Crunched output has strings of tabs and blanks reduced to
one blank and blank lines suppressed.
The following operand is supported:
filename Any file up to 1024K bytes and 32K lines, with up to 512 characters, including new-line, per line (255 for
16-bit machines). filename can be a section of a larger file which has been divided into more manageable sections for
editing by the use of csplit(1).
The following exit values are returned:
0 Successful completion without any file or command errors.
>0 An error occurred.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wesu
csplit(1), ed(1), umask(1), attributes(5)
Message is ? for errors in commands, if prompting is turned off. Self-explanatory error messages are displayed when
prompting is on.
bind.3socket <beginning of page>
bind <-> bind a name to a socket
cc [ flag ... ] file ... -lsocket -lnsl [ library ... ]
#include <sys/types.h>
#include <sys/socket.h>
int bind(int s, const struct sockaddr *name, int namelen);
The bind() function assigns a name to an unnamed socket. When a socket is created with socket(3SOCKET), it ex<hy>
ists in a name space (address family) but has no name assigned. The bind() function requests that the name pointed
to by name be assigned to the socket.
Upon successful completion 0 is returned. Otherwise, <mi>1 is returned and errno is set to indicate the error.
The bind() function will fail if:
EACCES The requested address is protected, and {PRIV_NET_PRIVADDR} is not asserted in the effective set of
the current process.
EADDRINUSE The specified address is already in use.
EADDRNOTAVAIL The specified address is not available on the local machine.
EBADF s is not a valid descriptor.
EINVAL namelen is not the size of a valid address for the specified address family.
The socket is already bound to an address.
Socket options are inconsistent with port attributes.
ENOSR There were insufficient STREAMS resources for the operation to complete.
ENOTSOCK s is a descriptor for a file, not a socket.
The following errors are specific to binding names in the UNIX domain:
EACCES Search permission is denied for a component of the path prefix of the pathname in name.
EIO An I/O error occurred while making the directory entry or allocating the inode.
EISDIR A null pathname was specified.
ELOOP Too many symbolic links were encountered in translating the pathname in name.
ENOENT A component of the path prefix of the pathname in name does not exist.
ENOTDIR A component of the path prefix of the pathname in name is not a directory.
EROFS The inode would reside on a read-only file system.
<beginning of page>
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT-LevelSafe
unlink(2), socket(3SOCKET), attributes(5), privileges(5), socket.h(3HEAD)
Binding a name in the UNIX domain creates a socket in the file system that must be deleted by the caller when it is
no longer needed by using unlink(2).
The rules used in name binding vary between communication domains.
bioerror.9f <beginning of page>
bioerror <-> indicate error in buffer header
#include <sys/types.h>
#include <sys/buf.h>
#include <sys/ddi.h>
void bioerror(struct buf *bp, int error);
Solaris DDI specific (Solaris DDI)
bp Pointer to the buf(9S) structure describing the transfer.
error Error number to be set, or zero to clear an error indication.
If error is non-zero, bioerror() indicates an error has occured in the buf(9S) structure. A subsequent call to geter<hy>
ror(9F) will return error.
If error is 0, the error indication is cleared and a subsequent call to geterror(9F) will return 0.
bioerror() can be called from any context.
strategy(9E), geterror(9F), getrbuf(9F), buf(9S)
bioreset.9f <beginning of page>
bioreset <-> reuse a private buffer header after I/O is complete
#include <sys/buf.h>
#include <sys/ddi.h>
void bioreset(struct buf *bp);
Solaris DDI specific (Solaris DDI)
bp Pointer to the buf(9S) structure.
bioreset() is used by drivers that allocate private buffers with getrbuf(9F) or kmem_alloc(9F) and want to reuse
them in multiple transfers before freeing them with freerbuf(9F) or kmem_free(9F). bioreset() resets the buffer
header to the state it had when initially allocated by getrbuf() or initialized by bioinit(9F).
bioreset() can be called from any context.
strategy(9E), bioinit(9F), biofini(9F), freerbuf(9F), getrbuf(9F), kmem_alloc(9F), kmem_free(9F), buf(9S)
bp must not describe a transfer in progress.
bkgrnd.3xcurses <beginning of page>
bkgrnd, bkgrndset, getbkgrnd, wbkgrnd, wbkgrndset, wgetbkgrnd <-> set or get the background character (and rendi<hy>
tion) of window using a complex character
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library... ]
#include <curses.h>
int bkgrnd(const cchar_t *wch);
void bkgrndset(const cchar_t *wch);
int getbkgrnd(cchar_t *wch);
int wbkgrnd(WINDOW *win, const cchar_t *wch);
void wbkgrndset(WINDOW *win, const cchar_t *wch);
int wgetbkgrnd(WINDOW *win, cchar_t *wch);
The bkgrndset() and wbkgrndset() functions turn off the previous background attributes, logical OR the requested
attributes into the window rendition, and set the background property of the current or specified window based on
the information in wch.
The bkgrnd() and wbkgrnd() functions turn off the previous background attributes, logical OR the requested at<hy>
tributes into the window rendition, and set the background property of the current or specified window and then ap<hy>
ply this setting to every character position in that window: <bu> The rendition of every character on the screen is
changed to the new window rendition. <bu> Wherever the former background character appears, it is changed to the
new background character.
If wch refers to a non-spacing complex character for bkgrnd(), bkgrndset(), wbkgrnd(), and wbkgrndset(), then
wch is added to the existing spacing complex character that is the background character. If wch refers to a multi-col<hy>
umn character, the results are unspecified.
The getbkgrnd() and wgetbkgrnd() functions store, into the area pointed to buy wch, the window's background
character and rendition.
wch Is a pointer to the complex background character to be set.
win Is a pointer to the window in which the complex background character is to be set.
The bkgrndset() and wbkgrndset() functions do not return a value.
Upon successful completion, the other functions return OK. Otherwise, they return ERR.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
add_wch(3XCURSES), add_wchnstr(3XCURSES), addch(3XCURSES), addchstr(3XCURSES), at<hy>
troff(3XCURSES), bkgd(3XCURSES), clear(3XCURSES), clrtoeol(3XCURSES), clrtobot(3XCURSES),
erase(3XCURSES), inch(3XCURSES), libcurses(3XCURSES), mvprintw(3XCURSES), attributes(5), stan<hy>
dards(5)
bltocolor.3tsol <beginning of page>
bltocolor, bltocolor_r <-> get character-coded color name of label
cc [flag...] file... -ltsol [library...]
#include <tsol/label.h>
char *bltocolor(const m_label_t *label);
char *bltocolor_r(const m_label_t *label, const int size,
 char *color_name);
The bltocolor() and bltocolor_r() functions get the character-coded color name associated with the binary label la<hy>
bel.
The calling process must have PRIV_SYS_TRANS_LABEL in its set of effective privileges to get color names of
labels that dominate the current process's sensitivity label.
The bltocolor() function returns a pointer to a statically allocated string that contains the character-coded color
name specified for the label or returns (char *)0 if, for any reason, no character-coded color name is available for
this binary label.
The bltocolor_r() function returns a pointer to the color_name string which contains the character-coded color name
specified for the label or returns (char *)0 if, for any reason, no character-coded color name is available for this bi<hy>
nary label. color_name must provide for a string of at least size characters.
/etc/security/tsol/label_encodings
The label encodings file contains the classification names, words, constraints, and values for the defined labels of
this system.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Obsolete _ MT-LevelMT-Safe with exceptions
These functions are obsolete and retained for ease of porting. They might be removed in a future Solaris Trusted Ex<hy>
tensions release. Use the label_to_str(3TSOL) function instead.
The bltocolor() function returns a pointer to a statically allocated string. Subsequent calls to it will overwrite that
string with a new character-coded color name. It is not MT-Safe. The bltocolor_r() function should be used in multi<hy>
threaded applications.
label_to_str(3TSOL), libtsol(3LIB), attributes(5)
The functionality described on this manual page is available only if the system is configured with Trusted Exten<hy>
sions.
If label includes a specified word or words, the character-coded color name associated with the first word specified
in the label encodings file is returned. Otherwise, if no character-coded color name is specified for label, the first
character-coded color name specified in the label encodings file with the same classification as the binary label is re<hy>
turned.
bootconfchk.1m <beginning of page>
bootconfchk <-> verify the integrity of a network boot configuration file
/usr/sbin/bootconfchk [bootconf-file]
The bootconfchk command checks that the file specified is a valid network boot configuration file as described in
wanboot.conf(4).
Any discrepancies are reported on standard error.
0 Successful completion.
1 An error occurred.
2 Usage error.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wwbsup _ Interface StabilityEvolving
wanboot.conf(4), attributes(5)
bp_copyin.9f <beginning of page>
bp_copyin <-> copy from a buf(9S) into a driver buffer
#include <sys/types.h>
#include <sys/buf.h>
int bp_copyin(struct buf *bp, void *driverbuf, offset_t offset,
 size_t size);
Architecture independent level 1 (DDI/DKI).
bp Pointer to the buffer header structure to copy from.
driverbuf Driver buffer to copy to.
offset Offset into bp where to start copying.
size Size of copy.
The bp_copyin() function copies size bytes into the memory associated with bp to the destination driver buffer
driverbuf. The offset only applies to bp.
Under normal conditions, 0 is returned to indicate a successful copy. Otherwise, -1 is returned if bp references in<hy>
valid pages.
The bp_copyin() function can be called from user or kernel context only.
bp_copyout(9F), bp_mapin(9F), bp_mapout(9F), ddi_copyout(9F), buf(9S)
bpp.7d <beginning of page>
bpp <-> bi-directional parallel port driver
SUNW,bpp@slot,offset:bppn
The bpp driver provides a general-purpose bi-directional interface to parallel devices. It supports a variety of output
(printer) and input (scanner) devices, using programmable timing relationships between the various handshake sig<hy>
nals.
The bpp driver is an exclusive-use device. If the device has already been opened, subsequent opens fail with
EBUSY.
Each time the bpp device is opened, the default configuration is BPP_ACK_BUSY_HS for read handshake,
BPP_ACK_HS for write handshake, 1 microsecond for all setup times and strobe widths, and 60 seconds for both
timeouts. This configuration (in the write mode) drives many common personal computer parallel printers with Cen<hy>
tronics-type interfaces. The application should use the BPPIOC_SETPARMS ioctl request to configure the bpp
for the particular device which is attached, if necessary.
If a failure or error condition occurs during a write(2), the number of bytes successfully written is returned (short
write). Note that errno will not be set. The contents of certain status bits will be captured at the time of the error,
and can be retrieved by the application program, using the BPPIOC_GETERR ioctl request. Subsequent write(2)
calls may fail with the system error ENXIO if the error condition is not rectified. The captured status information
will be overwritten each time an attempted transfer or a BPPIOC_TESTIO ioctl request occurs.
If a failure or error condition occurs during a read(2), the number of bytes successfully read is returned (short read).
Note that errno will not be set. The contents of certain status bits will be captured at the time of the error, and can be
retrieved by the application, using the BPPIOC_GETERR ioctl request. Subsequent read(2) calls may fail with
ENXIO if the error condition is not rectified. The captured register information will be overwritten each time an at<hy>
tempted transfer or a BPPIOC_TESTIO ioctl request.
If the read_handshake element of the bpp_transfer_parms structure (see below) is set to BPP_CLEAR_MEM
or BPP_SET_MEM, zeroes or ones, respectively, are written into the user buffer.
When the driver is opened for reading and writing, it is assumed that scanning will take place, as scanners are the
only devices supported by this mode. Most scanners require that the SLCT_IN or AFX pin be set to tell the scanner
the direction of the transfer. The AFX line is set when the read_handshake element of the bpp_transfer_parms
structure is set to BPP_HSCAN_HS, otherwise the SLCT_IN pin is set. Normally, scanning starts by writing a
command to the scanner, at which time the pin is set. When the scan data is read back, the pin is reset.
The following ioctl requests are supported:
BPPIOC_SETPARMS Set transfer parameters.
The argument is a pointer to a bpp_transfer_parms structure. See below for a description of the elements of this
structure. If a parameter is out of range, EINVAL is returned.
BPPIOC_GETPARMS Get current transfer parameters.
The argument is a pointer to a bpp_transfer_parms structure. See below for a description of the elements of this
structure. If no parameters have been configured since the device was opened, the contents of the structure will be
the default conditions of the parameters (see Default Operation above).
BPPIOC_SETOUTPINS Set output pin values.
The argument is a pointer to a bpp_pins structure. See below for a description of the elements of this structure. If a
parameter is out of range, EINVAL is returned.
BPPIOC_GETOUTPINS Read output pin values. The argument is a pointer to a bpp_pins structure. See below
for a description of the elements of this structure.
BPPIOC_GETERR Get last error status.
The argument is a pointer to a bpp_error_status structure. See below for a description of the elements of this struc<hy>
<beginning of page>
ture. This structure indicates the status of all the appropriate status bits at the time of the most recent error condition
during a read(2) or write(2) call, or the status of the bits at the most recent BPPIOC_TESTIO ioctl request. Note:
The bits in the pin_status element indicate whether the associated pin is active, not the actual polarity. The applica<hy>
tion can check transfer readiness without attempting another transfer using the BPPIOC_TESTIO ioctl. Note:
The timeout_occurred and bus_error fields will never be set by the BPPIOC_TESTIO ioctl, only by an actual
failed transfer.
BPPIOC_TESTIO Test transfer readiness.
This command checks to see if a read or write transfer would succeed based on pin status, opened mode, and hand<hy>
shake selected. If a handshake would succeed, 0 is returned. If a transfer would fail, -1 is returned, and errno is set
to EIO, and the error status information is captured. The captured status can be retrieved using the BPPI<hy>
OC_GETERR ioctl call. Note that the timeout_occurred and bus_error fields will never be set by this ioctl.
This structure is defined in <sys/bpp_io.h>.
 struct bpp_transfer_parms {
  enum handshake_t
  read_handshake; /* parallel port read handshake mode */
  int read_setup_time; /* DSS register - in nanoseconds */
  int read_strobe_width; /* DSW register - in nanoseconds */
  int read_timeout; /*
  * wait this many seconds
  * before aborting a transfer
  */
  enum handshake_t
  write_handshake; /* parallel port write handshake mode */
  int write_setup_time; /* DSS register - in nanoseconds */
  int write_strobe_width; /* DSW register - in nanoseconds */
  int write_timeout; /*
  * wait this many seconds
  * before aborting a transfer
  */
 };
 /* Values for read_handshake and write_handshake fields */
  enum handshake_t {
  BPP_NO_HS, /* no handshake pins */
  BPP_ACK_HS, /* handshake controlled by ACK line */
  BPP_BUSY_HS, /* handshake controlled by BSY line */
  BPP_ACK_BUSY_HS, /*
  * handshake controlled by ACK and BSY lines
  * read_handshake only!
  */
  BPP_XSCAN_HS, /* xerox scanner mode,
  * read_handshake only!
   */
  BPP_HSCAN_HS, /*
  * HP scanjet scanner mode
  * read_handshake only!
  */
  BPP_CLEAR_MEM, /* write 0's to memory,
  * read_handshake only!
  */
  BPP_SET_MEM, /* write 1's to memory,
  * read_handshake only!
  */
  /* The following handshakes are RESERVED. Do not use. */
  BPP_VPRINT_HS, /* valid only in read/write mode */
  BPP_VPLOT_HS /* valid only in read/write mode */
 };
The read_setup_time field controls the time between dstrb falling edge to bsy rising edge if the read_handshake
field is set to BPP_NO_HS or BPP_ACK_HS. It controls the time between dstrb falling edge to ack rising edge if
<beginning of page>
the read_handshake field is set to BPP_ACK_HS or BPP_ACK_BUSY_HS. It controls the time between ack
falling edge to dstrb rising edge if the read_handshake field is set to BPP_XSCAN_HS.
The read_strobe_width field controls the time between ack rising edge and ack falling edge if the read_hand<hy>
shake field is set to BPP_NO_HS or BPP_ACK_BUSY_HS. It controls the time between dstrb rising edge to dstrb
falling edge if the read_handshake field is set to BPP_XSCAN_HS.
The values allowed for the write_handshake field are duplicates of the definitions for the read_handshake field.
Note that some of these handshake definitions are only valid in one mode or the other.
The write_setup_time field controls the time between data valid to dstrb rising edge for all values of the
write_handshake field.
The write_strobe_width field controls the time between dstrb rising edge and dstrb falling edge if the write_hand<hy>
shake field is not set to BPP_VPRINT_HS or BPP_VPLOT_HS. It controls the minimum time between dstrb ris<hy>
ing edge to dstrb falling edge if the write_handshake field is set to BPP_VPRINT_HS or BPP_VPLOT_HS.
This structure is defined in <sys/bpp_io.h>.
 struct bpp_pins {
  uchar_t output_reg_pins; /* pins in P_OR register */
  uchar_t input_reg_pins; /* pins in P_IR register */
 };
 /* Values for output_reg_pins field */
 #define BPP_SLCTIN_PIN 0x01 /* Select in pin */
 #define BPP_AFX_PIN 0x02 /* Auto feed pin */
 #define BPP_INIT_PIN 0x04 /* Initialize pin */
 #define BPP_V1_PIN 0x08 /* reserved pin 1 */
 #define BPP_V2_PI 0x10 /* reserved pin 2 */
 #define BPP_V3_PIN 0x20 /* reserved pin 3 */
 #define BPP_ERR_PIN 0x01 /* Error pin */
 #define BPP_SLCT_PIN 0x02 /* Select pin */
 #define BPP_PE_PIN 0x04 /* Paper empty pin */
This structure is defined in the include file <sys/bpp_io.h>.
 struct bpp_error_status {
  char timeout_occurred; /* 1 if a timeout occurred */
  char bus_error; /* 1 if an SBus bus error */
  uchar_t pin_status; /*
     * status of pins which could
     * cause an error
     */
 };
 /* Values for pin_status field */
 #define BPP_ERR_ERR 0x01 /* Error pin active */
 #define BPP_SLCT_ERR 0x02 /* Select pin active */
 #define BPP_PE_ERR 0x04 /* Paper empty pin active */
 #define BPP_SLCTIN_ERR 0x10 /* Select in pin active */
 #define BPP_BUSY_ERR 0x40 /* Busy pin active */
EBADF The device is opened for write-only access and a read is attempted, or the device is opened for read-only
access and a write is attempted.
EBUSY The device has been opened and another open is attempted. An attempt has been made to unload the driver
while one of the units is open.
EINVAL A BPPIOC_SETPARMS ioctl is attempted with an out of range value in the bpp_transfer_parms struc<hy>
ture. A BPPIOC_SETOUTPINS ioctl is attempted with an invalid value in the pins structure. An ioctl is attempt<hy>
ed with an invalid value in the command argument. An invalid command argument is received during modload(1M)
or modunload(1M).
<beginning of page>
EIO The driver encountered an SBus bus error when attempting an access.
A read or write does not complete properly, due to a peripheral error or a transfer timeout.
A BPPIOC_TESTIO ioctl call is attempted while a condition exists which would prevent a transfer (such as a pe<hy>
ripheral error).
ENXIO The driver has received an open request for a unit for which the attach failed. The driver has received a read
or write request for a unit number greater than the number of units available. The driver has received a write request
for a unit which has an active peripheral error.
/dev/bppn bi-directional parallel port devices
ioctl(2), read(2), write(2), sbus(4)
bscv.7d <beginning of page>
bscv, bscbus, i2bsc <-> Blade support chip interface driver
The bscv, bscbus and i2bsc drivers interface with the Blade support chip used on Sun Microsystem's Blade server
products. These drivers provide a conduit for passing control, environmental, cpu signature and event information
between Solaris and the Blade support chip.
These drivers do not export public interfaces. Instead they make information available via picl, prtdiag, prtfru and re<hy>
lated tools. In addition, these drivers log Blade support chip environmental event information into system logs.
/platform/sun4u/kernel/drv/sparcv9/bscbus
64-bit ELF kernel driver
/platform/sun4u/kernel/drv/sparcv9/bscv
64-bit ELF kernel driver
/platform/sun4u/kernel/drv/sparcv9/i2bsc
64-bit ELF kernel driver
/platform/i86pc/kernel/drv/bscbus
32-bit ELF kernel file (x86 only)
/platform/i86pc/kernel/drv/bscv
32-bit ELF kernel file (x86 only)
See attributes(5) for descriptions of the following attributes:
tab() box; lw(2.75i) |lw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureT{
Limited to systems with Blade Support Chip T} _ AvailabilitySUNWcar.u, SUNWcar.i
bsmconv.1m <beginning of page>
bsmconv, bsmunconv <-> enable or disable Solaris Auditing
/etc/security/bsmconv [rootdir]...
/etc/security/bsmunconv [rootdir]...
The bsmconv and bsmunconv scripts are used to enable or disable the BSM features on a Solaris system. The op<hy>
tional argument rootdir is a list of one or more root directories of diskless clients that have already been configured.
See smdiskless(1M).
To enable or disable BSM on a diskless client, a server, or a stand-alone system, logon as super-user to the system
being converted and use the bsmconv or bsmunconv commands without any options.
To enable or disable BSM on a diskless client from that client's server, logon to the server as super-user and use
bsmconv, specifying the root directory of each diskless client you wish to affect. For example, the command:
 myhost# bsmconv /export/root/client1 /export/root/client2
enables BSM on the two machines named client1 and client2. While the command:
 myhost# bsmconv
enables BSM only on the machine called myhost. It is no longer necessary to enable BSM on both the server and its
diskless clients.
After running bsmconv the system can be configured by editing the files in /etc/security. Each diskless client has its
own copy of configuration files in its root directory. You might want to edit these files before rebooting each client.
Following the completion of either script, the affected system(s) should be rebooted to allow the auditing subsystem
to come up properly initialized.
The following files are created by bsmconv:
/etc/security/device_maps
Administrative file defining the mapping of device special files to allocatable device names.
/etc/security/device_allocate
Administrative file defining parameters for device allocation.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsr _ Interface StabilityObsolete Committed
auditconfig(1M), auditd(1M), audit_startup(1M), audit.log(4), audit_control(4), attributes(5)
See the section on Solaris Auditing in System Administration Guide: Security Services.
bsmconv and bsmunconv are not valid in a non-global zone.
These commands are Obsolete and may be removed and replaced with equivalent functionality in a future release of
Solaris.
btopr.9f <beginning of page>
btopr <-> convert size in bytes to size in pages (round up)
#include <sys/ddi.h>
unsigned long btopr(unsigned long numbytes);
Architecture independent level 1 (DDI/DKI).
numbytes Number of bytes.
The btopr() function returns the number of memory pages contained in the specified number of bytes memory,
rounded up to the next whole page. For example, if the page size is 2048, then btopr(4096) returns 2, and bto<hy>
pr(4097) returns 3.
The return value is always the number of pages. There are no invalid input values, and therefore no error return val<hy>
ues.
The btopr() function can be called from user, interrupt, or kernel context.
btop(9F), ddi_btopr(9F), ptob(9F)
Writing Device Drivers
6to4relay.1m <beginning of page>
6to4relay <-> administer configuration for 6to4 relay router communication
/usr/sbin/6to4relay
/usr/sbin/6to4relay [-e] [-a addr]
/usr/sbin/6to4relay [-d]
/usr/sbin/6to4relay [-h]
The 6to4relay command is used to configure 6to4 relay router communication. Relay router communication support
is enabled by setting the value of a variable that stores an IPv4 address within the tun module. This variable is glob<hy>
al to all tunnels and defines the policy for communication with relay routers. By default, the address is set to INAD<hy>
DR_ANY (0.0.0.0), and the kernel interprets the value to indicate that support for relay router communication is dis<hy>
abled. Otherwise, support is enabled, and the specified address is used as the IPv4 destination address when packets
destined for native IPv6 (non-6to4) hosts are sent through the 6to4 tunnel interface. The 6to4relay command uses a
project private ioctl to set the variable.
6to4relay used without any options outputs the current, in-kernel, configuration status. Use the -a option to send
packets to a specific relay router's unicast address instead of the default anycast address. The address specified with
the -a option does not specify the policy for receiving traffic from relay routers. The source relay router on a re<hy>
ceived packet is non-deterministic, since a different relay router may be chosen for each sending native IPv6 end-
point.
Configuration changes made by using the 6to4relay are not persistent across reboot. The changes will persist in the
kernel only until you take the tunnel down
The 6to4relay command supports the following options:
-a addr Use the specified address, addr.
-e Enable support for relay router. Use -a addr if it is specified. Otherwise, use the default anycast address,
192.88.99.1.
-d Disable support for the relay router.
-h Help
The following operands are supported:
addr A specific relay router's unicast address. addr must be specified as a dotted decimal representation of an IPv4
address. Otherwise, an error will occur, and the command will fail.
Example 1 Printing the In-Kernel Configuration Status
Use /usr/sbin/6to4relay without any options to print the in-kernel configuration status.
 example# /usr/sbin/6to4relay
If 6to4 relay router communication is disabled, the administrator will see the following message:
 6to4relay: 6to4 Relay Router communication support is disabled.
If 6to4 router communication is enabled, the user will see this message:
 6to4relay: 6to4 Relay Router communication support is enabled.
<beginning of page>
 IPv4 destination address of Relay Router = 192.88.99.1
The following exit values are returned:
0 Successful completion.
>0 An error occurred.
/usr/sbin/6to4relay The default installation root
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ Interface StabilityEvolving
ifconfig(1M), attributes(5)
Huitema, C. RFC 3068, An Anycast Prefix for 6to4 Relay Routers. Network Working Group. June, 2001.
Carpenter, B. and Moore, K. RFC 3056, Connection of IPv6 Domains via IPv4 Clouds. Network Working Group.
February, 2001.
The 6to4relay reports the following messages:
 6to4relay: input (0.0.0.0) is not a valid IPv4 unicast address
Example:
The following example provides an incorrect unicast address.
 example# 6to4relay -e -a 0.0.0.0
Description:
The address specified with the -a option must be a valid unicast address.
 6to4relay: option requires an argument -a
 usage:
  6to4relay
  6to4relay -e [-a <addr>]
  6to4relay -d
  6to4relay -h
Example:
The following example does not include an argument for the -a option.
 example# 6to4relay -e -a
Description:
The -a option requires an argument.
 usage:
<beginning of page>
  6to4relay
  6to4relay -e [-a <addr>]
  6to4relay -d
  6to4relay -h
Example:
The following example specifies options that are not permitted.
 example# 6to4relay -e -d
Description:
The options specified are not permitted. A usage message is output to the screen.
 usage:
  6to4relay
  6to4relay -e [-a <addr>]
  6to4relay -d
  6to4relay -h
Example:
The following example specifies the -a option without specifying the -e option.
 example# 6to4relay -a 1.2.3.4
Description:
The -e option is required in conjunction with the -a option. A usage message is output to the screen.
 6to4relay: ioctl (I_STR) : Invalid argument
Example:
The following example specifies an invalid address.
 example# 6to4relay -e -a 239.255.255.255
Description:
The address specified with the -a option must not be a class d addr.
aac.7d <beginning of page>
aac <-> SCSI HBA driver for Adaptec AdvancedRAID Controller
The aac plain SCSI host bus adapter driver is a SCSA-compliant nexus driver that supports the Adaptec
2200S/2120S SCSI RAID card, Dell PERC 3Di SCSI RAID controller, Dell PERC 3Si SCSI RAID controller,
Adaptec 2820SA SATA RAID card, Adaptec 4800SAS, 4805SAS SAS RAID cards and SUN's STK RAID REM,
STK RAID INT, and STK RAID EXT RAID cards.
The aac driver is ported from FreeBSD and supports RAID disk I/O functions and the RAID management interface.
There are no user configurable parameters available. Please configure your hardware through BIOS.
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilityT{ x86,
SPARC (Limited to systems with AAC hardware RAID cards.) T}
/kernel/drv/aac 32-bit ELF kernel module.
/kernel/drv/amd64/aac 64-bit ELF kernel module. (x86)
/kernel/drv/sparcv9/aac 64-bit ELF kernel module. (SPARC)
/kernel/drv/aac.conf Configuration file. (Contains no user-configurable options).
prtconf(1M), attributes(5), scsi_hba_attach(9F), scsi_sync_pkt(9F), scsi_transport(9F), scsi_device(9S), sc<hy>
si_inquiry(9S), scsi_pkt(9S)
Small Computer System Interface-2 (SCSI-2)
abs.3c <beginning of page>
abs, labs, llabs <-> return absolute value of integer
#include <stdlib.h>
int abs(int val);
long labs(long lval);
long long llabs(long long llval);
The abs() function returns the absolute value of its int operand.
The labs() function returns the absolute value of its long operand.
The llabs() function returns the absolute value of its long long operand.
In 2's-complement representation, the absolute value of the largest magnitude negative integral value is undefined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
attributes(5), standards(5)
accept.3socket <beginning of page>
accept <-> accept a connection on a socket
cc [ flag ... ] file ... -lsocket -lnsl [ library ... ]
#include <sys/types.h>
#include <sys/socket.h>
int accept(int s, struct sockaddr *addr, socklen_t *addrlen);
The argument s is a socket that has been created with socket(3SOCKET) and bound to an address with
bind(3SOCKET), and that is listening for connections after a call to listen(3SOCKET). The accept() function ex<hy>
tracts the first connection on the queue of pending connections, creates a new socket with the properties of s, and al<hy>
locates a new file descriptor, ns, for the socket. If no pending connections are present on the queue and the socket is
not marked as non-blocking, accept() blocks the caller until a connection is present. If the socket is marked as non-
blocking and no pending connections are present on the queue, accept() returns an error as described below. The
accept() function uses the netconfig(4) file to determine the STREAMS device file name associated with s. This is
the device on which the connect indication will be accepted. The accepted socket, ns, is used to read and write data
to and from the socket that connected to ns. It is not used to accept more connections. The original socket (s) re<hy>
mains open for accepting further connections.
The argument addr is a result parameter that is filled in with the address of the connecting entity as it is known to the
communications layer. The exact format of the addr parameter is determined by the domain in which the communi<hy>
cation occurs.
The argument addrlen is a value-result parameter. Initially, it contains the amount of space pointed to by addr; on re<hy>
turn it contains the length in bytes of the address returned.
The accept() function is used with connection-based socket types, currently with SOCK_STREAM.
It is possible to select(3C) or poll(2) a socket for the purpose of an accept() by selecting or polling it for a read.
However, this will only indicate when a connect indication is pending; it is still necessary to call accept().
The accept() function returns <mi>1 on error. If it succeeds, it returns a non-negative integer that is a descriptor for the
accepted socket.
accept() will fail if:
EBADF The descriptor is invalid.
ECONNABORTED The remote side aborted the connection before the accept() operation completed.
EFAULT The addr parameter or the addrlen parameter is invalid.
EINTR The accept() attempt was interrupted by the delivery of a signal.
EMFILE The per-process descriptor table is full.
ENODEV The protocol family and type corresponding to s could not be found in the netconfig file.
ENOMEM There was insufficient user memory available to complete the operation.
ENOSR There were insufficient STREAMS resources available to complete the operation.
ENOTSOCK The descriptor does not reference a socket.
EOPNOTSUPP The referenced socket is not of type SOCK_STREAM.
<beginning of page>
EPROTO A protocol error has occurred; for example, the STREAMS protocol stack has not been initialized or the
connection has already been released.
EWOULDBLOCK The socket is marked as non-blocking and no connections are present to be accepted.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT-LevelSafe
poll(2), bind(3SOCKET), connect(3SOCKET), listen(3SOCKET), select(3C), socket.h(3HEAD), socket(3SOCK<hy>
ET), netconfig(4), attributes(5)
access.2 <beginning of page>
access, faccessat <-> determine accessibility of a file
#include <unistd.h>
#include <sys/fcntl.h>
int access(const char *path, int amode);
int faccessat(int fd, const char *path, int amode, int flag);
The access() function checks the file named by the pathname pointed to by the path argument for accessibility ac<hy>
cording to the bit pattern contained in amode, using the real user ID in place of the effective user ID and the real
group ID in place of the effective group ID. This allows a setuid process to verify that the user running it would have
had permission to access this file.
The value of amode is either the bitwise inclusive OR of the access permissions to be checked (R_OK, W_OK,
X_OK) or the existence test, F_OK.
These constants are defined in <unistd.h> as follows:
R_OK Test for read permission.
W_OK Test for write permission.
X_OK Test for execute or search permission.
F_OK Check existence of file
See Intro(2) for additional information about "File Access Permission".
If any access permissions are to be checked, each will be checked individually, as described in Intro(2). If the
process has appropriate privileges, an implementation may indicate success for X_OK even if none of the execute
file permission bits are set.
The faccessat() function is equivalent to the access() function, except in the case where path specifies a relative
path. In this case the file whose accessibility is to be determined is located relative to the directory associated with
the file descriptor fd instead of the current working directory.
If faccessat() is passed in the fd parameter the special value AT_FDCWD, defined in <fcntl.h>, the current working
directory is used and the behavior is identical to a call to access().
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in <fcntl.h>:
AT_EACCESS The checks for accessibility are performed using the effective user and group IDs instead of the real
user and group ID as required in a call to access().
If the requested access is permitted, access() and faccessat()succeed and return 0. Otherwise, <mi>1 is returned and er<hy>
rno is set to indicate the error.
The access() and faccessat() functions will fail if:
EACCES Permission bits of the file mode do not permit the requested access, or search permission is denied on a
component of the path prefix.
EFAULT The path argument points to an illegal address.
EINTR A signal was caught during the access() function.
<beginning of page>
ELOOP Too many symbolic links were encountered in resolving path, or loop exists in symbolic links encountered
during resolution of the path argument.
ENAMETOOLONG The length of the path argument exceeds {PATH_MAX}, or a pathname component is longer
than {NAME_MAX} while _POSIX_NO_TRUNC is in effect.
ENOENT A component of path does not name an existing file or path is an empty string.
ENOLINK The path argument points to a remote machine and the link to that machine is no longer active.
ENOTDIR A component of the path prefix is not a directory.
ENXIO The path argument points to a character or block device special file and the corresponding device has been
retired by the fault management framework.
EROFS Write access is requested for a file on a read-only file system.
The faccessat() function will fail if:
EBADF The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a
valid file descriptor open for reading or searching.
The access() and faccessat() functions may fail if:
EINVAL The value of the amode argument is invalid.
ENAMETOOLONG Pathname resolution of a symbolic link produced an intermediate result whose length exceeds
{PATH_MAX}.
ETXTBSY Write access is requested for a pure procedure (shared text) file that is being executed.
The faccessat() function may fail if:
EINVAL The value of the flag argument is not valid.
ENOTDIR The path argument is not an absolute path and fd is neither AT_FDCWD nor a file descriptor associated
with a directory.
Additional values of amode other than the set defined in the description might be valid, for example, if a system has
extended access controls.
The purpose of the faccessat() function is to enable the checking of the accessibility of files in directories other than
the current working directory without exposure to race conditions. Any part of the path of a file could be changed in
parallel to a call to access(), resulting in unspecified behavior. By opening a file descriptor for the target directory
and using the faccessat() function, it can be guaranteed that the file tested for accessibility is located relative to the
desired directory.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelAsync-Signal-Safe _ StandardSee below.
<beginning of page>
For access(), see standards(5).
Intro(2), chmod(2), stat(2), attributes(5), standards(5)
acct.2 <beginning of page>
acct <-> enable or disable process accounting
#include <unistd.h>
int acct(const char *path);
The acct() function enables or disables the system process accounting routine. If the routine is enabled, an account<hy>
ing record will be written in an accounting file for each process that terminates. The termination of a process can be
caused by either an exit(2) call or a signal(3C)). The effective user ID of the process calling acct() must have the ap<hy>
propriate privileges.
The path argument points to the pathname of the accounting file, whose file format is described on the ac<hy>
ct.h(3HEAD) manual page.
The accounting routine is enabled if path is non-zero and no errors occur during the function. It is disabled if path is
(char *)NULL and no errors occur during the function.
Upon successful completion, 0 is returned. Otherwise, <mi>1 is returned and errno is set to indicate the error.
The acct() function will fail if:
EACCES The file named by path is not an ordinary file.
EBUSY An attempt is being made to enable accounting using the same file that is currently being used.
EFAULT The path argument points to an illegal address.
ELOOP Too many symbolic links were encountered in translating path.
ENAMETOOLONG The length of the path argument exceeds {PATH_MAX}, or the length of a path argument
exceeds {NAME_MAX} while _POSIX_NO_TRUNC is in effect.
ENOENT One or more components of the accounting file pathname do not exist.
ENOTDIR A component of the path prefix is not a directory.
EPERM The {PRIV_SYS_ACCT} privilege is not asserted in the effective set of the calling process.
EROFS The named file resides on a read-only file system.
exit(2), acct.h(3HEAD), signal(3C), privileges(5)
acctcms.1m <beginning of page>
acctcms <-> command summary from process accounting records
/usr/lib/acct/acctcms [-a [-o] [-p]] [-c] [-j] [-n] [-s]
 [-t] filename...
acctcms reads one or more filenames, normally in the form described in acct.h(3HEAD). It adds all records for pro<hy>
cesses that executed identically named commands, sorts them, and writes them to the standard output, normally us<hy>
ing an internal summary format.
-a Print output in ASCII rather than in the internal summary format. The output includes command name, number
of times executed, total kcore-minutes, total CPU minutes, total real minutes, mean size (in K), mean CPU minutes
per invocation, "hog factor," characters transferred, and blocks read and written, as in acctcom(1). Output is normal<hy>
ly sorted by total kcore-minutes.
Use the following options only with the -a option:
-o Output a (non-prime) offshift-time-only command summary.
-p Output a prime-time-only command summary.
When -o and -p are used together, a combination prime-time and non-prime-time report is produced. All the output
summaries are total usage except number of times executed, CPU minutes, and real minutes, which are split into
prime and non-prime.
-c Sort by total CPU time, rather than total kcore-minutes.
-j Combine all commands invoked only once under "***other".
-n Sort by number of command invocations.
-s Any file names encountered hereafter are already in internal summary format.
-t Process all records as total accounting records. The default internal summary format splits each field into prime
and non-prime-time parts. This option combines the prime and non-prime time parts into a single field that is the to<hy>
tal of both, and provides upward compatibility with old style acctcms internal summary format records.
Example 1 Using the acctcms command.
A typical sequence for performing daily command accounting and for maintaining a running total is:
 example% acctcms filename ... > today
 example% cp total previoustotal
 example% acctcms -s today previoustotal > total
 example% acctcms -a -s today
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Availability<hy>
SUNWaccu
acctcom(1), acct(1M), acctcon(1M), acctmerg(1M), acctprc(1M), acctsh(1M), fwtmp(1M), runacct(1M), ac<hy>
ct(2), acct.h(3HEAD), utmpx(4), attributes(5)
Unpredictable output results if -t is used on new style internal summary format files, or if it is not used with old style
<beginning of page>
internal summary format files.
acctcon.1m <beginning of page>
acctcon, acctcon1, acctcon2 <-> connect-time accounting
/usr/lib/acct/acctcon [-l lineuse] [-o reboot]
/usr/lib/acct/acctcon1 [-p] [-t] [-l lineuse] [-o reboot]
/usr/lib/acct/acctcon2
acctcon converts a sequence of login/logoff records to total accounting records (see the tacct format in ac<hy>
ct.h(3HEAD)). The login/logoff records are read from standard input. The file /var/adm/wtmpx is usually the
source of the login/logoff records; however, because it might contain corrupted records or system date changes, it
should first be fixed using wtmpfix. The fixed version of file /var/adm/wtmpx can then be redirected to acctcon.
The tacct records are written to standard output.
acctcon is a combination of the programs acctcon1 and acctcon2. acctcon1 converts login/logoff records, taken
from the fixed /var/adm/wtmpx file, to ASCII output. acctcon2 reads the ASCII records produced by acctcon1 and
converts them to tacct records. acctcon1 can be used with the -l and -o options, described below, as well as with the
-p and -t options.
-p Print input only, showing line name, login name, and time (in both numeric and date/time formats).
-t acctcon1 maintains a list of lines on which users are logged in. When it reaches the end of its input, it emits a ses<hy>
sion record for each line that still appears to be active. It normally assumes that its input is a current file, so that it us<hy>
es the current time as the ending time for each session still in progress. The -t flag causes it to use, instead, the last
time found in its input, thus assuring reasonable and repeatable numbers for non-current files.
-l lineuse lineuse is created to contain a summary of line usage showing line name, number of minutes used, percent<hy>
age of total elapsed time used, number of sessions charged, number of logins, and number of logoffs. This file helps
track line usage, identify bad lines, and find software and hardware oddities. Hangup, termination of login(1) and
termination of the login shell each generate logoff records, so that the number of logoffs is often three to four times
the number of sessions. See init(1M) and utmpx(4).
-o reboot reboot is filled with an overall record for the accounting period, giving starting time, ending time, number
of reboots, and number of date changes.
Example 1 Using the acctcon command.
The acctcon command is typically used as follows:
 example% acctcon -l lineuse -o reboots < tmpwtmp > ctacct
The acctcon1 and acctcon2 commands are typically used as follows:
 example% acctcon1 -l lineuse -o reboots < tmpwtmp | sort +1n +2 > ctmp
 example% acctcon2 < ctmp > ctacct
/var/adm/wtmpx History of user access and administration information
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Availability<hy>
SUNWaccu
<beginning of page>
acctcom(1), login(1), acct(1M), acctcms(1M), acctmerg(1M), acctprc(1M), acctsh(1M), fwtmp(1M), init(1M),
runacct(1M), acct(2), acct.h(3HEAD), utmpx(4), attributes(5)

The line usage report is confused by date changes. Use wtmpfix (see fwtmp(1M)), with the /var/adm/wtmpx file as
an argument, to correct this situation.
During a single invocation of any given command, the acctcon, acctcon1, and acctcon2 commands can process a
maximum of: <bu> 6000 distinct session <bu> 1000 distinct terminal lines <bu> 2000 distinct login names
If at some point the actual number of any one of these items exceeds the maximum, the command will not succeed.
acctmerg.1m <beginning of page>
acctmerg <-> merge or add total accounting files
/usr/lib/acct/acctmerg [-a] [-i] [-p] [-t] [-u] [-v]
 [filename] ...
acctmerg reads its standard input and up to nine additional files, all in the tacct format (see acct.h(3HEAD)) or an
ASCII version thereof. It merges these inputs by adding records whose keys (normally user ID and name) are identi<hy>
cal, and expects the inputs to be sorted on those keys.
-a Produce output in ASCII version of tacct.
-i Produce input in ASCII version of tacct.
-p Print input with no processing.
-t Produce a single record that totals all input.
-u Summarize by user ID, rather than by user ID and name.
-v Produce output in verbose ASCII format, with more precise notation for floating-point numbers.
Example 1 Using the acctmerg command.
The following sequence is useful for making "repairs" to any file kept in this format:
 example% acctmerg -v <filename1>filename2
Edit filename2 as you want:
 example% acctmerg -i <filename2>filename1
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Availability<hy>
SUNWaccu
acctcom(1), acct(1M), acctcms(1M), acctcon(1M), acctprc(1M), acctsh(1M), fwtmp(1M), runacct(1M), acct(2),
acct.h(3HEAD), utmpx(4), attributes(5)

acctsh.1m <beginning of page>
acctsh, chargefee, ckpacct, dodisk, lastlogin, monacct, nulladm, prctmp, prdaily, prtacct, shutacct, startup, turnacct <->
shell procedures for accounting
/usr/lib/acct/chargefee login-name number
/usr/lib/acct/ckpacct [blocks]
/usr/lib/acct/dodisk [-o] [filename]...
/usr/lib/acct/lastlogin
/usr/lib/acct/monacct number
/usr/lib/acct/nulladm filename...
/usr/lib/acct/prctmp filename
/usr/lib/acct/prdaily [-c] [-l] [mmdd]
/usr/lib/acct/prtacct filename ['' heading '']
/usr/lib/acct/shutacct ['' reason '']
/usr/lib/acct/startup
/usr/lib/acct/turnacct on | off | switch
chargefee can be invoked to charge a number of units to login-name. A record is written to /var/adm/fee, to be
merged with other accounting records by runacct(1M).
ckpacct should be initiated using cron(1M) to periodically check the size of /var/adm/pacct. If the size exceeds
blocks, 500 by default, turnacct will be invoked with argument switch. To avoid a conflict with turnacct switch ex<hy>
ecution in runacct, do not run ckpacct and runacct simultaneously. If the number of free disk blocks in the /var file
system falls below 500, ckpacct will automatically turn off the collection of process accounting records via the off
argument to turnacct. When at least 500 blocks are restored, the accounting will be activated again on the next in<hy>
vocation of ckpacct. This feature is sensitive to the frequency at which ckpacct is executed, usually by the
cron(1M) command.
dodisk should be invoked by cron(1M) to perform the disk accounting functions.
lastlogin is invoked by runacct(1M) to update /var/adm/acct/sum/loginlog, which shows the last date on which
each person logged in.
monacct should be invoked once each month or each accounting period. number indicates which month or period it
is. If number is not given, it defaults to the current month (01<mi>12). This default is useful if monacct is to executed
using cron(1M) on the first day of each month. monacct creates summary files in /var/adm/acct/fiscal and restarts
the summary files in /var/adm/acct/sum.
nulladm creates filename with mode 664 and ensures that owner and group are adm. It is called by various account<hy>
ing shell procedures.
prctmp can be used to print the session record file (normally /var/adm/acct/nite/ctmp created by acctcon1 (see ac<hy>
ctcon(1M)).
prdaily is invoked by runacct(1M) to format a report of the previous day's accounting data. The report resides in
/var/adm/acct/sum/rprt/mmdd where mmdd is the month and day of the report. The current daily accounting re<hy>
ports may be printed by typing prdaily. Previous days' accounting reports can be printed by using the mmdd option
and specifying the exact report date desired.
prtacct can be used to format and print any total accounting (tacct)file.
shutacct is invoked during a system shutdown to turn process accounting off and append a reason record to
/var/adm/wtmpx.
startup can be invoked when the system is brought to a multi-user state to turn process accounting on.
<beginning of page>
turnacct is an interface to accton (see acct(1M)) to turn process accounting on or off. The switch argument moves
the current /var/adm/pacct to the next free name in /var/adm/pacct.incr (where incr is a number starting with 0 and
incrementing by one for each additional pacct file), then turns accounting back on again. This procedure is called
by ckpacct and thus can be taken care of by the cron(1M) command and used to keep pacct to a reasonable size.
shutacct uses turnacct to stop process accounting. startup uses turnacct to start process accounting.
The following options are supported:
-c This option prints a report of exceptional resource usage by command, and may be used on current day's account<hy>
ing data only.
-l This option prints a report of exceptional usage by login id for the specified date. Previous daily reports are
cleaned up and therefore inaccessible after each invocation of monacct.
-o This option uses acctdusg (see acct(1M)) to do a slower version of disk accounting by login directory. filenames
specifies the one or more filesystem names where disk accounting will be done. If filenames are used, disk account<hy>
ing will be done on these filesystems only. If the -o option is used, filenames should be mount points of mounted
filesystems. If the -o option is omitted, filenames should be the special file names of mountable filesystems.
/etc/logadm.conf Configuration file for the logadm(1M) command
/usr/lib/acct Holds all accounting commands listed in section 1M of this manual
/usr/lib/acct/ptecms.awk Contains the limits for exceptional usage by command name
/usr/lib/acct/ptelus.awk Contains the limits for exceptional usage by login ID
/var/adm/acct/fiscal Fiscal reports directory
/var/adm/acct/nite Working directory
/var/adm/acct/sum Summary directory that contains information for monacct
/var/adm/acct/sum/loginlog File updated by last login
/var/adm/fee Accumulator for fees
/var/adm/pacct Current file for per-process accounting
/var/adm/pacctincr Used if pacct gets large and during execution of daily accounting procedure
/var/adm/wtmpx History of user access and administration information
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Availability<hy>
SUNWaccu
<beginning of page>
acctcom(1), acct(1M), acctcms(1M), acctcon(1M), acctmerg(1M), acctprc(1M), cron(1M), fwtmp(1M), lo<hy>
gadm(1M), runacct(1M), acct(2), acct.h(3HEAD), utmpx(4), attributes(5)
See runacct(1M) for the main daily accounting shell script, which performs the accumulation of connect, process,
fee, and disk accounting on a daily basis. It also creates summaries of command usage.
acl.5 <beginning of page>
acl <-> Access Control Lists
Access control lists (ACLs) are discretionary access control mechanisms that grant and deny access to files and di<hy>
rectories. Two different ACL models are supported in the Solaris release:POSIX-draft ACLs and NFSv4 ACLs.
The older, POSIX-draft model is supported by the UFS file system. This model is based on a withdrawn ACL
POSIX specification that was never standardized. It was subsequently withdrawn by the POSIX committee.
The other model is based on the standards of the NFSv4 working group and is an approved standard from the Inter<hy>
net Engineering Task Force (IETF). The ZFS file system uses the NFSv4 model, and provides richer semantics and
finer grained permission capabilities than the POSIX-draft model.
POSIX-draft ACLs provide an alternative security mechanism to basic UNIX file permissions in the Solaris release.
Their purpose is to further restrict access to files and directories or to extend permissions to a particular user. ACLs
can be used to change the permissions for the standard owner, group and other class bits of a file's mode. ACLs can
give additional users and groups access to the file. A directory can also have a special kind of ACL called a default
ACL, which defines ACL entries to be inherited by descendents of the directory. POSIX-draft ACLs have an ACL
entry called mask. The mask defines the maximum permissions that can be granted to additional user and group en<hy>
tries. Whenever a file is created or its mode is changed by chmod(1) or chmod(2), the mask is recomputed. It is re<hy>
computed to be the group permission defined in the mode passed to chmod(2).
The POSIX-draft ACL model uses the standard rwx model of traditional UNIX permissions.
An ACL is represented as follows:
 acl_entry[,acl_entry]...
Each acl_entry contains one ACL entry. An ACL entry is represented by two or three colon-separated(:) fields.
user:[uid]:perms If uid blank, it represents the file owner.
group:[gid]:perms If gid is blank, it represents the owning group.
other:perms Represents the file other class.
mask:perms Defines the MAX permission to hand out.
For example to give user joe read and write permissions, the ACL entry is specified as:
 user:joe:rw-
NFSv4 ACL model is based loosely on the Windows NT ACL model. NFSv4 ACLs provide a much richer ACL
model than POSIX-draft ACLs.
The major differences between NFSv4 and POSIX-draft ACLs are as follows: <bu> NFSv4 ACLs provide finer grained
permissions than the rwx model. <bu> NFSv4 ACLs allow for both ALLOW and DENY entries. <bu> NFSv4 ACLs pro<hy>
vide a rich set of inheritance semantics. POSIX ACLs also have inheritance, but with the NFSv4 model you can con<hy>
trol the following inheritance features: <bu> Whether inheritance cascades to both files and directories or only to files or
directories. <bu> In the case of directories, you can indicate whether inheritance is applied to the directory itself, to just
one level of subdirectories, or cascades to all subdirectories of the directory. <bu> NFSv4 ACLs provide a mechanism
for hooking into a system's audit trail. Currently, Solaris does not support this mechanism. <bu> NFSv4 ACLs enable
adminstrators to specify the order in which ACL entries are checked. With POSIX-draft ACLs the file system re<hy>
orders ACL entries into a well defined, strict access, checking order.
POSIX-draft ACL semantics can be achieved with NFSv4 ACLs. However, only some NFSv4 ACLs can be translat<hy>
ed to equivalent POSIX-draft ACLs.
Permissions can be specified in three different chmod ACL formats: verbose, compact, or positional. The verbose
<beginning of page>
format uses words to indicate that the permissions are separated with a forward slash (/) character. Compact format
uses the permission letters and positional format uses the permission letters or the hypen (-) to identify no permis<hy>
sions.
The permissions for verbose mode and their abbreviated form in parentheses for compact and positional mode are
described as follows:
read_data (r) Permission to read the data of the file
list_directory (r) Permission to list the contents of a directory.
write_data (w) Permission to modify a file's data anywhere in the file's offset range. This includes the ability to
grow the file or write to any arbitrary offset.
add_file (w) Permission to add a new file to a directory.
append_data (p) The ability to modify the file's data, but only starting at EOF. Currently, this permission is not sup<hy>
ported.
add_subdirectory (p) Permission to create a subdirectory to a directory.
read_xattr (R) The ability to read the extended attributes of a file or do a lookup in the extended attributes directory.
write_xattr (W) The ability to create extended attributes or write to the extended attributes directory.
execute (x) Permission to execute a file.
read_attributes (a) The ability to read basic attributes (non-ACLs) of a file. Basic attributes are considered to be the
stat level attributes. Allowing this access mask bit means that the entity can execute ls(1) and stat(2).
write_attributes (A) Permission to change the times associated with a file or directory to an arbitrary value.
delete (d) Permission to delete the file.
delete_child (D) Permission to delete a file within a directory.
read_acl (c) Permission to read the ACL.
write_acl (C) Permission to write the ACL or the ability to execute chmod(1) or setfacl(1).
write_owner (o) Permission to change the owner or the ability to execute chown(1) or chgrp(1).
synchronize (s) Permission to access a file locally at the server with synchronous reads and writes. Currently, this
permission is not supported.
The following inheritance flags are supported by NFSv4:
file_inherit (f) Inherit to all newly created files in a directory.
<beginning of page>
dir_inherit (d) Inherit to all newly created directories in a directory.
inherit_only (i) Placed on a directory, but does not apply to the directory itself, only to newly created created files
and directories. This flag requires file_inherit and or dir_inherit to indicate what to inherit.
no_propagate (n) Placed on directories and indicates that ACL entries should only be inherited one level of the tree.
This flag requires file_inherit and or dir_inherit to indicate what to inherit.
successful_access (S)) Indicates if an alarm or audit record should be initiated upon successful accesses. Used with
audit/alarm ACE types.
failed_access (F) Indicates if an alarm or audit record should be initiated when access fails. Used with audit/alarm
ACE types.
inherited (I) ACE was inherited.
- No permission granted.
An NFSv4 ACL is expressed using the following syntax:
 acl_entry[,acl_entry]...
  owner@:<perms>[:inheritance flags]:<allow|deny>
  group@:<perms>[:inheritance flags]:<allow|deny>
  everyone@:<perms>[:inheritance flags]:<allow|deny>
  user:<username>[:inheritance flags]:<allow|deny>
  group:<groupname>[:inheritance flags]:<allow|deny>
owner@ File owner
group@ Group owner
user Permissions for a specific user
group Permissions for a specific group
Permission and inheritance flags are separated by a / character.
ACL specification examples:
 user:fred:read_data/write_data/read_attributes:file_inherit:allow
 owner@:read_data:allow,group@:read_data:allow,user:tom:read_data:deny
Using the compact ACL format, permissions are specified by using 14 unique letters to indicate permissions.
Using the positional ACL format, permissions are specified as positional arguments similar to the ls -V format. The
hyphen (-), which indicates that no permission is granted at that position, can be omitted and only the required letters
have to be specified.
The letters above are listed in the order they would be specified in positional notation.
<beginning of page>
With these letters you can specify permissions in the following equivalent ways.
 user:fred:rw------R------:file_inherit:allow
Or you can remove the - and scrunch it together.
 user:fred:rwR:file_inherit:allow
The inheritance flags can also be specified in a more compact manner, as follows:
 user:fred:rwR:f:allow
 user:fred:rwR:f------:allow
The Solaris command interface supports the manipulation of ACLs. The following Solaris utilities accommodate
both ACL models:
chmod The chmod utility has been enhanced to allow for the setting and deleting of ACLs. This is achieved by ex<hy>
tending the symbolic-mode argument to support ACL manipulation. See chmod(1) for details.
compress When a file is compressed any ACL associated with the original file is preserved with the compressed file.
cp By default, cp ignores ACLs, unless the -p option is specified. When -p is specified the owner and group id, per<hy>
mission modes, modification and access times, ACLs, and extended attributes if applicable are preserved.
cpio ACLs are preserved when the -P option is specified.
find Find locates files with ACLs when the -acl flag is specified.
ls By default ls does not display ACL information. When the -v option is specified, a file's ACL is displayed.
mv When a file is moved, all attributes are carried along with the renamed file. When a file is moved across a file
system boundary, the ACLs are replicated. If the ACL information cannot be replicated, the move fails and the
source file is not removed.
pack When a file is packed, any ACL associated with the original file is preserved with the packed file.
rcp rcp has been enhanced to support copying. A file's ACL is only preserved when the remote host supports ACLs.
tar ACLs are preserved when the -p option is specified.
unpack When a file with an ACL is unpacked, the unpacked file retains the ACL information.
The primary interfaces required to access file system ACLs at the programmatic level are the acl_get() and acl_set()
functions. These functions support both POSIX draft ACLs and NFSv4 ACLs.
 int acl_get(const char *path, int flag, acl_t **aclp);
 int facl_get(int fd, int flag, acl_t **aclp);
<beginning of page>
The acl_get(3SEC) and facl_get(3SEC) functions retrieves an ACL on a file whose name is given by path or refer<hy>
enced by the open file descriptor fd. The flag argument specifies whether a trivial ACL should be retrieved. When
the flag argument equals ACL_NO_TRIVIAL then only ACLs that are not trivial are retrieved. The ACL is re<hy>
turned in the aclp argument.
 void acl_free(acl_t *aclp)s;
The acl_free() function frees up memory allocated for the argument aclp;.
 int acl_set(const char *path, acl_t *aclp);
 int facl_set(int fd, acl_t *aclp);
The acl_set(3SEC) and facl_get(3SEC) functions are used for setting an ACL on a file whose name is given by path
or referenced by the open file descriptor fd. The aclp argument specifies the ACL to set. The acl_set(3SEC) trans<hy>
lates an POSIX-draft ACL into a NFSv4 ACL when the target file systems supports NFSv4 ACLs. No translation is
performed when trying to set an NFSv4 ACL on a POSIX-draft ACL supported file system.
 int acl_trivial(const char *path);
The acl_trivial() function is used to determine whether a file has a trivial ACL. The trivialness of a file's ACL de<hy>
pends on the type of ACL it is. For POSIX-draft ACLs, it implies the ACL has greater than MIN_ACL_ENTRIES.
For NFSv4/ZFS style ACLs, it implies that the ACL has entries other than owner@, group@ and everyone@, in<hy>
heritance flags are set, or the ACL is not ordered in a manner that meets POSIX access control requirements.
 int acl_strip(const char *path, uid_t uid, gid_t gid, mode_t mode);
The acl_strip() function removes all ACLs from a file and replaces them with a trivial ACL based off of the passed
in argument mode. After replacing the ACL the owner and group of the file are set to the values specified in the uid
and gid parameters.
 int acl_fromtext(const char *path, acl_t **aclp);
 char *acl_totext(acl_t *aclp, int flags);
The acl_text() function converts an internal ACL representation pointed to by aclp into an external representation.
See DESCRIPTION for details about external representation.
The acl_fromtext() functions converts and external representation into an internal representation. See DESCRIP<hy>
TION for details about external representation.
The following examples demonstrate how the API can be used to perform basic operations on ACLs. Example 1
Retrieving and Setting an ACL
Use the following to retrieve an ACL and set it on another file:
 error = acl_get("file", ACL_NO_TRIVIAL, &aclp);
 if (error == 0 && aclp != NULL) {
 error = acl_set("file2", aclp)
 acl_free(aclp);
 }
 ...
Example 2 Retrieving and Setting Any ACLs
Use the following to retrieve any ACL, including trivial ACLs, and set it on another file:
 error = acl_get("file3", 0, &aclp);
 if (error == 0) {
 error = acl_set("file4", aclp)
<beginning of page>
 acl_free(aclp);
 }
 ...
Example 3 Determining if a File has a Trivial ACL
Use the following to determine if a file has a trivial ACL:
 istrivial = acl_trivial("file")
 if (istrivial == 0)
 printf("file %s has a trivial ACL0, file);
 else
 printf("file %s has a NON-trivial ACL0, file);
 ...
Example 4 Removing all ACLs from a File
Use the following to remove all ACLs from a file, and set a new mode, owner, and group:
 error = acl_strip("file", 10, 100, 0644);
 ...
chgrp(1), chmod(1), chown(1), cp(1), cpio(1), find(1), ls(1), mv(1), tar(1), setfacl(1), chmod(2),
acl(2),stat(2),acl_get(3SEC), aclsort(3SEC), acl_fromtext(3SEC), acl_free(3SEC), acl_strip(3SEC), acl_triv<hy>
ial(3SEC)
aclcheck.3sec <beginning of page>
aclcheck <-> check the validity of an ACL
cc [ flag... ] file... -lsec [ library... ]
#include <sys/acl.h>
int aclcheck(aclent_t *aclbufp, int nentries, int *which);
The aclcheck() function checks the validity of an ACL pointed to by aclbufp. The nentries argument is the number
of entries contained in the buffer. The which parameter returns the index of the first entry that is invalid.
The function verifies that an ACL pointed to by aclbufp is valid according to the following rules: <bu> There must be
exactly one GROUP_OBJ ACL entry. <bu> There must be exactly one USER_OBJ ACL entry. <bu> There must be ex<hy>
actly one OTHER_OBJ ACL entry. <bu> If there are any GROUP ACL entries, then the group ID in each group ACL
entry must be unique. <bu> If there are any USER ACL entries, then the user ID in each user ACL entry must be
unique. <bu> If there are any GROUP or USER ACL entries, then there must be exactly one CLASS_OBJ (ACL
mask) entry. <bu> If there are any default ACL entries, then the following apply: <bu> There must be exactly one default
GROUP_OBJ ACL entry. <bu> There must be exactly one default OTHER_OBJ ACL entry. <bu> There must be exactly
one default USER_OBJ ACL entry. <bu> If there are any DEF_GROUP entries, then the group ID in each
DEF_GROUP ACL entry must be unique. <bu> If there are any DEF_USER entries, then the user ID in each
DEF_USER ACL entry must be unique. <bu> If there are any DEF_GROUP or DEF_USER entries, then there must
be exactly one DEF_CLASS_OBJ (default ACL mask) entry. <bu> If any of the above rules are violated, then the
function fails with errno set to EINVAL.
If the ACL is valid, alcheck() will return 0. Otherwise errno is set to EINVAL and return code is set to one of the
following:
GRP_ERROR There is more than one GROUP_OBJ or DEF_GROUP_OBJ ACL entry.
USER_ERROR There is more than one USER_OBJ or DEF_USER_OBJ ACL entry.
CLASS_ERROR There is more than one CLASS_OBJ (ACL mask) or DEF_CLASS_OBJ (default ACL mask)
entry.
OTHER_ERROR There is more than one OTHER_OBJ or DEF_OTHER_OBJ ACL entry.
DUPLICATE_ERROR Duplicate entries of USER, GROUP, DEF_USER, or DEF_GROUP.
ENTRY_ERROR The entry type is invalid.
MISS_ERROR Missing an entry. The which parameter returns <mi>1 in this case.
MEM_ERROR The system cannot allocate any memory. The which parameter returns <mi>1 in this case.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyEvolving _ MT-LevelUnsafe
acl(2), aclsort(3SEC), attributes(5)
acl_get.3sec <beginning of page>
acl_get, facl_get, acl_set, facl_set <-> get or set a file's Access Control List (ACL)
cc [ flag... ] file... -lsec [ library... ]
#include <sys/acl.h>
int *acl_get(const char *path, int flag, acl_t **aclp);
int *facl_get(int fd, int flag, acl_t **aclp);
int acl_set(const char *path, acl_t *aclp);
int facl_set(int fd, acl_t *aclp);
The acl_get() and facl_get() functions retrieve an Access Control List (ACL) of a file whose name is given by path
or referenced by the open file descriptor fd. The flag argument specifies whether a trivial ACL should be retrieved.
When the flag argument is ACL_NO_TRIVIAL, only ACLs that are not trivial will be retrieved. The ACL is re<hy>
turned in the aclp argument.
The acl_set() and facl_set() functions are used for setting an ACL of a file whose name is given by path or refer<hy>
enced by the open file descriptor fd. The aclp argument specifies the ACL to set.
The acl_get() and acl_set() functions support multiple types of ACLs. When possible, the acl_set() function trans<hy>
lates an ACL to the target file's style of ACL. Currently this is only possible when translating from a POSIX-draft
ACL such as on UFS to a file system that supports NFSv4 ACL semantics such as ZFS or NFSv4.
Upon successful completion, acl_get() and facl_get() return 0 and aclp is non-NULL. The aclp argument can be
NULL after successful completion if the file had a trivial ACL and the flag argument was ACL_NO_TRIVIAL.
Otherwise, -1 is returned and errno is set to indicate the error.
Upon successful completion, acl_set() and facl_set() return 0. Otherwise, -1 is returned and errno is set to indicate
the error.
These functions will fail if:
EACCES The caller does not have access to a component of path.
EIO A disk I/O error has occured while retrieving the ACL.
ENOENT A component of the path does not exist.
ENOSYS The file system does not support ACLs.
ENOTSUP The ACL supplied could not be translated to an NFSv4 ACL.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyEvolving _ MT-LevelMT-Safe
chmod(1), acl(2), acl(5), attributes(5)
acl_strip.3sec <beginning of page>
acl_strip <-> remove all ACLs from a file
cc [ flag... ] file... -lsec [ library... ]
#include <sys/acl.h>
int acl_strip(const char *path, uid_t uid, gid_t gid, mode_t mode);
The acl_strip() function removes all ACLs from a file and replaces them with a trivial ACL based on the mode argu<hy>
ment. After replacing the ACL, the owner and group of the file are set to the values specified by the uid and gid argu<hy>
ments.
Upon successful completion, acl_strip() returns 0. Otherwise it returns -1 and sets errno to indicate the error.
The acl_strip() function will fail if:
EACCES Search permission is denied on a component of the path prefix of path.
EFAULT The path argument points to an illegal address.
EINVAL The uid or gid argument is out of range.
EIO A disk I/O error has occurred while storing or retrieving the ACL.
ELOOP A loop exists in symbolic links encountered during the resolution of the path argument.
ENAMETOOLONG The length of the path argument exceeds {PATH_MAX}, or the length of a path compo<hy>
nent exceeds {NAME_MAX} while _POSIX_NO_TRUNC is in effect.
ENOENT A component of path does not exist.
ENOTDIR A component of the prefix of path is not a directory.
EPERM The effective user ID does not match the owner of the file and the process does not have appropriate privi<hy>
leges.
EROFS The file system is mounted read-only.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyEvolving _ MT-LevelMT-Safe
acl_get(3SEC), acl_trivial(3SEC), acl(5), attributes(5)
acl_totext.3sec <beginning of page>
acl_totext, acl_fromtext <-> convert internal representation to or from external representation
cc [ flag... ] file... -lsec [ library... ]
#include <sys/acl.h>
char *acl_totext(acl_t *aclp, int flags);
int acl_fromtext(char *acltextp, acl_t **aclp);
The acl_totext() function converts an internal ACL representation pointed to by aclp into an external ACL represen<hy>
tation. The memory for the external text string is obtained using malloc(3C). The caller is responsible for freeing the
memory upon completion.
The format of the external ACL is controlled by the flags argument. Values for flags are constructed by a bitwise-in<hy>
clusive-OR of flags from the following list, defined in <sys/acl.h>.
ACL_COMPACT_FMT For NFSv4 ACLs, the ACL entries will be formatted using the compact ACL format de<hy>
tailed in ls(1) for the -V option.
ACL_APPEND_ID Append the uid or gid for additional user or group entries. This flag is used to construt ACL
entries in a manner that is suitable for archive utilities such as tar(1). When the ACL is translated from the external
format to internal representation using acl_fromtext(), the appended ID will be used to populate the uid or gid field
of the ACL entry when the user or group name does not exist on the host system. The appended id will be ignored
when the user or group name does exist on the system.
ACL_SID_FMT For NFSv4 ACLs, the ACL entries for user or group entries will use the usersid or groupsid for<hy>
mat when the "id" field in the ACL entry is an ephemeral uid or gid. The raw sid format will only be used when the
"id" cannot be resolved to a windows name.
The acl_fromtext() function converts an external ACL representation pointed to by acltextp into an internal ACL
representation. The memory for the list of ACL entries is obtained using malloc(3C). The caller is responsible for
freeing the memory upon completion. Depending on type of ACLs a file system supports, one of two external exter<hy>
nal representations are possible. For POSIX draft file systems such as ufs, the external representation is described in
acltotext(3SEC). The external ACL representation For NFSv4-style ACLs is detailed as follows.
Each acl_entry contains one ACL entry. The external representation of an ACL entry contains three, four or five
colon separated fields. The first field contains the ACL entry type. The entry type keywords are defined as:
everyone@ This ACL entry specifies the access granted to any user or group that does not match any previous ACL
entry.
group This ACL entry with a GID specifies the access granted to a additional group of the object.
group@ This ACL entry with no GID specified in the ACL entry field specifies the access granted to the owning
group of the object.
groupsid This ACL entry with a SID or Windows name specifies the access granted to a Windows group. This type
of entry is for a CIFS server created file.
owner@ This ACL entry with no UID specified in the ACL entry field specifies the access granted to the owner of
the object.
sid This ACL entry with a SID or Windows name when the entry could be either a group or a user.
user This ACL entry with a UID specifies the access granted to a additional user of the object.
<beginning of page>
usersid This ACL entry with a SID or Windows name specifies the access granted to a Windows user. This type of
entry is for a CIFS server created file.
The second field contains the ACL entry ID, and is used only for user or group ACL entries. This field is not used
for owner@, group@, or everyone@ entries.
uid This field contains a user-name or user-ID. If the user-name cannot be resolved to a UID, then the entry is as<hy>
sumed to be a numeric UID.
gid This field contains a group-name or group-ID. If the group-name can't be resolved to a GID, then the entry is as<hy>
sumed to be a numeric GID.
The third field contains the discretionary access permissions. The format of the permissions depends on whether
ACL_COMPACT_FMT is specified. When the flags field does not request ACL_COMPACT_FMT, the following
format is used with a forward slash (/) separating the permissions.
add_file Add a file to a directory.
add_subdirectory Add a subdirectory.
append Append data.
delete Delete.
delete_child Delete child.
execute Execute permission.
list_directory List a directory.
read_acl Read ACL.
read_data Read permission.
read_attributes Read attributes.
read_xattr Read named attributes.
synchronize Synchronize.
write_acl Write ACL.
write_attributes Write attributes.
write_data Write permission.
write_owner Write owner.
<beginning of page>
write_xattr Write named attributes.
This format allows permissions to be specified as, for example: read_data/read_xattr/read_attributes.
When ACL_COMPACT_FMT is specified, the permissions consist of 14 unique letters. A hyphen (-) character is
used to indicate that the permission at that position is not specified.
a read attributes
A write attributes
c read ACL
C write ACL
d delete
D delete child
o write owner
p append
r read_data
R read named attributes
s synchronize
w write_data
W write named attributes
x execute
This format allows compact permissions to be represented as, for example: rw--d-a-------
The fourth field is optional when ACL_COMPACT_FMT is not specified, in which case the field will be present
only when the ACL entry has inheritance flags set. The following is the list of inheritance flags separated by a slash
(/) character.
dir_inherit ACE_DIRECTORY_INHERIT_ACE
file_inherit ACE_FILE_INHERIT_ACE
inherit_only ACE_INHERIT_ONLY_ACE
<beginning of page>
no_propagate ACE_NO_PROPAGATE_INHERIT_ACE
When ACL_COMPACT_FMT is specified the inheritance will always be present and is represented as positional
arguments. A hyphen (-) character is used to indicate that the inheritance flag at that position is not specified.
d dir_inherit
f file_inherit
F failed access (not currently supported)
i inherit_only
n no_propagate
S successful access (not currently supported)
The fifth field contains the type of the ACE (allow or deny):
allow The mask specified in field three should be allowed.
deny The mask specified in field three should be denied.
Upon successful completion, the acl_totext() function returns a pointer to a text string. Otherwise, it returns NULL.
Upon successful completion, the acl_fromtext() function returns 0. Otherwise, the return value is set to one of the
following:
EACL_FIELD_NOT_BLANK A field that should be blank is not blank.
EACL_FLAGS_ERROR An invalid ACL flag was specified.
EACL_INHERIT_ERROR An invalid inheritance field was specified.
EACL_INVALID_ACCESS_TYPE An invalid access type was specified.
EACL_INVALID_STR The string is NULL.
EACL_INVALID_USER_GROUP The required user or group name not found.
EACL_MISSING_FIELDS The ACL needs more fields to be specified.
EACL_PERM_MASK_ERROR The permission mask is invalid.
EACL_UNKNOWN_DATA Unknown data was found in the ACL.
Example 1 Examples of permissions when ACL_COMPACT_FMT is not specified.
 user:joe:read_data/write_data:file_inherit/dir_inherit:allow
<beginning of page>
 owner@:read_acl:allow,user:tom:read_data:file_inherit/inherit_only:deny
Example 2 Examples of permissions when ACL_COMPACT_FMT is specified.
 user:joe:rw------------:fd----:allow
 owner@:----------c---:------allow,user:tom:r-------------:f-i---:deny
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelSafe
ls(1), tar(1), acl(2), malloc(3C), aclfromtext(3SEC), acl(5), attributes(5)
acl_trivial.3sec <beginning of page>
acl_trivial <-> determine whether a file has a trivial ACL
cc [ flag... ] file... -lsec [ library... ]
#include <sys/acl.h>
int acl_trivial(char *path);
The acl_trivial() function is used to determine whether a file has a trivial ACL. Whether an ACL is trivial depends
on the type of the ACL. A POSIX draft ACL is trivial if it has greater than MIN_ACL_ENTRIES. An NFSv4/ZFS-
style ACL is trivial if it either has entries other than owner@, group@, and everyone@, has inheritance flags set, or
is not ordered in a manner that meets POSIX access control requirements.
Upon successful completion, acl_trivial() returns 0 if the file's ACL is trivial and 1 if the file's ACL is not trivial. If
it could not be determined whether a file's ACL is trivial, -1 is returned and errno is set to indicate the error.
The acl_trivial() function will fail if:
EACCES A file's ACL could not be read.
ENOENT A component of path does not name an existing file or path is an empty string.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyEvolving _ MT-LevelMT-Safe
acl(5), attributes(5)
acosh.3m <beginning of page>
acosh, acoshf, acoshl <-> inverse hyperbolic cosine functions
c99 [ flag... ] file... -lm [ library... ]
#include <math.h>
double acosh(double x);
float acoshf(float x);
long double acoshl(long double x);
These functions compute the inverse hyperbolic cosine of their argument x.
Upon successful completion, these functions return the inverse hyperbolic cosine of their argument.
For finite values of x < 1, a domain error occurs and NaN is returned.
If x is NaN, NaN is returned.
If x is +1, +0 is returned.
If x is +Inf, +Inf is returned.
If x is <mi>Inf, a domain error occurs and NaN is returned.
For exceptional cases, matherr(3M) tabulates the values to be returned by acosh() as specified by SVID3 and
XPG3.
These functions will fail if:
Domain Error The x argument is finite and less than 1.0, or is <mi>Inf.
If the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, the invalid floating-point ex<hy>
ception is raised.
The acosh() function sets errno to EDOM if x is less than 1.0.
An application wanting to check for exceptions should call feclearexcept(FE_ALL_EXCEPT) before calling these
functions. On return, if fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDER<hy>
FLOW) is non-zero, an exception has been raised. An application should either examine the return value or check
the floating point exception flags to detect exceptions.
An application can also set errno to 0 before calling acosh(). On return, if errno is non-zero, an error has occurred.
The acoshf() and acoshl() functions do not set errno.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
cosh(3M), feclearexcept(3M), fetestexcept(3M), math.h(3HEAD), matherr(3M), attributes(5), standards(5)
adb.1 <beginning of page>
adb <-> general-purpose debugger
adb [-kw] [-I dir] [-P prompt] [-V mode] [object [core]]
The adb utility is an interactive, general-purpose debugger. It can be used to examine files and provides a controlled
environment for the execution of programs.
The adb utility is now implemented as a link to the mdb(1) utility. mdb(1) is a low-level debugging utility that can
be used to examine user processes as well as the live operating system or operating system crash dumps. The new
mdb(1) utility provides complete backwards compatibility with the existing syntax and features of adb, including
support for processing adb macro files. The Solaris Modular Debugger Guide and mdb(1) man page describes the
features of mdb, including its adb compatibility mode. This mode will be activated by default when the adb link is
executed.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wmdb
mdb(1), attributes(5)
Solaris Modular Debugger Guide
add_allocatable.1m <beginning of page>
add_allocatable <-> add entries to allocation databases
/usr/sbin/add_allocatable [-f] [-s] [-d] -n name -t type -l device-list
 [-a authorization] [-c clean] [-o key=value]
add_allocatable creates new entries for user allocatable devices that are to be managed by the device allocation
mechanism. add_allocatable can also be used to update existing entries of such devices.
add_allocatable can also create and update entries for non-allocatable devices, such as printers, whose label range is
managed by the device allocation mechanism.
add_allocatable can be used in shell scripts, such as installation scripts for driver packages, to automate the admin<hy>
istrative work of setting up a new device.
Use list_devices(1) to see the names and types of allocatable devices, their attributes, and device paths.
-f Force an update of an already-existing entry with the specified information. add_allocatable exits with an error if
this option is not specified when an entry with the specified device name already exists.
-s Turn on silent mode. add_allocatable does not print any error or warning messages.
-d If this option is present, add_allocatable updates the system-supplied default attributes of the device type speci<hy>
fied with -t.
-n name Adds or updates an entry for device that is specified by name.
-t type Adds or updates device entries that are of a type that are specified by type.
-l device-list Adds or updates device paths to the device that is specified with -n. Multiple paths in device-list must
be separated by white spaces and the list must be quoted.
-a authorization Adds or updates the authorization that is associated with either the device that is specified with -n
or with devices of the type that is specified with -t. When more than one authorization is specified, the list must be
separated by commas and must be quoted. When the device is not allocatable, authorization is specified with an as<hy>
terisk (*) and must be quoted. When the device is allocatable by any user, authorization is specified with the at sign
(@) and must be quoted. Default authorization is '@'.
-c clean Specifies the device_clean(5) program clean to be used with the device that is specified with -n or with de<hy>
vices of the type that is specified with -t. The default clean program is /bin/true.
-o key=value Accepts a string of colon-separated key=value pairs for a device that is specified with -n or with de<hy>
vices of the type that is specified with -t. The following keys are currently interpreted by the system:
minlabel The minimum label at which the device can be used.
maxlabel The maximum label at which the device can be used.
class Specifies a logical grouping of devices. For example, all Sun RayTM devices of all device types is a logical
grouping. The class keyword has no default value.
xdpy Specifies the display name of the X session. This keyword is used to identify devices that are associated with
the X session. The xdpy keyword has no default value.
<beginning of page>
When successful, add_allocate returns an exit status of 0 (true). add_allocate returns a nonzero exit status in the
event of an error. The exit codes are as follows:
1 Invocation syntax error
2 Unknown system error
3 An entry already exists for the specified device. This error occurs only when the -f option is not specified.
4 Permission denied. User does not have DAC or MAC access record updates.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.82i) |cw(2.68i) lw(2.82i) |lw(2.68i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Availability<hy>
SUNWtsu _ Interface StabilitySee below.
The invocation is Uncommitted. The options are Uncommitted. The output is Not-an-Interface.
allocate(1), deallocate(1), list_devices(1), remove_allocatable(1M), attributes(5), device_clean(5)
The functionality described on this manual page is available only if the system is configured with Trusted Exten<hy>
sions.
addbib.1 <beginning of page>
addbib <-> create or extend a bibliographic database
addbib [-a] [-p promptfile] database
When addbib starts up, answering y to the initial Instructions? prompt yields directions. Typing n (or RETURN)
skips the directions. addbib then prompts for various bibliographic fields, reads responses from the terminal, and
sends output records to database. A null response (just RETURN) means to leave out that field. A `<mi>' (minus sign)
means to go back to the previous field. A trailing backslash allows a field to be continued on the next line. The re<hy>
peating Continue? prompt allows the user either to resume by typing y (or RETURN), to quit the current session by
typing n or q, or to edit database with any system editor (see vi(1), ex(1), ed(1)).
The following options are supported:
-a Suppresses prompting for an abstract. Asking for an abstract is the default. Abstracts are ended with a Control<mi>D.
-p promptfile Uses a new prompting skeleton, defined in promptfile. This file should contain prompt strings, a TAB,
and the key-letters to be written to the database.
The most common key-letters and their meanings are given below. addbib insulates you from these key-letters,
since it gives you prompts in English, but if you edit the bibliography file later on, you will need to know this infor<hy>
mation.
%A Author's name
%B Book containing article referenced
%C City (place of publication)
%D Date of publication
%E Editor of book containing article referenced
%F Footnote number or label (supplied by refer)
%G Government order number
%H Header commentary, printed before reference
%I Issuer (publisher)
%J Journal containing article
%K Keywords to use in locating reference
%L Label field used by -k option of refer
%M Bell Labs Memorandum (undefined)
%N Number within volume
<beginning of page>
%O Other commentary, printed at end of reference
%P Page number(s)
%Q Corporate or Foreign Author (unreversed)
%R Report, paper, or thesis (unpublished)
%S Series title
%T Title of article or book
%V Volume number
%X Abstract <em> used by roffbib, not by refer
%Y,Z Ignored by refer
Example 1 Editing the bibliography file
Except for A, each field should be given just once. Only relevant fields should be supplied.
 %A Mark Twain
 %T Life on the Mississippi
 %I Penguin Books
 %C New York
 %D 1978
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wdoc
ed(1), ex(1), indxbib(1), lookbib(1), refer(1), roffbib(1), sortbib(1), vi(1), attributes(5)
addchstr.3xcurses <beginning of page>
addchstr, addchnstr, mvaddchstr, mvaddchnstr, mvwaddchnstr, mvwaddchstr, waddchstr, waddchnstr <-> copy a char<hy>
acter string (with renditions) to a window
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library ... ]
#include <curses.h>
int addchstr(const chtype *chstr);
int addchnstr(const chtype *chstr, int n);
int mvaddchnstr(int y, int x, const chtype *chstr, int n);
int mvaddchstr(int y, int x, const chtype *chstr);
int mvwaddchnstr(WINDOW *win, int y, int x, const chtype *chstr, int n);
int mvwaddchstr(WINDOW *win, int y, int x, const chtype *chstr);
int waddchstr(WINDOW *win, const chtype *chstr);
int waddchnstr(WINDOW *win, const chtype *chstr, int n);
The addchstr() function copies the chtype character string to the stdscr window at the current cursor position. The
mvaddchstr() and mvwaddchstr() functions copy the character string to the starting position indicated by the x
(column) and y (row) parameters (the former to the stdscr window; the latter to window win). The waddchstr() is
identical to addchstr(), but writes to the window specified by win.
The addchnstr(), waddchnstr(), mvaddchnstr(), and mvwaddchnstr() functions write n characters to the win<hy>
dow, or as many as will fit on the line. If n is less than 0, the entire string is written, or as much of it as fits on the
line. The former two functions place the string at the current cursor position; the latter two commands use the posi<hy>
tion specified by the x and y parameters.
These functions differ from the addstr(3XCURSES) set of functions in two important respects. First, these func<hy>
tions do not advance the cursor after writing the string to the window. Second, the current window rendition is not
combined with the character; only the attributes that are already part of the chtype character are used.
chstr Is a pointer to the chtype string to be copied to the window.
n Is the maximum number of characters to be copied from chstr. If n is less than 0, the entire string is written or as
much of it as fits on the line.
y Is the y (row) coordinate of the starting position of chstr in the window.
x Is the x (column) coordinate of the starting position of chstr in the window.
win Is a pointer to the window to which the string is to be copied.
On success, these functions return OK. Otherwise, they return ERR.
None.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
<beginning of page>
addch(3XCURSES), addnstr(3XCURSES), attroff(3XCURSES), libcurses(3XCURSES), attributes(5), stan<hy>
dards(5)
addnstr.3xcurses <beginning of page>
addnstr, addstr, mvaddnstr, mvaddstr, mvwaddnstr, mvwaddstr, waddnstr, waddstr <-> add a multi-byte character string
(without rendition) to a window
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library ... ]
#include <curses.h>
int addnstr(const char *str, int n);
int addstr(const char *str);
int mvaddnstr(int y, int x, const char *str, int n);
int mvaddstr(int y, int x, const char *str);
int mvwaddnstr(WINDOW *win, int y, int x, const char *str, int n);
int mvwaddstr(WINDOW *win, int y, int x, const char *str);
int waddstr(WINDOW *win, const char *str);
int waddnstr(WINDOW *win, const char *str, int n);
The addstr() function writes a null-terminated string of multi-byte characters to the stdscr window at the current
cursor position. The waddstr() function performs an identical action, but writes the character to the window speci<hy>
fied by win. The mvaddstr() and mvwaddstr() functions write the string to the position indicated by the x (col<hy>
umn) and y (row) parameters (the former to the stdscr window; the latter to window win).
The addnstr(), waddnstr(), mvaddnstr(), and mvwaddnstr() functions are similar but write at most n characters
to the window. If n is less than 0, the entire string is written.
All of these functions advance the cursor after writing the string.
These functions are functionally equivalent to calling the corresponding function from the addch(3XCURSES) set
of functions once for each character in the string. Refer to the curses(3XCURSES) man page for a complete de<hy>
scription of special character handling and of the interaction between the window rendition (or background charac<hy>
ter and rendition) and the character written.
Note that these functions differ from the addchstr() set of functions in that the addchstr(3XCURSES) functions
copy the string as is (without combining each character with the window rendition or the background character and
rendition.
str Is a pointer to the character string that is to be written to the window.
n Is the maximum number of characters to be copied from str. If n is less than 0, the entire string is written or as
much of it as fits on the line.
y Is the y (row) coordinate of the starting position of str in the window.
x Is the x (column) coordinate of the starting position of str in the window.
win Is a pointer to the window in which the string is to be written.
On success, these functions return OK. Otherwise, they return ERR.
None.
See attributes(5) for descriptions of the following attributes:
<beginning of page>
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
addch(3XCURSES), addchstr(3XCURSES), curses(3XCURSES), libcurses(3XCURSES), attributes(5), stan<hy>
dards(5)
addsev.3c <beginning of page>
addsev <-> define additional severities
#include <pfmt.h>
int addsev(int int_val, const char *string);
The addsev() function defines additional severities for use in subsequent calls to pfmt(3C) or lfmt(3C). It associates
an integer value int_val in the range [5-255] with a character string, overwriting any previous string association be<hy>
tween int_val and string.
If int_val is OR-ed with the flags argument passed to subsequent calls to pfmt() or lfmt(), string will be used as
severity. Passing a null string removes the severity.
Upon successful completion, addsev() returns 0. Otherwise it returns<mi>1.
Only the standard severities are automatically displayed for the locale in effect at runtime. An application must pro<hy>
vide the means for displaying locale-specific versions of add-on severities. Add-on severities are only effective with<hy>
in the applications defining them. Example 1 Example of addsev() function.
The following example
 #define Panic 5
 setlabel("APPL");
 setcat("my_appl");
 addsev(Panic, gettxt(":26", "PANIC"));
 /* ... */
 lfmt(stderr, MM_SOFT|MM_APPL|PANIC, ":12:Cannot locate database\n");
will display the message to stderr and forward to the logging service
 APPL: PANIC: Cannot locate database
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT-LevelMT-safe
gettxt(3C), lfmt(3C), pfmt(3C), attributes(5)
add_wch.3xcurses <beginning of page>
add_wch, mvadd_wch, mvwadd_wch, wadd_wch <-> add a complex character (with rendition) to a window
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library ... ]
#include <curses.h>
int add_wch(const cchar_t *wch);
int wadd_wch(WINDOW *win, const cchar_t *wch);
int mvadd_wch(int y, int x, const cchar_t *wch);
int mvwadd_wch(WINDOW *win, int y, int x, const cchar_t *wch);
The add_wch() function writes a complex character to the stdscr window at the current cursor position. The
mvadd_wch() and mvwadd_wch() functions write the character to the position indicated by the x (column) and y
(row) parameters. The mvadd_wch() function writes the character to the stdscr window, while mvwadd_wch()
writes the character to the window specified by win. The wadd_wch() function is identical to add_wch(), but
writes the character to the window specified by win. These functions advance the cursor after writing the character.
If wch is a spacing complex character, X/Open Curses replaces any previous character at the specified location with
wch (and its rendition). If wch is a non-spacing complex character, X/Open Curses preserves all existing characters
at the specified location and adds the non-spacing characters of wch to the spacing complex character. It ignores the
rendition associated with wch.
Characters that do not fit on the end of the current line are wrapped to the beginning of the next line unless the cur<hy>
rent line is the last line of the window and scrolling is disabled. In that situation, X/Open Curses discards characters
which extend beyond the end of the line.
When wch is a backspace, carriage return, newline, or tab, X/Open Curses moves the cursor appropriately as de<hy>
scribed in the curses(3XCURSES) man page. Each tab character moves the cursor to the next tab stop. By default,
tab stops occur every eight columns. When wch is a control character other than a backspace, carriage return, new<hy>
line, or tab, it is written using ^x notation, where x is a printable character. When X/Open Curses writes wch to the
last character position on a line, it automatically generates a newline. When wch is written to the last character posi<hy>
tion of a scrolling region and scrollok() is enabled, X/Open Curses scrolls the scrolling region up one line (see
clearok(3XCURSES)).
wch Is the character/attribute pair (rendition) to be written to the window.
win Is a pointer to the window in which the character is to be written.
y Is the y (row) coordinate of the character's position in the window.
x Is the x (column) coordinate of the character's position in the window.
On success, these functions return OK. Otherwise, they return ERR.
None.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
attr_off(3XCURSES), bkgrndset(3XCURSES), curses(3XCURSES), doupdate(3XCURSES), in_wch(3XCURS<hy>
ES), ins_wch(3XCURSES), libcurses(3XCURSES), nl(3XCURSES), printw(3XCURSES), scrollok(3XCURS<hy>
<beginning of page>
ES), scrl(3XCURSES), setscrreg(3XCURSES), terminfo(4), attributes(5), standards(5)
adjmsg.9f <beginning of page>
adjmsg <-> trim bytes from a message
#include <sys/stream.h>
int adjmsg(mblk_t *mp, ssize_t len);
Architecture independent level 1 (DDI/DKI).
mp Pointer to the message to be trimmed.
len The number of bytes to be removed.
The adjmsg() function removes bytes from a message. |len| (the absolute value of len) specifies the number of bytes
to be removed. The adjmsg() function only trims bytes across message blocks of the same type.
The adjmsg() function finds the maximal leading sequence of message blocks of the same type as that of mp and
starts removing bytes either from the head of that sequence or from the tail of that sequence. If len is greater than 0,
adjmsg() removes bytes from the start of the first message block in that sequence. If len is less than 0, it removes
bytes from the end of the last message block in that sequence.
The adjmsg() function fails if |len| is greater than the number of bytes in the maximal leading sequence it finds.
The adjmsg() function may remove any except the first zero-length message block created during adjusting. It may
also remove any zero-length message blocks that occur within the scope of |len|.
The adjmsg() function returns:
1 Successful completion.
0 An error occurred.
The adjmsg() function can be called from user, interrupt, or kernel context.
STREAMS Programming Guide
admin.4 <beginning of page>
admin <-> installation defaults file
admin is a generic name for an ASCII file that defines default installation actions by assigning values to installation
parameters. For example, it allows administrators to define how to proceed when the package being installed already
exists on the system.
/var/sadm/install/admin/default is the default admin file delivered with this release. The default file is not
writable, so to assign values different from this file, create a new admin file. There are no naming restrictions for
admin files. Name the file when installing a package with the -a option of pkgadd(1M). If the -a option is not used,
the default admin file is used.
Each entry in the admin file is a line that establishes the value of a parameter in the following form:
param=value
All of the parameters listed below can be defined in an admin file, but it is not required to assign values to all of
these. If a value is not assigned, pkgadd(1M) asks the installer how to proceed.
The valid parameters and their possible values are shown below except as noted. They can be specified in any order.
Any of these parameters (except the mail and proxy parameters) can be assigned the value ask, which means that,
when the parameter is reached during the installation sequence, the installer is notified and asked to supply instruc<hy>
tions (see NOTES).
basedir Indicates the base directory where relocatable packages are to be installed. If there is no basedir entry in the
file, the installer will be prompted for a path name, as if the file contained the entry basedir=ask. This parameter can
also be set to default (entry is basedir=default). In this instance, the package is installed into the base directory
specified by the BASEDIR parameter in the pkginfo(4) file.
mail Defines a list of users to whom mail should be sent following installation of a package. If the list is empty, no
mail is sent. If the parameter is not present in the admin file, the default value of root is used. The ask value cannot
be used with this parameter.
runlevel Indicates resolution if the run level is not correct for the installation or removal of a package. Options are:
nocheck Do not check for run level.
quit Abort installation if run level is not met.
conflict Specifies what to do if an installation expects to overwrite a previously installed file, thus creating a conflict
between packages. Options are:
nocheck Do not check for conflict; files in conflict will be overwritten.
quit Abort installation if conflict is detected.
nochange Override installation of conflicting files; they will not be installed.
setuid Checks for executables which will have setuid or setgid bits enabled after installation. Options are:
nocheck Do not check for setuid executables.
quit Abort installation if setuid processes are detected.
nochange Override installation of setuid processes; processes will be installed without setuid bits enabled.
<beginning of page>
action Determines if action scripts provided by package developers contain possible security impact. Options are:
nocheck Ignore security impact of action scripts.
quit Abort installation if action scripts may have a negative security impact.
partial Checks to see if a version of the package is already partially installed on the system. Options are:
nocheck Do not check for a partially installed package.
quit Abort installation if a partially installed package exists.
instance Determines how to handle installation if a previous version of the package (including a partially installed
instance) already exists. Options are:
quit Exit without installing if an instance of the package already exists (does not overwrite existing packages).
overwrite Overwrite an existing package if only one instance exists. If there is more than one instance, but only one
has the same architecture, it overwrites that instance. Otherwise, the installer is prompted with existing instances and
asked which to overwrite.
unique Do not overwrite an existing instance of a package. Instead, a new instance of the package is created. The
new instance will be assigned the next available instance identifier.
idepend Controls resolution if the package to be installed depends on other packages and if other packages depend
on the one to be installed. Options are:
nocheck Do not check package dependencies.
quit Abort installation if package dependencies are not met.
rdepend Controls resolution if other packages depend on the package to be removed. Also determines behavior if
registered products components to be removed. See libwsreg(3LIB) and prodreg(1M) for a definition of product
components. Options are:
nocheck Do not check package or product dependencies.
quit Abort removal if package or product dependencies are not met.
space Controls resolution if disk space requirements for package are not met. Options are:
nocheck Do not check space requirements (installation fails if it runs out of space).
quit Abort installation if space requirements are not met.
<beginning of page>
authentication Controls resolution when a datastream package with signature is to be installed. Options are:
nocheck Do not verify package signature. This also disables the use of the Online Certificate Status Protocol (OC<hy>
SP) to validate the package's signing certificate.
quit Abort installation if package signature cannot be verified.
networktimeout Number of seconds to wait before giving up a network connection when downloading a package.
This entry must be a positive integer. If not present, the default value of 60 is used.
networkretries Number of times to retry a failed network connection when downloading a package. This entry must
be a positive integer. If not present, the default value of 5 is used.
keystore Location of trusted certificates used when downloading packages over SSL and when verifying signatures
on packages. This is the base directory of the certificate location for trusted certificates used when validating digital
signatures on packages. For example, if this setting is /var/sadm/security, then pkgadd will use /var/sadm/securi<hy>
ty/pkgadd/truststore, then /var/sadm/security/truststore when searching for trusted certificates. See KEYSTORE
LOCATIONS and KEYSTORE AND CERTIFICATE FORMATS in pkgadd(1M) for details on certificate store
format and usage.
proxy The default proxy to use when installing packages from the network. Currently, only HTTP or HTTPS prox<hy>
ies are supported. If this field is blank or nonexistent, then no proxy will be used.
rscriptalt=root | noaccess Determines the user that will run request scripts. This parameter can have either of the
values described below. See pkgadd(1M) for details on the conditions under which this parameter is useful.
root Run request script as user install, if such a user exists, with the privileges of that user. Otherwise, run script as
user root, with UID equal to 0 and with all/zone privileges. (See zones(5).)
noaccess Run request script as user install, if such a user exists, with the privileges of that user. Otherwise, run
script as user noaccess, with the basic privileges of the unprivileged user noaccess.
If this parameter is not present or has a null value, the user noaccess is assumed. Likewise, if this parameter is set to
anything other than the values described here, a warning is issued, and noaccess is assumed. rscriptalt is not present
in the default admin file, /var/sadm/install/admin/default. In this case, request scripts are run as the user noac<hy>
cess.
Example 1 Default admin File
The default admin file, named default, is shipped with user-, group-, and world-read privileges (444). Its contents
are as follows:
 mail=
 instance=unique
 partial=ask
 runlevel=ask
 idepend=ask
 rdepend=ask
 space=ask
 setuid=ask
 conflict=ask
 action=ask
 basedir=default
 authentication=quit
 networktimeout=10
 networkretries=3
 keystore=/var/sadm/security
<beginning of page>
 proxy=
Example 2 Sample admin file.
Below is a sample admin file.
 basedir=default
 runlevel=quit
 conflict=quit
 setuid=quit
 action=quit
 partial=quit
 instance=unique
 idepend=quit
 rdepend=quit
 space=quit
 authentication=quit
 networktimeout=10
 networkretries=5
 keystore=/opt/certs
 proxy=syrinx.eng.example.com:8080
The default admin file is consulted during package installation when no other admin file is specified.
/var/sadm/install/admin/default
default admin file
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUNW<hy>
pkgcmdsr _ Interface StabilityEvolving
pkgadd(1M), prodreg(1M), libwsreg(3LIB), pkginfo(4), attributes(5), zones(5)
The value ask should not be defined in an admin file that will be used for non-interactive installation (because, by
definition, there is no installer interaction). Doing so causes installation to fail at the point when input is needed.
agpgart_io.7i <beginning of page>
agpgart_io <-> Solaris agpgart driver I/O control operations
#include <sys/agpgart.h>
The Accelerated Graphics Port (AGP) is a PCI bus technology enhancement that improves 3D graphics performance
by using low-cost system memory. AGP chipsets use the Graphics Address Remapping Table (GART) to map dis<hy>
contiguous system memory into a contiguous PCI memory range (known as the AGP Aperture), enabling the graph<hy>
ics card to utilize the mapped aperture range as video memory.
The agpgart driver creates a pseudo device node at /dev/agpgart and provides a set of ioctls for managing alloca<hy>
tion/deallocation of system memory, setting mappings between system memory and aperture range, and setting up
AGP devices. The agpgart driver manages both pseudo and real device nodes, but to initiate AGP-related operations
you operate only on the /dev/agpgart pseudo device node. To do this, open /dev/agpgart. The macro defined for the
pseudo device node name is:
 #define AGP_DEVICE "/dev/agpgart"
The agpgart_io driver implementation is AGP architecture-dependent and cannot be made generic. Currently, the
agpgart_io driver only supports specific AGP systems. To determine if a system is supported, run an open(2) sys<hy>
tem call on the AGP_DEVICE node. (Note that open(2) fails if a system is not supported). After the AGP_DE<hy>
VICE is opened, you can use kstat(1M) to read the system architecture type.
In addition to AGP system support, the agpgart ioctls can also be used on Intel integrated graphics devices (IGD).
IGD devices usually have no dedicated video memory and must use system memory as video memory. IGD devices
contain translation tables (referred to as GTT tables) that are similar to the GART translation table for address map<hy>
ping purposes.
Processes must open the agpgart_io driver utilizing a GRAPHICS_ACCESS privilege. Then all the ioctls can be
called by this processes with the saved file descriptor. With the exception of AGPIOC_INFO, the AGPIOC_AC<hy>
QUIRE ioctl must be called before any other ioctl. Once a process has acquired GART, it cannot be acquired by an<hy>
other process until the former process calls AGPIOC_RELEASE.
If the AGP_DEVICE fails to open, it may be due to one of the following reasons:
EAGAIN
GART table allocation failed.
EIO
Internal hardware initialization failed.
ENXIO
Getting device soft state error. (This is unlikely to happen.)
 EPERM
Without enough privilege.
With the exception of GPIOC_INFO, all ioctls shown in this section are protected by GRAPHICS_ACCESS privi<hy>
lege. (Only processes with GRAPHICS_ACCESS privilege in its effective set can access the privileged ioctls).
Common ioctl error codes are shown below. (Additional error codes may be displayed by individual ioctls.)
ENXIO
Ioctl command not supported or getting device soft state error.
EPERM
Process not privileged.
<beginning of page>
AGPIOC_INFO
Get system wide AGP or IGD hardware information. This command can be called by any process from user or ker<hy>
nel context.
 The argument is a pointer to agp_info_t structure.
  typedef struct _agp_info {
  agp_version_t agpi_version; /* OUT: AGP version supported */
  uint32_t agpi_devid; /* OUT: bridge vendor + device */
  uint32_t agpi_mode; /* OUT: mode of bridge */
  ulong_t agpi_aperbase; /* OUT: base of aperture */
  size_t agpi_apersize; /* OUT: aperture size in MB */
  uint32_t agpi_pgtotal; /* OUT: max aperture pages avail. */
  uint32_t agpi_pgsystem; /* OUT: same as pg_total */
  uint32_t agpi_pgused; /* OUT: no. of currently used pages */
  } agp_info_t;
 agpi_version The version of AGP protocol the bridge device is
  compatible with, for example, major 3 and minor 0
  means AGP version 3.0.
  typedef struct _agp_version {
  uint16_t agpv_major;
  uint16_t agpv_minor;
  } agp_version_t;
 agpi_devid AGP bridge vendor and device ID.
 agpi_mode Current AGP mode, read from AGP status register of
  target device. The main bits are defined as below.
  /* AGP status register bits definition */
  #define AGPSTAT_RQ_MASK 0xff000000
  #define AGPSTAT_SBA (0x1 << 9)
  #define AGPSTAT_OVER4G (0x1 << 5)
  #define AGPSTAT_FW (0x1 << 4)
  #define AGPSTAT_RATE_MASK 0x7
  /* AGP 3.0 only bits */
  #define AGPSTAT_ARQSZ_MASK (0x7 << 13)
  #define AGPSTAT_CAL_MASK (0x7 << 10)
  #define AGPSTAT_GART64B (0x1 << 7)
  #define AGPSTAT_MODE3 (0x1 << 3)
  /* rate for 2.0 mode */
  #define AGP2_RATE_1X 0x1
  #define AGP2_RATE_2X 0x2
  #define AGP2_RATE_4X 0x4
  /* rate for 3.0 mode */
  #define AGP3_RATE_4X 0x1
  #define AGP3_RATE_8X 0x2
 agpi_aperbase The base address of aperture in PCI memory space.
 agpi_apersize The size of the aperture in megabytes.
 agpi_pgtotal Represents the maximum memory
  pages the system can allocate
  according to aperture size and
  system memory size (which may differ
  from the maximum locked memory a process
  can have. The latter is subject
  to the memory resource limit imposed
  by the resource_controls(5) for each
  project(4)):
  project.max-device-locked-memory
  This value can be modified through system
  utilities like prctl(1).
<beginning of page>
 agpi_pgsystem Same as pg_total.
 agpi_pgused System pages already allocated by the driver.
 Return Values:
  EFAULT Argument copy out error
  EINVAL Command invalid
  0 Success
AGPIOC_ACQUIRE
Acquire control of GART. With the exception of AGPIOC_INFO, a process must acquire GART before can it call
other agpgart ioctl commands. Additionally, only processes with GRAPHICS_ACCESS privilege may access this
ioctl. In the current agpgart implementation, GART access is exclusive, meaning that only one process can perform
GART operations at a time. To release control over GART, call AGPIOC_RELEASE. This command can be called
from user or kernel context.
The argument should be NULL.
Return values:
EBUSY GART has been acquired
0 Success.
AGPIOC_RELEASE
Release GART control. If a process releases GART control, it cannot perform additional GART operations until
GART is reacquired. Note that this command does not free allocated memory or clear GART entries. (All clear jobs
are done by direct calls or by closing the device). When a process exits without making this ioctl, the final close(2)
performs this automatically. This command can be called from user or kernel context.
The argument should be NULL.
Return values:
EPERM Not owner of GART.
0 Success.
AGPIOC_SETUP
Setup AGPCMD register. An AGPCMD register resides in both the AGP master and target devices. The AGPCMD
register controls the working mode of the AGP master and target devices. Each device must be configured using the
same mode. This command can be called from user or kernel context.
 The argument is a pointer to agp_setup_t structure:
  typedef struct _agp_setup {
  uint32_t agps_mode; /* IN: value to be set for AGPCMD */
  } agp_setup_t;
 agps_mode Specifying the mode to be set. Each bit of the value may have
  a specific meaning, please refer to AGP 2.0/3.0 specification
  or hardware datasheets for details.
  /* AGP command register bits definition */
  #define AGPCMD_RQ_MASK 0xff000000
  #define AGPCMD_SBAEN (0x1 << 9)
<beginning of page>
  #define AGPCMD_AGPEN (0x1 << 8)
  #define AGPCMD_OVER4GEN (0x1 << 5)
  #define AGPCMD_FWEN (0x1 << 4)
  #define AGPCMD_RATE_MASK 0x7
  /* AGP 3.0 only bits */
  #define AGP3_CMD_ARQSZ_MASK (0x7 << 13)
  #define AGP3_CMD_CAL_MASK (0x7 << 10)
  #define AGP3_CMD_GART64BEN (0x1 << 7)
The final values set to the AGPCMD register of the master/target devices are decided by the agps_mode value and
AGPSTAT of the master and target devices.
Return Values:
EPERM Not owner of GART.
EFAULT Argument copy in error.
EINVAL Command invalid for non-AGP system.
EIO Hardware setup error.
0 Success.
AGPIOC_ALLOCATE
Allocate system memory for graphics device. This command returns a unique ID which can be used in subsequent
operations to represent the allocated memory. The memory is made up of discontiguous physical pages. In rare cas<hy>
es, special memory types may be required. The allocated memory must be bound to the GART table before it can be
used by graphics device. Graphics applications can also mmap(2) the memory to userland for data storing. Memory
should be freed when it is no longer used by calling AGPIOC_DEALLOCATE or simply by closing the device. This
command can be called from user or kernel context.
 The argument is a pointer to agp_allocate_t structure.
  typedef struct _agp_allocate {
  int32_t agpa_key; /* OUT:ID of allocated memory */
  uint32_t agpa_pgcount;/* IN: no. of pages to be allocated */
  uint32_t agpa_type;/* IN: type of memory to be allocated */
  uint32_t agpa_physical; /* OUT: reserved */
  } agp_allocate_t;
agpa_key Unique ID of the allocated memory.
agpa_pgcount Number of pages to be allocated. The driver currently supports only 4K pages. The value cannot ex<hy>
ceed the agpi_pgtotal value returned by AGPIOC_INFO ioct and is subject to the limit of project.max-device-
locked-memory. If the memory needed is larger than the resource limit but not larger than agpi_pgtotal, use prctl(1)
or other system utilities to change the default value of memory resource limit beforehand.
agpa_type Type of memory to be allocated. The valid value of agpa_type should be AGP_NORMAL. It is defined
as:
  #define AGP_NORMAL 0
Above, AGP_NORMAL represents the discontiguous non-cachable physical memory which doesn't consume kernel
virtual space but can be mapped to user space by mmap(2). This command may support more type values in the fu<hy>
ture.
<beginning of page>
agpa_physical Reserved for special uses. In normal operations, the value is undefined.
Return Values:
EPERM Not owner of GART.
EINVAL Argument not valid.
EFAULT Argument copy in/out error.
ENOMEM Memory allocation error.
0 Success.
AGPIOC_DEALLOCATE Deallocate the memory identified by a key assigned in a previous allocation. If the
memory isn't unbound from GART, this command unbinds it automatically. The memory should no longer be used
and those still in mapping to userland cannot be deallocated. Always call AGPIOC_DEALLOCATE explicitly (in<hy>
stead of deallocating implicitly by closing the device), as the system won't carry out the job until the last reference
to the device file is dropped. This command from user or kernel context.
The input argument is a key of type int32_t, no output argument.
Return Values:
EPERM Not owner of GART.
EINVAL Key not valid or memory in use.
0 Success.
AGPIOC_BIND Bind allocated memory. This command binds the allocated memory identified by a key to a
specific offset of the GART table, which enables GART to translate the aperture range at the offset to system
memory. Each GART entry represents one physical page. If the GART range is previously bound to other system
memory, it returns an error. Once the memory is bound, it cannot be bound to other offsets unless it is unbound. To
unbind the memory, call AGPIOC_UNBIND or deallocate the memory. This command can be called from user or
kernel context.
 The argument is a pointer to agp_bind_t structure:
  typedef struct _agp_bind {
  int32_t agpb_key; /* IN: ID of memory to be bound */
  uint32_t agpb_pgstart; /* IN: offset in aperture */
  } agp_bind_t;
agpb_key The unique ID of the memory to be bound, which is previously allocated by calling AGPIOC_ALLO<hy>
CATE.
agpb_pgstart The starting page offset to be bound in aperture space.
Return Values:
EPERM Not owner of GART.
<beginning of page>
EFAULT Argument copy in error.
EINVAL Argument not valid.
EIO Binding to the GTT table of IGD devices failed.
0 Success.
AGPIOC_UNBIND Unbind memory identified by a key from the GART. This command clears the corresponding
entries in the GART table. Only the memory not in mapping to userland is allowed to be unbound.
This ioctl command can be called from user or kernel context.
 The argument is a pointer to agp_unbind_t structure.
  typedef struct _agp_unbind {
  int32_t agpu_key; /* IN: key of memory to be unbound*/
  uint32_t agpu_pri; /* Not used: for compat. with Xorg */
  } agp_unbind_t;
agpu_key Unique ID of the memory to be unbound which was previously bound by calling AGPIOC_BIND.
agpu_pri Reserved for compatibility with X.org/XFree86, not used.
Return Values:
EPERM Not owner of GART.
EFAULT Argument copy in error.
EINVAL Argument not valid or memory in use.
EIO Unbinding from the GTT table of IGD devices failed.
0 Success
Below is an sample program showing how agpgart ioctls can be used:
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h
 #include <sys/ioccom.h>
 #include <sys/types.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <sys/mman.h>
 #include <sys/agpgart.h>
 #define AGP_PAGE_SIZE 4096
 int main(int argc, char *argv[])
<beginning of page>
 {
  int fd, ret;
  agp_allocate_t alloc;
  agp_bind_t bindinfo;
  agp_info_t agpinfo;
  agp_setup_t modesetup;
  int *p = NULL;
  off_t mapoff;
  size_t maplen;
  if((fd = open(AGP_DEVICE, O_RDWR))== -1) {
  printf("open AGP_DEVICE error with %d\n", errno);\
  exit(-1);
  }
  printf("device opened\n");
  ret = ioctl(fd, AGPIOC_INFO, &agpinfo);
  if(ret == -1) {
  printf("Get info error %d0, errno);
  exit(-1);
  }
  printf("AGPSTAT is %x\n", agpinfo.agpi_mode);
  printf("APBASE is %x\n", agpinfo.agpi_aperbase);
  printf("APSIZE is %dMB\n", agpinfo.agpi_apersize);
  printf("pg_total is %d\n", agpinfo.agpi_pgtotal);
  ret = ioctl(fd, AGPIOC_ACQUIRE);
  if(ret == -1) {
  printf(" Acquire GART error %d\n", errno);
  exit(-1);
  }
  modesetup.agps_mode = agpinfo.agpi_mode;
  ret = ioctl(fd, AGPIOC_SETUP, &modesetup);
  if(ret == -1) {
  printf("set up AGP mode error\n", errno);
  exit(-1);
  }
  printf("Please input the number of pages you want to allocate\n");
  scanf("%d", &alloc.agpa_pgcount);
  alloc.agpa_type = AGP_NORMAL;
  ret = ioctl(fd, AGPIOC_ALLOCATE, &alloc);
  if(ret == -1) {
  printf("Allocate memory error %d\n", errno);
  exit(-1);
  }
  printf("Please input the aperture page offset to bind\n");
  scanf("%d", &bindinfo.agpb_pgstart);
  bindinfo.agpb_key = alloc.agpa_key;
  ret = ioctl(fd, AGPIOC_BIND, &bindinfo);
  if(ret == -1) {
  printf("Bind error %d\n", errno);
  exit(-1);
  }
  printf("Bind successful\n");
  /*
  * Now gart aperture space from (bindinfo.agpb_pgstart) to
  * (bindinfo.agpb_pgstart + alloc.agpa_pgcount) can be used for
  * AGP graphics transactions
  */
  ...
  /*
<beginning of page>
  * mmap can allow user processes to store graphics data
  * to the aperture space
  */
  maplen = alloc.agpa_pgcount * AGP_PAGE_SIZE;
  mapoff = bindinfo.agpb_pgstart * AGP_PAGE_SIZE;
  p = (int *)mmap((caddr_t)0, maplen, (PROT_READ | PROT_WRITE),
  MAP_SHARED, fd, mapoff);
  if (p == MAP_FAILED) {
  printf("Mmap error %d\n", errno);
  exit(-1);
  }
  printf("Mmap successful\n");
  ...
  /*
  * When user processes finish access to the aperture space,
  * unmap the memory range
  */
  munmap((void *)p, maplen);
  ...
  /*
  * After finishing AGP transactions, the resources can be freed
  * step by step or simply by close device.
  */
  ret = ioctl(fd, AGPIOC_DEALLOCATE, alloc.agpa_key);
  if(ret == -1) {
  printf(" Deallocate memory error %d\n", errno);
  exit(-1);
  }
  ret = ioctl(fd, AGPIOC_RELEASE);
  if(ret == -1) {
  printf(" Release GART error %d\n", errno);
  exit(-1);
  }
  close(fd);
 }
/dev/agpgart
Symbolic link to the pseudo agpgart device.
/platform/i86pc/kernel/drv/agpgart
agpgart pseudo driver.
/platform/i86pc/kernel/drv/agpgart.conf
Driver configuration file.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(1.83i) |cw(3.67i) lw(1.83i) |lw(3.67i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureX86 _
AvailabilitySUNWagp, SUNWagph _ Stability levelUnstable
prctl(1), kstat(1M), close(2), ioctl(2), open(2), mmap(2), project(4), privileges(5), attributes(5), resource_con<hy>
trols(5)
aio_cancel.3c <beginning of page>
aio_cancel <-> cancel asynchronous I/O request
#include <aio.h>
int aio_cancel(int fildes, struct aiocb *aiocbp);
The aio_cancel() function attempts to cancel one or more asynchronous I/O requests currently outstanding against
file descriptor fildes. The aiocbp argument points to the asynchronous I/O control block for a particular request to be
canceled. If aiocbp is NULL, then all outstanding cancelable asynchronous I/O requests against fildes are canceled.
Normal asynchronous notification occurs for asynchronous I/O operations that are successfully canceled. If there are
requests that cannot be canceled, then the normal asynchronous completion process takes place for those requests
when they are completed.
For requested operations that are successfully canceled, the associated error status is set to ECANCELED and the
return status is <mi>1. For requested operations that are not successfully canceled, the aiocbp is not modified by
aio_cancel().
If aiocbp is not NULL, then if fildes does not have the same value as the file descriptor with which the asynchronous
operation was initiated, unspecified results occur.
The aio_cancel() function returns the value AIO_CANCELED to the calling process if the requested operation(s)
were canceled. The value AIO_NOTCANCELED is returned if at least one of the requested operation(s) cannot be
canceled because it is in progress. In this case, the state of the other operations, if any, referenced in the call to
aio_cancel() is not indicated by the return value of aio_cancel(). The application may determine the state of affairs
for these operations by using aio_error(3C). The value AIO_ALLDONE is returned if all of the operations have al<hy>
ready completed. Otherwise, the function returns <mi>1 and sets errno to indicate the error.
The aio_cancel() function will fail if:
EBADF The fildes argument is not a valid file descriptor.
ENOSYS The aio_cancel() function is not supported.
The aio_cancel() function has a transitional interface for 64-bit file offsets. See lf64(5).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyCommitted _ MT-LevelMT-Safe _ StandardSee standards(5).
aio.h(3HEAD), signal.h(3HEAD), aio_read(3C), aio_return(3C), attributes(5), lf64(5), standards(5)
Solaris 2.6 was the first release to support the Asynchronous Input and Output option. Prior to this release, this func<hy>
tion always returned <mi>1 and set errno to ENOSYS.
aio_error.3c <beginning of page>
aio_error <-> retrieve errors status for an asynchronous I/O operation
#include <aio.h>
int aio_error(const struct aiocb *aiocbp);
The aio_error() function returns the error status associated with the aiocb structure referenced by the aiocbp argu<hy>
ment. The error status for an asynchronous I/O operation is the errno value that would be set by the corresponding
read(2), write(2), or fsync(3C) operation. If the operation has not yet completed, then the error status will be equal
to EINPROGRESS.
If the asynchronous I/O operation has completed successfully, then 0 is returned. If the asynchronous operation has
completed unsuccessfully, then the error status, as described for read(2), write(2), and fsync(3C), is returned. If the
asynchronous I/O operation has not yet completed, then EINPROGRESS is returned.
The aio_error() function may fail if:
EINVAL The aiocbp argument does not refer to an asynchronous operation whose return status has not yet been re<hy>
trieved.
The aio_error() function has a transitional interface for 64-bit file offsets. See lf64(5). Example 1 The following is
an example of an error handling routine using the aio_error() function.
 #include <aio.h>
 #include <errno.h>
 #include <signal.h>
 struct aiocb my_aiocb;
 struct sigaction my_sigaction;
 void my_aio_handler(int, siginfo_t *, void *);
 ...
 my_sigaction.sa_flags = SA_SIGINFO;
 my_sigaction.sa_sigaction = my_aio_handler;
 sigemptyset(&my_sigaction.sa_mask);
 (void) sigaction(SIGRTMIN, &my_sigaction, NULL);
 ...
 my_aiocb.aio_sigevent.sigev_notify = SIGEV_SIGNAL;
 my_aiocb.aio_sigevent.sigev_signo = SIGRTMIN;
 my_aiocb.aio_sigevent.sigev_value.sival_ptr = &myaiocb;
 ...
 (void) aio_read(&my_aiocb);
 ...
 void
 my_aio_handler(int signo, siginfo_t *siginfo, void *context) {
 int my_errno;
 struct aiocb *my_aiocbp;
 my_aiocbp = siginfo->si_value.sival_ptr;
  if ((my_errno = aio_error(my_aiocb)) != EINPROGRESS) {
  int my_status = aio_return(my_aiocb);
  if (my_status >= 0){ /* start another operation */
  ...
  } else { /* handle I/O error */
  ...
  }
  }
 }
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelAsync-Signal-Safe _ StandardSee standards(5).
<beginning of page>
_Exit(2), close(2), fork(2), lseek(2), read(2), write(2), aio.h(3HEAD), aio_cancel(3C), aio_fsync(3C),
aio_read(3C), aio_return(3C), aio_write(3C), lio_listio(3C), signal.h(3HEAD), attributes(5), lf64(5), stan<hy>
dards(5)
aio.h.3head <beginning of page>
aio.h, aio <-> asynchronous input and output
#include <aio.h>
The <aio.h> header defines the aiocb structure which includes the following members:
 int aio_fildes file descriptor
 off_t aio_offset file offset
 volatile void* aio_buf location of buffer
 size_t aio_nbytes length of transfer
 int aio_reqprio request priority offset
 struct sigevent aio_sigevent notification type
 int aio_lio_opcode listio operation
This header also includes the following constants:
AIO_ALLDONE A return value indicating that none of the requested operations could be canceled since they are
already complete.
AIO_CANCELED A return value indicating that all requested operations have been canceled.
AIO_NOTCANCELED A return value indicating that some of the requested operations could not be canceled since
they are in progress.
LIO_NOP A lio_listio(3C) element operation option indicating that no transfer is requested.
LIO_NOWAIT A lio_listio() synchronization operation indicating that the calling thread is to continue execution
while the lio_listio() operation is being performed, and notification is to be given when the operation is complete.
LIO_READ A lio_listio() element operation option requesting a read.
LIO_WAIT A lio_listio() synchronization operation indicating that the calling thread is to suspend until the lio_lis<hy>
tio() operation is complete.
LIO_WRITE A lio_listio() element operation option requesting a write.
lseek(2), read(2), write(2), fsync(3C), libaio(3LIB), lio_listio(3C)
aioread.3c <beginning of page>
aioread, aiowrite <-> read or write asynchronous I/O operations
#include <sys/types.h>
#include <sys/asynch.h>
int aioread(int fildes, char *bufp, int bufs, off_t offset,
 int whence, aio_result_t *resultp);
int aiowrite(int fildes, const char *bufp, int bufs, off_t offset,
 int whence, aio_result_t *resultp);
The aioread() function initiates one asynchronous read(2) and returns control to the calling program. The read con<hy>
tinues concurrently with other activity of the process. An attempt is made to read bufs bytes of data from the object
referenced by the descriptor fildes into the buffer pointed to by bufp.
The aiowrite() function initiates one asynchronous write(2) and returns control to the calling program. The write
continues concurrently with other activity of the process. An attempt is made to write bufs bytes of data from the
buffer pointed to by bufp to the object referenced by the descriptor fildes.
On objects capable of seeking, the I/O operation starts at the position specified by whence and offset. These parame<hy>
ters have the same meaning as the corresponding parameters to the llseek(2) function. On objects not capable of
seeking the I/O operation always start from the current position and the parameters whence and offset are ignored.
The seek pointer for objects capable of seeking is not updated by aioread() or aiowrite(). Sequential asynchronous
operations on these devices must be managed by the application using the whence and offset parameters.
The result of the asynchronous operation is stored in the structure pointed to by resultp:
 int aio_return; /* return value of read() or write() */
 int aio_errno; /* value of errno for read() or write() */
Upon completion of the operation both aio_return and aio_errno are set to reflect the result of the operation. Since
AIO_INPROGRESS is not a value used by the system, the client can detect a change in state by initializing aio_re<hy>
turn to this value.
The application-supplied buffer bufp should not be referenced by the application until after the operation has com<hy>
pleted. While the operation is in progress, this buffer is in use by the operating system.
Notification of the completion of an asynchronous I/O operation can be obtained synchronously through the
aiowait(3C) function, or asynchronously by installing a signal handler for the SIGIO signal. Asynchronous notifi<hy>
cation is accomplished by sending the process a SIGIO signal. If a signal handler is not installed for the SIGIO sig<hy>
nal, asynchronous notification is disabled. The delivery of this instance of the SIGIO signal is reliable in that a sig<hy>
nal delivered while the handler is executing is not lost. If the client ensures that aiowait() returns nothing (using a
polling timeout) before returning from the signal handler, no asynchronous I/O notifications are lost. The aiowait()
function is the only way to dequeue an asynchronous notification. The SIGIO signal can have several meanings si<hy>
multaneously. For example, it can signify that a descriptor generated SIGIO and an asynchronous operation com<hy>
pleted. Further, issuing an asynchronous request successfully guarantees that space exists to queue the completion
notification.
The close(2), exit(2) and execve(2)) functions block until all pending asynchronous I/O operations can be canceled
by the system.
It is an error to use the same result buffer in more than one outstanding request. These structures can be reused only
after the system has completed the operation.
Upon successful completion, aioread() and aiowrite() return 0. Upon failure, aioread() and aiowrite() return <mi>1
and set errno to indicate the error.
The aioread() and aiowrite() functions will fail if:
EAGAIN The number of asynchronous requests that the system can handle at any one time has been exceeded
EBADF The fildes argument is not a valid file descriptor open for reading.
<beginning of page>
EFAULT At least one of bufp or resultp points to an address outside the address space of the requesting process.
This condition is reported only if detected by the application process.
EINVAL The resultp argument is currently being used by an outstanding asynchronous request.
EINVAL The offset argument is not a valid offset for this file system type.
ENOMEM Memory resources are unavailable to initiate request.
The aioread() and aiowrite() functions have transitional interfaces for 64-bit file offsets. See lf64(5).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT-LevelSafe
close(2), execve(2), exit(2), llseek(2), lseek(2), open(2), read(2), write(2), aiocancel(3C), aiowait(3C),
sigvec(3UCB), attributes(5), lf64(5)
aio_return.3c <beginning of page>
aio_return <-> retrieve return status of an asynchronous I/O operation
#include <aio.h>
ssize_t aio_return(struct aiocb *aiocbp);
The aio_return() function returns the return status associated with the aiocb structure referenced by the aiocbp ar<hy>
gument. The return status for an asynchronous I/O operation is the value that would be returned by the correspond<hy>
ing read(2), write(2), or fsync(3C) function call. If the error status for the operation is equal to EINPROGRESS,
then the return status for the operation is undefined. The aio_return() function may be called exactly once to re<hy>
trieve the return status of a given asynchronous operation; thereafter, if the same aiocb structure is used in a call to
aio_return() or aio_error(3C), an error may be returned. When the aiocb structure referred to by aiocbp is used to
submit another asynchronous operation, then aio_return() may be successfully used to retrieve the return status of
that operation.
If the asynchronous I/O operation has completed, then the return status, as described for read(2), write(2), and
fsync(3C), is returned. If the asynchronous I/O operation has not yet completed, the results of aio_return() are un<hy>
defined.
The aio_return() function will fail if:
EINVAL The aiocbp argument does not refer to an asynchronous operation whose return status has not yet been re<hy>
trieved.
ENOSYS The aio_return() function is not supported by the system.
The aio_return() function has a transitional interface for 64-bit file offsets. See lf64(5).
See attributes(5) for descriptions of the following attributes:
tab() box; lw(2.75i) |lw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyCommitted _ MT-LevelAsync-Signal-Safe _ StandardSee standards(5).
close(2), exec(2), exit(2), fork(2), lseek(2), read(2), write(2), fsync(3C), aio.h(3HEAD), signal.h(3HEAD),
aio_cancel(3C), aio_fsync(3C), aio_read(3C), lio_listio(3C), attributes(5), lf64(5), standards(5)
Solaris 2.6 was the first release to support the Asynchronous Input and Output option. Prior to this release, this func<hy>
tion always returned <mi>1 and set errno to ENOSYS.
aiowait.3c <beginning of page>
aiowait <-> wait for completion of asynchronous I/O operation
#include <sys/asynch.h>
#include <sys/time.h>
aio_result_t *aiowait(const struct timeval *timeout);
The aiowait() function suspends the calling process until one of its outstanding asynchronous I/O operations com<hy>
pletes, providing a synchronous method of notification.
If timeout is a non-zero pointer, it specifies a maximum interval to wait for the completion of an asynchronous I/O
operation. If timeout is a zero pointer, aiowait() blocks indefinitely. To effect a poll, the timeout parameter should be
non-zero, pointing to a zero-valued timeval structure.
The timeval structure is defined in <sys/time.h> and contains the following members:
 long tv_sec; /* seconds */
 long tv_usec; /* and microseconds */
Upon successful completion, aiowait() returns a pointer to the result structure used when the completed asynchro<hy>
nous I/O operation was requested. Upon failure, aiowait() returns <mi>1 and sets errno to indicate the error. aiowait()
returns 0 if the time limit expires.
The aiowait() function will fail if:
EFAULT The timeout argument points to an address outside the address space of the requesting process. See
NOTES.
EINTR The execution of aiowait() was interrupted by a signal.
EINVAL There are no outstanding asynchronous I/O requests.
EINVAL The tv_secs member of the timeval structure pointed to by timeout is less than 0 or the tv_usecs member
is greater than the number of seconds in a microsecond.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT-LevelSafe
aiocancel(3C), aioread(3C), attributes(5)
The aiowait() function is the only way to dequeue an asynchronous notification. It can be used either inside a SI<hy>
GIO signal handler or in the main program. One SIGIO signal can represent several queued events.
Passing an illegal address as timeout will result in setting errno to EFAULT only if detected by the application
process.
aio_write.3c <beginning of page>
aio_write <-> asynchronous write to a file
#include <aio.h>
int aio_write(struct aiocb *aiocbp);
The aio_write() function allows the calling process to write aiocbp<->>aio_nbytes to the file associated with
aiocbp<->>aio_fildes from the buffer pointed to by aiocbp<->>aio_buf. The function call returns when the write request
has been initiated or, at a minimum, queued to the file or device. If _POSIX_PRIORITIZED_IO is defined and pri<hy>
oritized I/O is supported for this file, then the asynchronous operation is submitted at a priority equal to the schedul<hy>
ing priority of the process minus aiocbp<->>aio_reqprio. The aiocbp may be used as an argument to aio_error(3C)
and aio_return(3C) in order to determine the error status and return status, respectively, of the asynchronous opera<hy>
tion while it is proceeding.
The aiocbp argument points to an aiocb structure. If the buffer pointed to by aiocbp<->>aio_buf or the control block
pointed to by aiocbp becomes an illegal address prior to asynchronous I/O completion, then the behavior is unde<hy>
fined.
If O_APPEND is not set for the file descriptor aio_fildes, then the requested operation takes place at the absolute
position in the file as given by aio_offset, as if lseek(2) were called immediately prior to the operation with an offset
equal to aio_offset and a whence equal to SEEK_SET. If O_APPEND is set for the file descriptor, write operations
append to the file in the same order as the calls were made. After a successful call to enqueue an asynchronous I/O
operation, the value of the file offset for the file is unspecified.
The aiocbp<->>aio_sigevent structure defines what asynchronous notification is to occur when the asynchronous oper<hy>
ation completes, as specified in signal.h(3HEAD).
The aiocbp<->>aio_lio_opcode field is ignored by aio_write().
Simultaneous asynchronous operations using the same aiocbp produce undefined results.
If _POSIX_SYNCHRONIZED_IO is defined and synchronized I/O is enabled on the file associated with
aiocbp<->>aio_fildes, the behavior of this function shall be according to the definitions of synchronized I/O data in<hy>
tegrity completion and synchronized I/O file integrity completion.
For any system action that changes the process memory space while an asynchronous I/O is outstanding to the ad<hy>
dress range being changed, the result of that action is undefined.
For regular files, no data transfer will occur past the offset maximum established in the open file description associ<hy>
ated with aiocbp<->>aio_fildes.
The aio_write() function returns 0 to the calling process if the I/O operation is successfully queued; otherwise, the
function returns <mi>1 and sets errno to indicate the error.
The aio_write() function will fail if:
EAGAIN The requested asynchronous I/O operation was not queued due to system resource limitations.
Each of the following conditions may be detected synchronously at the time of the call to aio_write(), or asyn<hy>
chronously. If any of the conditions below are detected synchronously, the aio_write() function returns <mi>1 and sets
errno to the corresponding value. If any of the conditions below are detected asynchronously, the return status of the
asynchronous operation is set to <mi>1, and the error status of the asynchronous operation will be set to the correspond<hy>
ing value.
EBADF The aiocbp<->>aio_fildes argument is not a valid file descriptor open for writing.
EINVAL The file offset value implied by aiocbp->aio_offset would be invalid, aiocbp->aio_reqprio is not a valid
value, or aiocbp<->>aio_nbytes is an invalid value.
In the case that the aio_write() successfully queues the I/O operation, the return status of the asynchronous opera<hy>
tion will be one of the values normally returned by the write(2) function call. If the operation is successfully queued
but is subsequently canceled or encounters an error, the error status for the asynchronous operation contains one of
the values normally set by the write() function call, or one of the following:
<beginning of page>
EBADF The aiocbp<->>aio_fildes argument is not a valid file descriptor open for writing.
EINVAL The file offset value implied by aiocbp->aio_offset would be invalid.
ECANCELED The requested I/O was canceled before the I/O completed due to an explicit aio_cancel(3C) request.
The following condition may be detected synchronously or asynchronously:
EFBIG The file is a regular file, aiobcp<->>aio_nbytes is greater than 0 and the starting offset in aiobcp<->>aio_offset
is at or beyond the offset maximum in the open file description associated with aiocbp<->>aio_fildes.
The aio_write() function has a transitional interface for 64-bit file offsets. See lf64(5).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe _ StandardSee standards(5).
aio_cancel(3C), aio_error(3C), aio_read(3C), aio_return(3C), lio_listio(3C), close(2), _Exit(2), fork(2), lseek(2),
write(2), aio.h(3HEAD), signal.h(3HEAD), attributes(5), lf64(5), standards(5)
alias.1 <beginning of page>
alias, unalias <-> create or remove a pseudonym or shorthand for a command or series of commands
/usr/bin/alias [alias-name[= string...]]
/usr/bin/unalias alias-name...
/usr/bin/unalias -a
alias [name [def]]
unalias pattern
alias [-tx] [name[= value]...]
unalias name...
unalias [-a]
alias [-ptx] [name[= value]...]
unalias [-a] [name...]
The alias and unalias utilities create or remove a pseudonym or shorthand term for a command or series of com<hy>
mands, with different functionality in the C-shell and Korn shell environments.
The alias utility creates or redefines alias definitions or writes the values of existing alias definitions to standard out<hy>
put. An alias definition provides a string value that replaces a command name when it is encountered.
An alias definition affects the current shell execution environment and the execution environments of the subshells
of the current shell. When used as specified by this document, the alias definition does not affect the parent process
of the current shell nor any utility environment invoked by the shell.
The unalias utility removes the definition for each alias name specified. The aliases are removed from the current
shell execution environment. The -a option removes all alias definitions from the current execution environment.
alias assigns def to the alias name. The assigned def is a list of words that can contain escaped history-substitution
metasyntax. name is not allowed to be alias or unalias. If def is omitted, the alias name is displayed along with its
current definition. If both name and def are omitted, all aliases are displayed.
Because of implementation restrictions, an alias definition must have been entered on a previous command line be<hy>
fore it can be used.
unalias discards aliases that match (filename substitution) pattern. All aliases can be removed by `unalias *'.
alias with no arguments prints the list of aliases in the form name=value on standard output. An alias is defined for
each name whose value is specified. A trailing space in value causes the next word to be checked for alias substitu<hy>
tion. The -t flag is used to set and list tracked aliases. The value of a tracked alias is the full pathname corresponding
to the specified name. The value becomes undefined when the value of PATH is reset but the aliases remained
tracked. Without the -t flag, for each name in the argument list for which no value is specified, the name and value of
the alias is printed. The -x flag is used to set or print exported aliases. An exported alias is defined for scripts in<hy>
voked by name. The exit status is non-zero if a name is specified, but no value, and no alias has been defined for the
name.
The aliass specified by the list of names can be removed from the alias list with unalias.
alias creates or redefines alias definitions or writes the existing alias definitions to standard output.
An alias definition provides a string value that replaces a command name when the command is read. Alias names
can contain any printable character that is not special to the shell. If an alias value ends in a SPACE or TAB, the
word following the command name the alias replaces is also checked to see whether it is an alias.
If no names are specified, the names and values of all aliases are written to standard output. Otherwise, for each
name that is specified, and =value is not specified, the current value of the alias corresponding to name is written to
standard output. If =value is specified, the alias name is created or redefined.
alias is built-in to the shell as a declaration command so that field splitting and pathname expansion are not per<hy>
<beginning of page>
formed on the arguments. Tilde expansion occurs on value. An alias definition only affects scripts read by the cur<hy>
rent shell environment. It does not affect scripts run by this shell.
unalias removes the definition of each named alias from the current shell execution environment, or all aliases if -a
is specified. It does not affect any commands that have already been read and subsequently executed.
The following option is supported by unalias:
-a Removes all alias definitions from the current shell execution environment.
The following option is supported by alias:
-t Sets and lists tracked aliases.
The following options are supported by alias:
-p Causes the output to be in the form of alias commands that can be used as input to the shell to recreate the current
aliases.
-t Specifies tracked aliases.
Tracked aliases connect a command name to the command's pathname, and are reset when the PATH variable is un<hy>
set. The tracked aliases feature is now obsolete.
-x Ignored, this option is obsolete.
The following option is supported by unalias:
-a Causes all alias definitions to be removed. name operands are optional and ignored if specified.
The following operands are supported:
alias-name Write the alias definition to standard output.
alias-name The name of an alias to be removed.
alias-name=string Assign the value of string to the alias alias-name.
If no operands are specified, all alias definitions are written to standard output.
The format for displaying aliases (when no operands or only name operands are specified) is:
 "%s=%s\n" name, value
The value string is written with appropriate quoting so that it is suitable for reinput to the shell. Example 1 Modify<hy>
ing a Command's Output
This example specifies that the output of the ls utility is columnated and more annotated:
 example% alias ls="ls <mi>CF"
Example 2 Repeating Previous Entries in the Command History File
<beginning of page>
This example creates a simple "redo" command to repeat previous entries in the command history file:
 example% alias r='fc <mi>s'
Example 3 Specifying a Command's Output Options
This example provides that the du utility summarize disk output in units of 1024 bytes:
 example% alias du=du <mi>k
Example 4 Dealing with an Argument That is an Alias Name
This example sets up the nohup utility so that it can deal with an argument that is an alias name:
 example% alias nohup="nohup "
See environ(5) for descriptions of the following environment variables that affect the execution of alias and unalias:
LANG, LC_ALL, LC_CTYPE, LC_MESSAGES, and NLSPATH.
The following exit values are returned:
0 Successful completion.
>0 One of the alias-name operands specified did not have an alias definition, or an error occurred.
>0 One of the alias-name operands specified did not represent a valid alias definition, or an error occurred.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ Interface StabilityCommitted _ StandardSee standards(5).
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ Interface StabilityUncommitted
csh(1), ksh(1), ksh93(1), shell_builtins(1), attributes(5), environ(5), standards(5)
aliasadm.1m <beginning of page>
aliasadm <-> manipulate the NIS+ aliases map
aliasadm -a alias expansion [options comments] optional flags
aliasadm -c alias expansion [options comments]
 [optional flags]
aliasadm -d alias [optional flags]
aliasadm -e alias [optional flags]
aliasadm -l alias [optional flags]
aliasadm -m alias [optional flags]
aliasadm [-I] [-D domainname] [-f filename] [-M mapname]
aliasadm makes changes to the alias map.
The alias map is an NIS+ table object with four columns:
alias The name of the alias as a null terminated string.
expansion The value of the alias as it would appear in a sendmail /etc/aliases file.
options A list of options applicable to this alias. The only option currently supported is CANON. With this option, if
the user has requested an inverse alias lookup, and there is more than one alias with this expansion, this alias is given
preference.
comments An arbitrary string containing comments about this alias. The sendmail(1M) command reads this map in
addition to the NIS aliases map and the local /etc/aliases database.
-a Add an alias.
-c Change an alias.
-d Delete an alias.
-e Edit the alias map.
-I Initialize the NIS+ aliases database.
-l List the alias map.
-m Print or match an alias.
-D domainname Edit the map in domain domainname instead of the current domain.
-f filename When editing or listing the database, use filename instead of invoking the editor.
-M mapname Edit mapname instead of mail_aliases.
<beginning of page>
/etc/aliases mail aliases for the local host in ASCII format
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wnisu
sendmail(1M), attributes(5)
NIS+ might not be supported in future releases of the Solaris operating system. Tools to aid the migration from
NIS+ to LDAP are available in the current Solaris release. For more information, visit http://www.sun.com/directo<hy>
ry/nisplus/transition.html.
allocate.1 <beginning of page>
allocate <-> device allocation
allocate [-s] [-w] [-F] [-U uname] [-z zonename] device
allocate [-s] [-w] [-F] [-U uname] [-z zonename] -g dev-type
The allocate utility manages the ownership of devices through its allocation mechanism. It ensures that each device
is used by only one qualified user at a time.
The device argument specifies the device to be manipulated. To preserve the integrity of the device's owner, the allo<hy>
cate operation is executed on all the device special files associated with that device.
The default allocate operation allocates the device special files associated with device to the uid of the current
process.
Only authorized users may allocate a device. The required authorizations are specified in device_allocate(4).
When the system is configured with Trusted Extensions, allocate runs the clean program for the device before it
grants access to the caller to that device. For devices with removable media that have a mountable file system, allo<hy>
cate mounts the media if the caller chooses.
The following options are supported:
-F device Force allocates either free or pre-allocated devices. This option is often used with the -U option to allo<hy>
cate/reallocate devices to a specific user. Only those users that have solaris.device.revoke authorization are allowed
to use this option.
-g dev<mi>type Allocates devices with a device<mi>type matching dev<mi>type. The dev<mi>type argument specifies the device
type to be operated on.
-s Silent. Suppresses any diagnostic output.
-U uname Uses the user ID uname instead of the user ID of the current process when performing the allocate opera<hy>
tion. Only a user with the solaris.device.revoke authorization is permitted to use this option.
The following options are supported with Trusted Extensions:
-w Runs the device cleaning program in a windowing environment. If a windowing version of the program exists, it
is used. Otherwise, the standard version is run in a terminal window.
-z zonename Allocates device to the zone specified by zonename.
The following operands are supported:
device Specifies the name of the device to be allocated.
The following exit values are returned:
0 Successful completion.
20 No entry for the specified device.
other value An error occurred.
/etc/security/device_allocate
<beginning of page>
/etc/security/device_maps
/etc/security/dev/*
/etc/security/lib/*
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ Interface StabilitySee below.
The invocation is Uncommitted. The options are Uncommitted. The output is Not-an-Interface.
deallocate(1), list_devices(1), bsmconv(1M), dminfo(1M), mkdevalloc(1M), mkdevmaps(1M), device_allo<hy>
cate(4), device_maps(4), attributes(5)
Controlling Access to Devices
The functionality described in this man page is available only if Solaris Auditing has been enabled. See bsm<hy>
conv(1M) for more information.
On systems configured with Trusted Extensions, the functionality is enabled by default.
/etc/security/dev, mkdevalloc(1M), and mkdevmaps(1M) might not be supported in a future release of the Solaris
Operating Environment.
amd8111s.7d <beginning of page>
amd8111s <-> AMD-8111 Fast Ethernet Network Adapter driver
/dev/amd8111s
The amd8111s Fast Ethernet driver is a multi-threaded, loadable, clonable, GLD-based STREAMS driver support<hy>
ing the Data Link Provider Interface, dlpi(7P), on the AMD-8111 Fast Ethernet Network Adapter.
The amd8111s driver functions include controller initialization, frame transmit and receive, promiscuous and multi<hy>
cast support, and error recovery and reporting.
The cloning, character-special device /dev/amd8111 is used to access all AMD-8111 Fast Ethernet devices installed
within the system.
The amd8111s driver is managed by the dladm(1M) command line utility, which allows VLANs to be defined on
top of amd8111s instances and for amd8111s instances to be aggregated. See dladm(1M) for more details.
By default, the amd8111s driver performs auto-negotiation to select the link speed and mode. Link speed and mode
can be any of the following:
100 Mbps, full-duplex.
100 Mbps, half-duplex.
10 Mbps, full-duplex.
10 Mbps, half-duplex.
/dev/amd8111s*
Special character device.
/kernel/drv/amd8111s*
32-bit ELF kernel module (x86).
/kernel/drv/amd64/amd8111s*
64-bit ELF Kernel module (x86).
See attributes(5) for descriptions of the following attributes:
tab() box; lw(2.75i) lw(2.75i) lw(2.75i) lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE Availability<hy>
SUNW8111s Architecturex86 Interface StabilityCommitted
dladm(1M), attributes(5), streamio(7I), dlpi(7P)
Writing Device Drivers
STREAMS Programming Guide
Network Interfaces Programmer's Guide
amt.1 <beginning of page>
amt <-> run abstract machine test
amt [-s]
The amt command is for use in a Common Criteria security certified system. The command is used to verify that the
low level functions necessary to enforce the object reuse requirements of the Controlled Access Protection Profile
are working correctly. /usr/bin/amt is a shell script that executes tests specific to your system. For a 32-bit system,
the tests run as a 32-bit application. For a 64-bit system, the tests run twice; once as a 32-bit application and once as
a 64-bit application.
amt lists test results with a pass or fail for each test it performs, unless output is suppressed with the -s option.
The following option is supported:
-s Suppresses output.
The following error values are returned:
0 All tests passed.
>0 Count of the number of tests that failed.
<0 Incorrect command line argument.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ Interface StabilityCommitted
attributes(5)
apache.1m <beginning of page>
apache <-> Apache hypertext transfer protocol server overview
apache consists of a main server daemon, loadable server modules, some additional support utilities, configuration
files, and documentation.
The apache HTTPD server is integrated with Solaris.
The following files specify the installation locations for apache:
/etc/apache Contains server configuration files.
A newly-installed server must be manually configured before use. Typically this involves copying httpd.conf-exam<hy>
ple to the httpd.conf file and making local configuration adjustments.
/usr/apache/bin Contains the httpd executable as well as other utility programs.
/usr/apache/htdocs Contains the Apache manual in HTML format. This documentation is accessible by way of a
link on the server test page that gets installed upon fresh installation.
/usr/apache/include Contains the Apache header files, which are needed for building various optional server exten<hy>
sions with apxs(8)
/usr/apache/jserv Contains documention for the mod_jserv java servlet module. Documention can be read with a
web browser using the url:
 file:/usr/apache/jserv/docs/index.html
/usr/apache/libexec Contains loadable modules (DSOs) supplied with the server. Any modules which are added us<hy>
ing apxs(8)are also copied into this directory.
/usr/apache/man Contains man pages for the server, utility programs, and mod_perl.
Add this directory to your MANPATH to read the Apache man pages. See NOTES.
/usr/apache/perl5 Contains the modules and library files used by the mod_perl extension to Apache.
/var/apache/cgi-bin Default location for the CGI scripts.
This can be changed by altering the httpd.conf file and restarting the server.
/var/apache/htdocs Default document root.
This can be changed by altering the httpd.conf file and restarting the server.
/var/apache/icons Icons used by the server.
This normally shouldn't need to be changed.
/var/apache/logs Contains server log files.
The formats, names, and locations of the files in this directory can be altered by various configuration directives in
the httpd.conf file.
<beginning of page>
/var/apache/proxy Directory used to cache pages if the caching feature of mod_proxy is enabled in the httpd.conf
file.
The location of the cache can also be changed by changing the proxy configuration in the httpd.conf file.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wapchr _ SUNWapchu _ SUNWapchd
attributes(5)
http://www.apache.org
In addition to the documentation and man pages included with Solaris, more information is available at
http://www.apache.org
The Apache man pages are provided with the programming modules. To view the manual pages for the Apache
modules with the man command, add /usr/apache/man to the MANPATH environment variable. See man(1) for
more information. Running catman(1M) on the Apache manual pages is not supported.
apptrace.1 <beginning of page>
apptrace <-> trace application function calls to Solaris shared libraries
apptrace [-f] [-F [!] tracefromlist] [-T [!] tracetolist]
 [-o outputfile] [ [-tv] [!] call ,...] command
 [command arguments]
The apptrace utility runs the executable program specified by command and traces all function calls that the pro<hy>
gramcommand makes to the Solaris shared libraries. For each function call that is traceable, apptrace reports the
name of the library interface called, the values of the arguments passed, and the return value.
By default, apptrace traces calls directly from the executable object to any of the shared objects it depends on. Indi<hy>
rect calls (that is, calls made between shared objects that the executable depends upon) are not reported by default.
Calls from or to additional shared objects may be traced using the -F or -T options (see below).
The default reporting format is a single line per call, with no formatted printing of arguments passed by reference or
of data structures.
Formatted printing providing additional argument details is obtained using the -v option (see below).
By default, every interface provided by a shared object is traced if called. However, the set of interfaces to be traced
can be restricted, using the -t and/or -v options.
Since it is generally possible to trace calls between any of the dynamic objects linked at runtime (the executable ob<hy>
ject and any of the shared objects depended upon), the report of each traced call gives the name of the object from
which the call was made.
apptrace traces all of the procedure calls that occur between dynamic objects via the procedure linkage table, so on<hy>
ly those procedure calls which are bound via the table will be traced. See the Linker and Libraries Guide.
The following options are supported:
-f Follows all children created by fork(2). This option will also cause the process id to be printed at the beginning of
each line.
-F [!]tracefromlist Traces calls from a comma-separated list of shared objects. Only calls from these shared objects
will be traced. The default is to trace calls from the main executable only. Only the basename of the shared object is
required. For example, libc will match /usr/lib/libc.so.1. Additionally, shell style wildcard characters are supported
as described in fnmatch(5). A list preceded by a ``!'' defines a list of objects from which calls should not be traced.
If the tracing of calls from command is required, then command must be a member of tracefromlist.
-o outputfile apptrace output will be directed to the outputfile. By default, apptrace output is placed on the stderr
stream of the process being traced.
-t [!]call,... Traces or excludes function calls. Those calls specified in the comma-separated list call are traced. If
the list begins with a !, the specified function calls are excluded from the trace output. The default is -t *. The use of
shell style wildcards is allowed.
-T [!]tracetolist Traces calls to a comma-separated list of shared objects. The default is to trace calls to all shared ob<hy>
jects. As above, the basename is all that is required and wildcarding is allowed. A list preceded by a ``!'' denotes a
list of objects to which calls should not be traced.
-v [!]call,... Provides verbose, formatted output of the arguments and return values of the function calls specified
(as above in the -t option). Unlike truss(1), calls named by the -v option do not have to be named by the -t option.
For example, apptrace -v open is equivalent to truss -t open -v open.
Example 1 Tracing the date command
 % apptrace date
 -> date -> libc.so.1:atexit(0xff3bf9ac, 0x22000, 0x0) ** NR
 -> date -> libc.so.1:atexit(0x11550, 0xfefeef80, 0xab268) ** NR
<beginning of page>
 -> date -> libc.so.1:setlocale(0x6, 0x11560, 0x0) ** NR
 -> date -> libc.so.1:textdomain(0x11564, 0xfefce156, 0xff160200) ** NR
 -> date -> libc.so.1:int getopt(int = 0x1,
  const char * * = 0xffbffa5c,
  const char * = 0x11574 "a:u")
 <- date -> libc.so.1:getopt() = 0xffffffff
 -> date -> libc.so.1:time_t time(time_t * = 0x225c0)
 <- date -> libc.so.1:time() = 0x41ab6e82
 -> date -> libc.so.1:char * nl_langinfo(nl_item = 0x3a)
 <- date -> libc.so.1:nl_langinfo() = 0xfefd3e10
 -> date -> libc.so.1:struct tm * localtime(const time_t * = 0x225c0)
 <- date -> libc.so.1:localtime() = 0xff160240
 -> date -> libc_psr.so.1:memcpy(0xffbff9cc, 0xff160240, 0x24) ** NR
 -> date -> libc.so.1:size_t strftime(char * = 0x225c4 "",
  size_t = 0x400,
  const char * = 0xfefd3e10 "%a %b %e %T %Z %Y",
  const struct tm * = 0xffbff9cc)
 <- date -> libc.so.1:strftime() = 0x1c
 -> date -> libc.so.1:int puts(const char * = 0x225c4
  "Mon Nov 29 10:46:26 PST 2004")
  Mon Nov 29 10:46:26 PST 2004
 <- date -> libc.so.1:puts() = 0x1d
 -> date -> libc.so.1:exit(0x0, 0x22400, 0x0) ** NR
Example 2 Tracing a specific set of interfaces with verbosity set
 % apptrace -v localtime,strftime,puts date
 -> date -> libc.so.1:struct tm * localtime(const time_t * = 0x225c0)
  arg0 = (const time_t *) 0x225c0
  return = (struct tm *) 0xff160280 (struct tm) {
  tm_sec: (int) 0x4
  tm_min: (int) 0x34
  tm_hour: (int) 0xa
  tm_mday: (int) 0x1d
  tm_mon: (int) 0xa
  tm_year: (int) 0x68
  tm_wday: (int) 0x1
  tm_yday: (int) 0x14d
  tm_isdst: (int) 0
  }
 <- date -> libc.so.1:localtime() = 0xff160280
 -> date -> libc.so.1:size_t strftime(char * = 0x225c4 "",
  size_t = 0x400,
  const char * = 0xfefd3e10 "%a %b %e %T %Z %Y",
  const struct tm * = 0xffbff99c)
  arg0 = (char *) 0x225c4 ""
  arg1 = (size_t) 0x400
  arg2 = (const char *) 0xfefd3e10 "%a %b %e %T %Z %Y"
  arg3 = (const struct tm *) 0xffbff99c (struct tm) {
  tm_sec: (int) 0x4
  tm_min: (int) 0x34
  tm_hour: (int) 0xa
  tm_mday: (int) 0x1d
  tm_mon: (int) 0xa
  tm_year: (int) 0x68
  tm_wday: (int) 0x1
  tm_yday: (int) 0x14d
  tm_isdst: (int) 0
  }
  return = (size_t) 0x1c
 <- date -> libc.so.1:strftime() = 0x1c
 -> date -> libc.so.1:int puts(const char * = 0x225c4
  "Mon Nov 29 10:52:04 PST 2004")
  arg0 = (const char *) 0x225c4 "Mon Nov 29 10:52:04 PST 2004"
  Mon Nov 29 10:52:04 PST 2004
<beginning of page>
  return = (int) 0x1d
 <- date -> libc.so.1:puts() = 0x1d
** NR - The return value of a function call will not be traced.
Basic runtime support for apptrace is provided by the link auditing feature of the Solaris runtime linker (ld.so.1(1))
and the apptrace command's use of this facility relies on an auditing object (apptrace.so.1) kept in /usr/lib/abi.
In general, apptrace cannot trace calls to functions accepting variable argument lists. There has been some clever
coding in several specific cases to work around this limitation, most notably in the printf and scanf families.
The apptrace utility can not trace the return value of a function call whose return type is a struct or union.
Functions that attempt to probe the stack or otherwise extract information about the caller cannot be traced. Some
examples are [gs]etcontext(), [sig]longjmp(), [sig]setjmp(), and vfork().
Functions such as exit(2) that do not return will not be traced for their return values.
For security reasons, only those processes with appropriate privileges can use apptrace to trace setuid/setgid pro<hy>
grams.
Tracing functions whose usage requires the inclusion of <varargs.h>, such as vwprintw(3XCURSES) and vws<hy>
canw(3XCURSES), will not provide formatted  printing of arguments.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcstl (32-bit) SUNWcstlx (64-bit) _ Interface StabilityUnstable
ld.so.1(1), truss(1), vwprintw(3XCURSES), vwscanw(3XCURSES), attributes(5), fnmatch(5)
Linker and Libraries Guide
ar.1 <beginning of page>
ar <-> maintain portable archive or library
/usr/bin/ar -d [-Vv] archive file...
/usr/bin/ar -m [-abiVv] [posname] archive file...
/usr/bin/ar -p [-sVv] archive [file]...
/usr/bin/ar -q [-cVv] archive file...
/usr/bin/ar -r [-abciuVv] [posname] archive file...
/usr/bin/ar -t [-sVv] archive [file]...
/usr/bin/ar -x [-CsTVv] archive [file]...
/usr/xpg4/bin/ar -d [-Vv] archive file...
/usr/xpg4/bin/ar -m [-abiVv] [posname] archive file...
/usr/xpg4/bin/ar -p [-sVv] archive [file]...
/usr/xpg4/bin/ar -q [-cVv] archive file...
/usr/xpg4/bin/ar -r [-abciuVv] [posname] archive file...
/usr/xpg4/bin/ar -t [-sVv] archive [file]...
/usr/xpg4/bin/ar -x [-CsTVv] archive [file]...
The ar utility maintains groups of files combined into a single archive file. Its main use is to create and update li<hy>
brary files. However, it can be used for any similar purpose. The magic string and the file headers used by ar consist
of printable ASCII characters. If an archive is composed of printable files, the entire archive is printable.
When ar creates an archive, it creates headers in a format that is portable across all machines. The portable archive
format and structure are described in detail in ar.h(3HEAD). The archive symbol table described there is used by the
link editor ld(1) to effect multiple passes over libraries of object files in an efficient manner. An archive symbol table
is only created and maintained by ar when there is at least one object file in the archive. The archive symbol table is
in a specially named file that is always the first file in the archive. This file is never mentioned or accessible to the
user. Whenever the ar command is used to create or update the contents of such an archive, the symbol table is re<hy>
built. The -s option described below forces the symbol table to be rebuilt.
The following options are supported:
-a Positions new files in archive after the file named by the posname operand.
-b Positions new files in archive before the file named by the posname operand.
-c Suppresses the diagnostic message that is written to standard error by default when archive is created.
-C Prevents extracted files from replacing like-named files in the file system. This option is useful when -T is also
used to prevent truncated file names from replacing files with the same prefix.
-d Deletes one or more files from archive.
-i Positions new files in archive before the file named by the posname operand. This option is quivalent to -b.
-m Moves files. If -a, -b, or -i with the posname operand are specified, the -m option moves files to the new position.
Otherwise, -m moves files to the end of archive.
<beginning of page>
-p Prints the contents of files in archive to standard output. If no files are specified, the contents of all files in archive
are written in the order of the archive.
-q Quickly appends files to the end of archive. Positioning options -a, -b, and -i are invalid. The command does not
check whether the added files are already in archive. This option is useful to avoid quadratic behavior when creating
a large archive piece-by-piece.
-r Replaces or adds files in archive. If archive does not exist, a new archive file is created and a diagnostic message
is written to standard error, unless the -c option is specified. If no files are specified and the archive exists, the results
are undefined. Files that replace existing files do not change the order of the archive. If the -u option is used with the
-r option, only those files with dates of modification later than the archive files are replaced. If the -a, -b, or -i option
is used, the posname argument must be present and specifies that new files are to be placed after (-a) or before (-b or
-i) posname. Otherwise, the new files are placed at the end.
-s Forces the regeneration of the archive symbol table even if ar is not invoked with an option that will modify the
archive contents. This command is useful to restore the archive symbol table after the strip(1) command has been
used on the archive.
-t Prints a table of contents of archive. The files specified by the file operands are included in the written list. If no
file operands are specified, all files in archive are included in the order of the archive.
-T Allows file name truncation of extracted files whose archive names are longer than the file system can support.
By default, extracting a file with a name that is too long is an error. In that case, a diagnostic message is written and
the file is not extracted.
-u Updates older files. When used with the -r option, files within archive are replaced only if the corresponding file
has a modification time that is at least as new as the modification time of the file within archive.
-v Gives verbose output. When used with options -d, -r, or -x, the -v option writes a detailed file-by-file description
of the archive creation and the constituent files, and maintenance activity. When used with -p, -v writes the name of
the file to the standard output before writing the file itself to the standard output. When used with -t, -v includes a
long listing of information about the files within the archive. When used with -x, -v prints the filename preceding
each extraction. When writing to an archive, -v writes a message to the standard error.
-V Prints its version number on standard error.
The following options are supported for /usr/xpg4/bin/ar:
-v Same as the /usr/bin/ar version, except when writing to an archive, no message is written to the standard error.
-x Extracts the files named by the file operands from archive. The contents of archive are not changed. If no file op<hy>
erands are given, all files in archive are extracted. If the file name of a file extracted from archive is longer than that
supported in the directory to which it is being extracted, the results are undefined. The modification time of each file
extracted is set to the time file is extracted from archive.
The following operands are supported:
archive A path name of the archive file.
file A path name. Only the last component is used when comparing against the names of files in the archive. If two
or more file operands have the same last path name component (see basename(1)), the results are unspecified. The
implementation's archive format will not truncate valid file names of files added to or replaced in the archive.
<beginning of page>
posname The name of a file in the archive file, used for relative positioning. See options -m and -r.
See environ(5) for descriptions of the following environment variables that affect the execution of ar: LANG,
LC_ALL, LC_CTYPE, LC_MESSAGES, LC_TIME, and NLSPATH.
TMPDIR Determine the pathname that overrides the default directory for temporary files, if any.
TZ Determine the timezone used to calculate date and time strings written by ar -tv. If TZ is unset or null, an un<hy>
specified default timezone is used.
The following exit values are returned:
0 Successful completion.
>0 An error occurred.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wbtool _ Interface StabilityCommitted
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wxcu4 _ Interface StabilityCommitted _ StandardSee standards(5).
basename(1), cpio(1), ld(1), lorder(1), strip(1), tar(1), ar.h(3HEAD), a.out(4), attributes(5), environ(5), stan<hy>
dards(5)
If the same file is mentioned twice in an argument list, it may be put in the archive twice.
By convention, archives are suffixed with ".a".
When inserting ELF objects into an archive file, ar might add "0fR" characters to pad these objects to an 8-byte
boundary. Such padding improves the efficiency with which ld(1) can access the archive. Only ELF object files
are padded in this way. Other archive members are not altered. When an object with such padding is extracted from
an archive, the padding is not included in the resulting output.
archives.h.3head <beginning of page>
archives.h, archives <-> device header
 /* Magic numbers */
 #define CMN_ASC 0x070701 /* Cpio Magic Number for -c header */
 #define CMN_BIN 070707 /* Cpio Magic Number for Binary header */
 #define CMN_BBS 0143561 /* Cpio Magic Number for Byte-Swap header */
 #define CMN_CRC 0x070702 /* Cpio Magic Number for CRC header */
 #define CMS_ASC "070701" /* Cpio Magic String for -c header */
 #define CMS_CHR "070707" /* Cpio Magic String for odc header */
 #define CMS_CRC "070702" /* Cpio Magic String for CRC header */
 #define CMS_LEN 6 /* Cpio Magic String length */
 /* Various header and field lengths */
 #define CHRSZ 76 /* -H odc size minus filename field */
 #define ASCSZ 110 /* -c and CRC hdr size minus filename field */
 #define TARSZ 512 /* TAR hdr size */
 #define HNAMLEN 256 /* maximum filename length for binary and
  odc headers */
 #define EXPNLEN 1024 /* maximum filename length for -c and
  CRC headers */
 #define HTIMLEN 2 /* length of modification time field */
 #define HSIZLEN 2 /* length of file size field */
 /* cpio binary header definition */
 struct hdr_cpio {
  short h_magic, /* magic number field */
  h_dev; /* file system of file */
  ushort_t h_ino, /* inode of file */
  h_mode, /* modes of file */
  h_uid, /* uid of file */
  h_gid; /* gid of file */
  short h_nlink, /* number of links to file */
  h_rdev, /* maj/min numbers for special files */
  h_mtime[HTIMLEN], /* modification time of file */
  h_namesize, /* length of filename */
  h_filesize[HSIZLEN]; /* size of file */
  char h_name[HNAMLEN]; /* filename */
 } ;
 /* cpio -H odc header format */
 struct c_hdr {
  char c_magic[CMS_LEN],
  c_dev[6],
  c_ino[6],
  c_mode[6],
  c_uid[6],
  c_gid[6],
  c_nlink[6],
  c_rdev[6],
  c_mtime[11],
  c_namesz[6],
  c_filesz[11],
  c_name[HNAMLEN];
 } ;
 /* -c and CRC header format */
 struct Exp_cpio_hdr {
  char E_magic[CMS_LEN],
  E_ino[8],
  E_mode[8],
  E_uid[8],
  E_gid[8],
  E_nlink[8],
  E_mtime[8],
  E_filesize[8],
  E_maj[8],
  E_min[8],
  E_rmaj[8],
  E_rmin[8],
  E_namesize[8],
<beginning of page>
  E_chksum[8],
  E_name[EXPNLEN];
 } ;
 /* Tar header structure and format */
 #define TBLOCK 512 /* length of tar header and data blocks */
 #define TNAMLEN 100 /* maximum length for tar file names */
 #define TMODLEN 8 /* length of mode field */
 #define TUIDLEN 8 /* length of uid field */
 #define TGIDLEN 8 /* length of gid field */
 #define TSIZLEN 12 /* length of size field */
 #define TTIMLEN 12 /* length of modification time field */
 #define TCRCLEN 8 /* length of header checksum field */
 /* tar header definition */
 union tblock {
  char dummy[TBLOCK];
  struct header {
  char t_name[TNAMLEN]; /* name of file */
  char t_mode[TMODLEN]; /* mode of file */
  char t_uid[TUIDLEN]; /* uid of file */
  char t_gid[TGIDLEN]; /* gid of file */
  char t_size[TSIZLEN]; /* size of file in bytes */
  char t_mtime[TTIMLEN]; /* modification time of file */
  char t_chksum[TCRCLEN]; /* checksum of header */
  char t_typeflag; /* flag to indicate type of file */
  char t_linkname[TNAMLEN]; /* file this file is linked with */
  char t_magic[6]; /* magic string always "ustar" */
  char t_version[2]; /* version strings always "00" */
  char t_uname[32]; /* owner of file in ASCII */
  char t_gname[32]; /* group of file in ASCII */
  char t_devmajor[8]; /* major number for special files */
  char t_devminor[8]; /* minor number for special files */
  char t_prefix[155]; /* pathname prefix */
  } tbuf;
 }
 /* volcopy tape label format and structure */
 #define VMAGLEN 8
 #define VVOLLEN 6
 #define VFILLEN 464
 struct volcopy_label {
  char v_magic[VMAGLEN],
  v_volume[VVOLLEN],
  v_reels,
  v_reel;
  long v_time,
  v_length,
  v_dens,
  v_reelblks, /* u370 added field */
  v_blksize, /* u370 added field */
  v_nblocks; /* u370 added field */
  char v_fill[VFILLEN];
  long v_offset; /* used with -e and -reel options */
  int v_type; /* does tape have nblocks field? */
 } ;
 /*
  * Define archive formats for extended attributes.
  *
  * Extended attributes are stored in two pieces.
  * 1. An attribute header which has information about
  * what file the attribute is for and what the attribute
  * is named.
  * 2. The attribute record itself. Stored as a normal file type
  * of entry.
  * Both the header and attribute record have special modes/typeflags
  * associated with them.
  *
<beginning of page>
  * The names of the header in the archive look like:
  * /dev/null/attr.hdr
  *
  * The name of the attribute looks like:
  * /dev/null/attr.
  *
  * This is done so that an archiver that doesn't understand these formats
  * can just dispose of the attribute records unless the user chooses to
  * rename them via cpio -r or pax -i
  *
  * The format is composed of a fixed size header followed
  * by a variable sized xattr_buf. If the attribute is a hard link
  * to another attribute, then another xattr_buf section is included
  * for the link.
  *
  * The xattr_buf is used to define the necessary "pathing" steps
  * to get to the extended attribute. This is necessary to support
  * a fully recursive attribute model where an attribute may itself
  * have an attribute.
  *
  * The basic layout looks like this.
  *
 * --------------------------------
  * | |
  * | xattr_hdr |
  * | |
  * --------------------------------
  * --------------------------------
  * | |
  * | xattr_buf |
  * | |
  * --------------------------------
  * --------------------------------
  * | |
  * | (optional link info) |
  * | |
  * --------------------------------
  * --------------------------------
  * | |
  * | attribute itself |
  * | stored as normal tar |
  * | or cpio data with |
  * | special mode or |
  * | typeflag |
  * | |
  * --------------------------------
  *
  */
 #define XATTR_ARCH_VERS "1.0"
 /*
  * extended attribute fixed header
  *
  * h_version format version.
  * h_size size of header + variable sized data sections.
  * h_component_len Length of entire pathing section.
  * h_link_component_len Length of link component section. Again same
  * definition as h_component_len.
  */
 struct xattr_hdr {
  char h_version[7];
  char h_size[10];
  char h_component_len[10]; /* total length of path component */
  char h_link_component_len[10];
 };
<beginning of page>
 /*
  * The name is encoded like this:
  * filepathNULattrpathNUL[attrpathNULL]...
  */
 struct xattr_buf {
  char h_namesz[7]; /* length of h_names */
  char h_typeflag; /* actual typeflag of file being archived */
  char h_names[1]; /* filepathNULattrpathNUL... */
 };
 /*
  * Special values for tar archives
  */
 /*
  * typeflag for tar archives.
  */
 /*
  * Attribute hdr and attribute files have the following typeflag
  */
 #define _XATTR_HDRTYPE 'E'
 /*
  * For cpio archives the header and attribute have
  * _XATTR_CPIO_MODE ORED into the mode field in both
  * character and binary versions of the archive format
  */
 #define _XATTR_CPIO_MODE 0xB000
aread.9e <beginning of page>
aread <-> asynchronous read from a device
#include <sys/uio.h>
#include <sys/aio_req.h>
#include <sys/cred.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
intprefix
aread(dev_t dev, struct aio_req *aio_reqp, cred_t *cred_p);
Solaris DDI specific (Solaris DDI). This entry point is optional. Drivers that do not support an aread() entry point
should use nodev(9F)
dev Device number.
aio_reqp Pointer to the aio_req(9S) structure that describes where the data is to be stored.
cred_p Pointer to the credential structure.
The driver's aread() routine is called to perform an asynchronous read. getminor(9F) can be used to access the mi<hy>
nor number component of the dev argument. aread() may use the credential structure pointed to by cred_p to check
for superuser access by calling drv_priv(9F). The aread() routine may also examine the uio(9S) structure through
the aio_req structure pointer, aio_reqp. aread() must call aphysio(9F) with the aio_req pointer and a pointer to the
driver's strategy(9E) routine.
No fields of the uio(9S) structure pointed to by aio_req, other than uio_offset or uio_loffset, may be modified for
non-seekable devices.
The aread() routine should return 0 for success, or the appropriate error number.
This function is called from user context only. Example 1 The following is an example of an aread() routine:
 static int
 xxaread(dev_t dev, struct aio_req *aio, cred_t *cred_p)
 {
  int instance;
  struct xxstate *xsp;
  instance = getminor(dev);
  xsp = ddi_get_soft_state(statep, instance);
  /*Verify soft state structure has been allocated */
  if (xsp == NULL)
   return (ENXIO);
  return (aphysio(xxstrategy, anocancel,
      dev, B_READ, xxminphys, aio));  
 }
read(2), aioread(3C), awrite(9E), read(9E), strategy(9E), write(9E), anocancel(9F), aphysio(9F),
ddi_get_soft_state(9F), drv_priv(9F), getminor(9F), minphys(9F), nodev(9F), aio_req(9S), cb_ops(9S), uio(9S)
Writing Device Drivers
There is no way other than calling aphysio(9F) to accomplish an asynchronous read.
arn.7d <beginning of page>
arn <-> Atheros AR9280/9281/9285 IEEE802.11 a/b/g/n wireless network device
The arn IEEE802.11 a/b/g/n wireless driver is a loadable, clonable, GLDv3-based STREAMS driver supporting
Atheros AR9280/9281/9285 IEEE802.11 a/b/g/n wireless network device.
The arn driver performs auto-negotiation to determine the data rate and mode. The driver supports only BSS net<hy>
works (also known as ap or infrastructure networks) and open(or open-system) or shared system authentication.
For wireless security, WEP encryption, WPA-PSK, and WPA2-PSK are currently supported. Configuration and ad<hy>
ministration tasks can be performed with the dladm(1M) and wificonfig(1M) utilities.
/dev/arn Special character device
/kernel/drv/arn 32-bit ELF kernel module (x86)
/kernel/drv/amd64/arn 64-bit ELF kernel driver module (x86)
See attributes(5) for a description of the following attributes:
tab() box; lw(2.75i) |lw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86 _
AvailabilitySUNWarn _ Interface StabilityCommitted
dladm(1M), wificonfig(1M), attributes(5), dlpi(7P), gld(7D)
arp.7p <beginning of page>
arp, ARP <-> Address Resolution Protocol
#include <sys/fcntl.h>
#include <sys/socket.h>
#include <net/if_arp.h>
#include <netinet/in.h>
s = socket(AF_INET, SOCK_DGRAM, 0);
d = open ("/dev/arp", oflag);
ARP is a protocol used to map dynamically between Internet Protocol (IP) and Ethernet addresses. It is used by all
Ethernet datalink providers (network drivers) and can be used by other datalink providers that support broadcast, in<hy>
cluding FDDI and Token Ring. The only network layer supported in this implementation is the Internet Protocol,
although ARP is not specific to that protocol.
ARP caches IP-to-link-layer address mappings. When an interface requests a mapping for an address not in the
cache, ARP queues the message that requires the mapping and broadcasts a message on the associated network re<hy>
questing the address mapping. If a response is provided, ARP caches the new mapping and transmits any pending
message. ARP will queue a maximum of four packets while awaiting a response to a mapping request. ARP keeps
only the first four transmitted packets.
The STREAMS device /dev/arp is not a Transport Level Interface (TLI) transport provider and may not be used
with the TLI interface.
To facilitate communications with systems that do not use ARP, ioctl() requests are provided to enter and delete
entries in the IP-to-link address tables. Ioctls that change the table contents require sys_net_config privilege. See
privileges(5).
 #include <sys/sockio.h>
 #include <sys/socket.h>
 #include <net/if.h>
 #include <net/if_arp.h>
 struct arpreq arpreq;
 ioctl(s, SIOCSARP, (caddr_t)&arpreq);
 ioctl(s, SIOCGARP, (caddr_t)&arpreq);
 ioctl(s, SIOCDARP, (caddr_t)&arpreq);
SIOCSARP, SIOCGARP and SIOCDARP are BSD compatible ioctls. These ioctls do not communicate the mac
address length between the user and the kernel (and thus only work for 6 byte wide Ethernet addresses). To manage
the ARP cache for media that has different sized mac addresses, use SIOCSXARP, SIOCGXARP and
SIOCDXARP ioctls.
 #include <sys/sockio.h>
 #include <sys/socket.h>
 #include <net/if.h>
 #include <net/if_dl.h>
 #include <net/if_arp.h>
 struct xarpreq xarpreq;
 ioctl(s, SIOCSXARP, (caddr_t)&xarpreq);
 ioctl(s, SIOCGXARP, (caddr_t)&xarpreq);
 ioctl(s, SIOCDXARP, (caddr_t)&xarpreq);
Each ioctl() request takes the same structure as an argument. SIOCS[X]ARP sets an ARP entry, SIOCG[X]ARP
gets an ARP entry, and SIOCD[X]ARP deletes an ARP entry. These ioctl() requests may be applied to any Internet
family socket descriptors, or to a descriptor for the ARP device. Note that SIOCS[X]ARP and SIOCD[X]ARP re<hy>
quire a privileged user, while SIOCG[X]ARP
does not.
The arpreq structure contains
<beginning of page>
 /*
 * ARP ioctl request
 */
 struct arpreq {
  struct sockaddr arp_pa; /* protocol address */
  struct sockaddr arp_ha; /* hardware address */
  int arp_flags; /* flags */
 };
The xarpreq structure contains:
 /*
 * Extended ARP ioctl request
 */
 struct xarpreq {
  struct sockaddr_storage xarp_pa; /* protocol address */
  struct sockaddr_dl xarp_ha; /* hardware address */
  int xarp_flags; /* arp_flags field values */
 };
 #define ATF_COM 0x2 /* completed entry (arp_ha valid) */
 #define ATF_PERM 0x4 /* permanent (non-aging) entry */
 #define ATF_PUBL 0x8 /* publish (respond for other host) */
 #define ATF_USETRAILERS 0x10 /* send trailer pckts to host */
 #define ATF_AUTHORITY 0x20 /* hardware address is authoritative */
The address family for the [x]arp_pa sockaddr must be AF_INET. The ATF_COM flag bits ([x]arp_flags) cannot
be altered. ATF_USETRAILERS is not implemented on Solaris and is retained for compatibility only.
ATF_PERM makes the entry permanent (disables aging) if the ioctl() request succeeds. ATF_PUBL specifies that
the system should respond to ARP requests for the indicated protocol address coming from other machines. This al<hy>
lows a host to act as an ARP server, which may be useful in convincing an ARP-only machine to talk to a non-ARP
machine. ATF_AUTHORITY indicates that this machine owns the address. ARP does not update the entry based
on received packets.
The address family for the arp_ha sockaddr must be AF_UNSPEC.
Before invoking any of the SIOC*XARP ioctls, user code must fill in the xarp_pa field with the protocol (IP) ad<hy>
dress information, similar to the BSD variant. The SIOC*XARP ioctls come in two (legal) varieties, depending on
xarp_ha.sdl_nlen: 1. if sdl_nlen = 0, it behaves as an extended BSD ioctl. The kernel uses the IP address to deter<hy>
mine the network interface. 2. if (sdl_nlen > 0) and (sdl_nlen < LIFNAMSIZ), the kernel uses the interface name
in sdl_data[0] to determine the network interface; sdl_nlen represents the length of the string (excluding terminating
null character). 3. if (sdl_nlen >= LIFNAMSIZ), an error (EINVAL) is flagged from the ioctl.
Other than the above, the xarp_ha structure should be 0-filled except for SIOCSXARP, where the sdl_alen field
must be set to the size of hardware address length and the hardware address itself must be placed in the LLAD<hy>
DR/sdl_data[] area. (EINVAL will be returned if user specified sdl_alen does not match the address length of the
identified interface).
On return from the kernel on a SIOCGXARP ioctl, the kernel fills in the name of the interface (excluding terminat<hy>
ing NULL) and its hardware address, one after another, in the sdl_data/LLADDR area; if the two are larger than
can be held in the 244 byte sdl_data[] area, an ENOSPC error is returned. Assuming it fits, the kernel will also set
sdl_alen with the length of hardware address, sdl_nlen with the length of name of the interface (excluding terminat<hy>
ing NULL), sdl_type with an IFT_* value to indicate the type of the media, sdl_slen with 0, sdl_family with
AF_LINK and sdl_index (which if not 0) with system given index for the interface. The information returned is
very similar to that returned via routing sockets on an RTM_IFINFO message.
The ARP ioctls have several additional restrictions and enhancements when used in conjunction with IPMP: <bu> ARP
mappings for IPMP data and test addresses are managed by the kernel and cannot be changed through ARP ioctls,
though they may be retrieved using SIOCGARP or SIOCGXARP. <bu> ARP mappings for a given IPMP group must
be consistent across the group. As a result, ARP mappings cannot be associated with individual underlying IP in<hy>
terfaces in an IPMP group and must instead be associated with the corresponding IPMP IP interface. <bu> roxy ARP
mappings for an IPMP group are automatically managed by the kernel. Specifically, if the hardware address in a
SIOCSARP or SIOCSXARP request matches the hardware address of an IP interface in an IPMP group and the
IP address is not local to the system, the kernel regards this as a IPMP Proxy ARP entry. This IPMP Proxy ARP
<beginning of page>
entry will have its hardware address automatically adjusted in order to keep the IP address reachable (provided
the IPMP group has not entirely failed).
 <em>
 <em>
 <em>P
ARP performs duplicate address detection for local addresses. When a logical interface is brought up (IFF_UP) or
any time the hardware link goes up (IFF_RUNNING), ARP sends probes (ar$spa == 0) for the assigned address. If
a conflict is found, the interface is torn down. See ifconfig(1M) for more details.
ARP watches for hosts impersonating the local host, that is, any host that responds to an ARP request for the local
host's address, and any address for which the local host is an authority. ARP defends local addresses and logs those
with ATF_AUTHORITY set, and can tear down local addresses on an excess of conflicts.
ARP also handles UNARP messages received from other nodes. It does not generate these messages.
The arp driver registers itself with the netinfo interface. To gain access to these events, a handle from net_proto<hy>
col_lookup must be acquired by passing it the value NHF_ARP. Through this interface, two packet events are sup<hy>
ported:
Physical in - ARP packets received via a network inter face
Physical out - ARP packets to be sent out via a network interface
For ARP packets, the hook_pkt_event structure is filled out as follows:
hpe_ifp
Identifier indicating the inbound interface for packets received with the physical in event.
hpe_ofp
Identifier indicating the outbound interface for packets received with the physical out event.
hpe_hdr
Pointer to the start of the ARP header (not the ethernet header).
hpe_mp
Pointer to the start of the mblk_t chain containing the ARP packet.
hpe_mb
Pointer to the mblk_t with the ARP header in it.
In addition to events describing packets as they move through the system, it is also possible to receive notification
of events relating to network interfaces. These events are all reported back through the same callback. The list of
events is as follows:
plumb
A new network interface has been instantiated.
unplumb
A network interface is no longer associated with ARP.
arp(1M), ifconfig(1M), privileges(5), if_tcp(7P), inet(7P), netinfo(9F)
Plummer, Dave, An Ethernet Address Resolution Protocol or Converting Network Protocol Addresses to 48 .bit
Ethernet Addresses for Transmission on Ethernet Hardware, RFC 826, STD 0037, November 1982.
<beginning of page>
Malkin, Gary, ARP Extension - UNARP, RFC 1868, November, 1995
Several messages can be written to the system logs (by the IP module) when errors occur. In the following exam<hy>
ples, the hardware address strings include colon (:) separated ASCII representations of the link layer addresses,
whose lengths depend on the underlying media (for example, 6 bytes for Ethernet).
Node %x:%x ... %x:%x is using our IP address %d.%d.%d.%d on %s.
Duplicate IP address warning. ARP has discovered another host on a local network that responds to mapping re<hy>
quests for the Internet address of this system, and has defended the system against this node by re-announcing the
ARP entry.
%s has duplicate address %d.%d.%d.%d (in use by %x:%x ... %x:%x); disabled.
Duplicate IP address detected while performing initial probing. The newly-configured interface has been shut down.
%s has duplicate address %d.%d.%d.%d (claimed by %x:%x ... %x:%x); disabled.
Duplicate IP address detected on a running IP interface. The conflict cannot be resolved, and the interface has been
disabled to protect the network.
Recovered address %d.%d.%d.%d on %s.
An interface with a previously-conflicting IP address has been recovered automatically and reenabled. The conflict
has been resolved.
Proxy ARP problem? Node '%x:%x ... %x:%x' is using %d.%d.%d.%d on %s
This message appears if arp(1M) has been used to create a published permanent (ATF_AUTHORITY) entry, and
some other host on the local network responds to mapping requests for the published ARP entry.
asa.1 <beginning of page>
asa <-> convert FORTRAN carriage-control output to printable form
asa [-f] [file]...
The asa utility will write its input files to standard output, mapping carriage-control characters from the text files to
line-printer control sequences.
The first character of every line will be removed from the input, and the following actions will be performed.
If the character removed is:
SPACE The rest of the line will be output without change.
0 It is replaced by a newline control sequence followed by the rest of the input line.
1 It is replaced by a newpage control sequence followed by the rest of the input line.
+ It is replaced by a control sequence that causes printing to return to the first column of the previous line, where
the rest of the input line is printed.
For any other character in the first column of an input line, asa skips the character and prints the rest of the line un<hy>
changed.
If asa is called without providing a filename, the standard input is used.
The following option is supported:
-f Start each file on a new page.
The following operand is supported:
file A pathname of a text file used for input. If no file operands are specified, or `<mi>' is specified, then the standard
input will be used.
The command
 a.out | asa | lp
converts output from a.out to conform with conventional printers and directs it through a pipe to the printer.
The command
 asa output
shows the contents of file output on a terminal as it would appear on a printer.
The following program is used in the next two examples:
 write(*,'(" Blank")')
 write(*,'("0Zero ")')
 write(*,'("+ Plus ")')
 write(*,'("1One ")')
 end
Both of the following examples produce two pages of output:
<beginning of page>
Page 1:
 Blank
 ZeroPlus
Page 2:
 One
Example 1 Using actual files
 a.out > MyOutputFile
 asa < MyOutputFile | lp
Example 2 Using only pipes
 a.out | asa | lp
See environ(5) for descriptions of the following environment variables that affect the execution of asa: LANG,
LC_ALL, LC_CTYPE, LC_MESSAGES, and NLSPATH.
The following exit values are returned:
0 All input files were output successfully.
>0 An error occurred.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ Interface StabilityStandard
lp(1), attributes(5), environ(5), standards(5)
asin.3m <beginning of page>
asin, asinf, asinl <-> arc sine function
c99 [ flag... ] file... -lm [ library... ]
#include <math.h>
double asin(double x);
float asinf(float x);
long double asinl(long double x);
These functions compute the principal value of the arc sine of their argument x. The value of x should be in the range
[<mi>1,1].
Upon successful completion, these functions return the arc sine of x in the range [<mi><*p> /2, <*p> /2] radians.
For finite values of x not in the range [<mi>1,1], a domain error occurs and a NaN is returned.
If x is NaN, NaN is returned.
If x is <+->0, x is returned.
If x is <+->Inf, a domain error occurs and a NaN is returned.
For exceptional cases, matherr(3M) tabulates the values to be returned by asin() as specified by SVID3 and XPG3.
These functions will fail if:
Domain Error The x argument is finite and not in the range [<mi>1,1], or is <+->Inf.
If the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, the invalid floating-point ex<hy>
ception is raised.
The asin() function sets errno to EDOM if x is not <+->Inf or NaN and is not in the range [<mi>1,1].
An application wanting to check for exceptions should call feclearexcept(FE_ALL_EXCEPT) before calling these
functions. On return, if fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDER<hy>
FLOW) is non-zero, an exception has been raised. An application should either examine the return value or check
the floating point exception flags to detect exceptions.
An application can also set errno to 0 before calling asin(). On return, if errno is non-zero, an error has occurred.
The asinf() and asinl() functions do not set errno.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
isnan(3M), feclearexcept(3M), fetestexcept(3M), math.h(3HEAD), matherr(3M), sin(3M), attributes(5), stan<hy>
dards(5)
assert.3c <beginning of page>
assert <-> verify program assertion
#include <assert.h>
void assert(int expression);
The assert() macro inserts diagnostics into applications. When executed, if expression is FALSE (zero), assert()
prints the error message
 Assertion failed: expression, file xyz, line nnn
on the standard error output and aborts. In the error message, xyz is the name of the source file and nnn the source
line number of the assert() statement. These are respectively the values of the preprocessor macros __FILE__ and
__LINE__.
Since assert() is implemented as a macro, the expression may not contain any string literals.
Compiling with the preprocessor option -DNDEBUG or with the preprocessor control statement #define NDEBUG
ahead of the #include <assert.h> statement, will stop assertions from being compiled into the program.
Messages printed from this function are in the native language specified by the LC_MESSAGES locale category.
See setlocale(3C).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelSafe _ StandardSee standards(5).
abort(3C), gettext(3C), setlocale(3C), attributes(5), standards(5)
assert.h.3head <beginning of page>
assert.h, assert <-> verify program assertion
#include <assert.h>
The <assert.h> header defines the assert() macro. It refers to the macro NDEBUG which is not defined in the head<hy>
er. If NDEBUG is defined as a macro name before the inclusion of this header, the assert() macro is defined simply
as:
 #define assert(ignore)((void) 0)
Otherwise, the macro behaves as described in assert(3C).
The assert() macro is redefined according to the current state of NDEBUG each time <assert.h> is included.
The assert() macro is implemented as a macro, not as a function. If the macro definition is suppressed in order to ac<hy>
cess an actual function, the behavior is undefined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard
assert(3C), attributes(5), standards(5)
at.1 <beginning of page>
at, batch <-> execute commands at a later time
/usr/bin/at [-c | -k | -s] [-m] [-f file] [-p project]
 [-q queuename] -t time
/usr/bin/at [-c | -k | -s] [-m] [-f file] [-p project]
 [-q queuename] timespec...
/usr/bin/at -l [-p project] [-q queuename] [at_job_id. ..]
/usr/bin/at -r at_job_id. ..
/usr/bin/batch [-p project]
/usr/xpg4/bin/at [-c | -k | -s] [-m] [-f file] [-p project]
 [-q queuename] -t time
/usr/xpg4/bin/at [-c | -k | -s] [-m] [-f file] [-p project]
 [-q queuename] timespec...
/usr/xpg4/bin/at -l [-p project] [-q queuename]
 [at_job_id. ..]
/usr/xpg4/bin/at -r at_job_id. ..
/usr/xpg4/bin/batch [-p project]
The at utility reads commands from standard input and groups them together as an at-job, to be executed at a later
time.
The at-job is executed in a separate invocation of the shell, running in a separate process group with no controlling
terminal, except that the environment variables, current working directory, file creation mask (see umask(1)), and
system resource limits (for sh and ksh only, see ulimit(1)) in effect when the at utility is executed is retained and
used when the at-job is executed.
When the at-job is submitted, the at_job_id and scheduled time are written to standard error. The at_job_id is an
identifier that is a string consisting solely of alphanumeric characters and the period character. The at_job_id is as<hy>
signed by the system when the job is scheduled such that it uniquely identifies a particular job.
User notification and the processing of the job's standard output and standard error are described under the -m op<hy>
tion.
Users are permitted to use at and batch (see below) if their name appears in the file /usr/lib/cron/at.allow. If that
file does not exist, the file /usr/lib/cron/at.deny is checked to determine if the user should be denied access to at. If
neither file exists, only a user with the solaris.jobs.user authorization is allowed to submit a job. If only at.deny ex<hy>
ists and is empty, global usage is permitted. The at.allow and at.deny files consist of one user name per line.
cron and at jobs are not be executed if the user's account is locked. Only accounts which are not locked as defined
in shadow(4) will have their job or process executed.
The batch utility reads commands to be executed at a later time.
Commands of the forms:
 /usr/bin/batch [-p project]
 /usr/xpg4/bin/batch [-p project]
are respectively equivalent to:
 /usr/bin/at -q b [-p project] now
 /usr/xpg4/bin/at -q b -m [-p project] now
<beginning of page>
where queue b is a special at queue, specifically for batch jobs. Batch jobs are submitted to the batch queue for im<hy>
mediate execution. Execution of submitted jobs can be delayed by limits on the number of jobs allowed to run con<hy>
currently. See queuedefs(4).
If the -c, -k, or -s options are not specified, the SHELL environment variable by default determines which shell to
use.
For /usr/xpg4/bin/at and /usr/xpg4/bin/batch, if SHELL is unset or NULL, /usr/xpg4/bin/sh is used.
For usr/bin/at and /usr/bin/batch, if SHELL is unset or NULL, /bin/sh is used.
The following options are supported:
-c C shell. csh(1) is used to execute the at-job.
-k Korn shell. ksh(1) is used to execute the at-job.
-s Bourne shell. sh(1) is used to execute the at-job.
-f file Specifies the path of a file to be used as the source of the at-job, instead of standard input.
-l (The letter ell.) Reports all jobs scheduled for the invoking user if no at_job_id operands are specified. If
at_job_ids are specified, reports only information for these jobs.
-m Sends mail to the invoking user after the at-job has run, announcing its completion. Standard output and standard
error produced by the at-job are mailed to the user as well, unless redirected elsewhere. Mail is sent even if the job
produces no output.
If -m is not used, the job's standard output and standard error is provided to the user by means of mail, unless they
are redirected elsewhere; if there is no such output to provide, the user is not notified of the job's completion.
-p project Specifies under which project the at or batch job is run. When used with the -l option, limits the search to
that particular project. Values for project is interpreted first as a project name, and then as a possible project ID, if
entirely numeric. By default, the user's current project is used.
-q queuename Specifies in which queue to schedule a job for submission. When used with the -l option, limits the
search to that particular queue. Values for queuename are limited to the lower case letters a through z. By default, at-
jobs are scheduled in queue a. In contrast, queue b is reserved for batch jobs. Since queue c is reserved for cron jobs,
it can not be used with the -q option.
-r at_job_id Removes the jobs with the specified at_job_id operands that were previously scheduled by the at utility.
-t time Submits the job to be run at the time specified by the time option-argument, which must have the format as
specified by the touch(1) utility.
The following operands are supported:
at_job_id The name reported by a previous invocation of the at utility at the time the job was scheduled.
timespec Submit the job to be run at the date and time specified. All of the timespec operands are interpreted as if
they were separated by space characters and concatenated. The date and time are interpreted as being in the time<hy>
zone of the user (as determined by the TZ variable), unless a timezone name appears as part of time below.
In the "C" locale, the following describes the three parts of the time specification string. All of the values from the
LC_TIME categories in the "C" locale are recognized in a case-insensitive manner.
<beginning of page>
time The time can be specified as one, two or four digits. One- and two-digit numbers are taken to be hours, four-
digit numbers to be hours and minutes. The time can alternatively be specified as two numbers separated by a colon,
meaning hour:minute. An AM/PM indication (one of the values from the am_pm keywords in the LC_TIME locale
category) can follow the time; otherwise, a 24-hour clock time is understood. A timezone name of GMT, UCT, or
ZULU (case insensitive) can follow to specify that the time is in Coordinated Universal Time. Other timezones can
be specified using the TZ environment variable. The time field can also be one of the following tokens in the "C" lo<hy>
cale:
midnight Indicates the time 12:00 am (00:00).
noon Indicates the time 12:00 pm.
now Indicate the current day and time. Invoking at now submits an at-job for potentially immediate execution (that
is, subject only to unspecified scheduling delays).
date An optional date can be specified as either a month name (one of the values from the mon or abmon keywords
in the LC_TIME locale category) followed by a day number (and possibly year number preceded by a comma) or a
day of the week (one of the values from the day or abday keywords in the LC_TIME locale category). Two special
days are recognized in the "C" locale:
today Indicates the current day.
tomorrow Indicates the day following the current day.
If no date is given, today is assumed if the given time is greater than the current time, and tomorrow is assumed if it
is less. If the given month is less than the current month (and no year is given), next year is assumed.
increment The optional increment is a number preceded by a plus sign (+) and suffixed by one of the following:
minutes, hours, days, weeks, months, or years. (The singular forms are also accepted.) The keyword next is equiv<hy>
alent to an increment number of + 1. For example, the following are equivalent commands:
 at 2pm + 1 week
 at 2pm next week
The format of the at command line shown here is guaranteed only for the "C" locale. Other locales are not supported
for midnight, noon, now, mon, abmon, day, abday, today, tomorrow, minutes, hours, days, weeks, months,
years, and next.
Since the commands run in a separate shell invocation, running in a separate process group with no controlling ter<hy>
minal, open file descriptors, traps and priority inherited from the invoking environment are lost. Example 1 Typical
Sequence at a Terminal
This sequence can be used at a terminal:
 $ at <mi>m 0730 tomorrow
 sort < file >outfile
 <EOT>
Example 2 Redirecting Output
This sequence, which demonstrates redirecting standard error to a pipe, is useful in a command procedure (the se<hy>
quence of output redirection specifications is significant):
<beginning of page>
 $ at now + 1 hour <<!
 diff file1 file2 2>&1 >outfile | mailx mygroup
Example 3 Self-rescheduling a Job
To have a job reschedule itself, at can be invoked from within the at-job. For example, this "daily-processing" script
named my.daily runs every day (although crontab is a more appropriate vehicle for such work):
 # my.daily runs every day
 at now tomorrow < my.daily
 daily-processing
Example 4 Various Time and Operand Presentations
The spacing of the three portions of the "C" locale timespec is quite flexible as long as there are no ambiguities. Ex<hy>
amples of various times and operand presentations include:
 at 0815am Jan 24
 at 8 :15amjan24
 at now "+ 1day"
 at 5 pm FRIday
 at '17
  utc+
  30minutes'
Example 5 Typical Sequence at a Terminal
This sequence can be used at a terminal:
 $ batch
 sort <file >outfile
 <EOT>
Example 6 Redirecting Output
This sequence, which demonstrates redirecting standard error to a pipe, is useful in a command procedure (the se<hy>
quence of output redirection specifications is significant):
 $ batch <<!
 diff file1 file2 2>&1 >outfile | mailx mygroup
 !
See environ(5) for descriptions of the following environment variables that affect the execution of at and batch:
LANG, LC_ALL, LC_CTYPE, LC_MESSAGES, NLSPATH, and LC_TIME.
DATEMSK If the environment variable DATEMSK is set, at uses its value as the full path name of a template file
containing format strings. The strings consist of format specifiers and text characters that are used to provide a richer
set of allowable date formats in different languages by appropriate settings of the environment variable LANG or
LC_TIME. The list of allowable format specifiers is located in the getdate(3C) manual page. The formats described
in the OPERANDS section for the time and date arguments, the special names noon, midnight, now, next, today,
tomorrow, and the increment argument are not recognized when DATEMSK is set.
SHELL Determine a name of a command interpreter to be used to invoke the at-job. If the variable is unset or
NULL, sh is used. If it is set to a value other than sh, the implementation uses that shell; a warning diagnostic is
<beginning of page>
printed telling which shell will be used.
TZ Determine the timezone. The job is submitted for execution at the time specified by timespec or -t time relative
to the timezone specified by the TZ variable. If timespec specifies a timezone, it overrides TZ. If timespec does not
specify a timezone and TZ is unset or NULL, an unspecified default timezone is used.
The following exit values are returned:
0 The at utility successfully submitted, removed or listed a job or jobs.
>0 An error occurred, and the job will not be scheduled.
/usr/lib/cron/at.allow names of users, one per line, who are authorized access to the at and batch utilities
/usr/lib/cron/at.deny names of users, one per line, who are denied access to the at and batch utilities
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ CSINot enabled _ Interface StabilityStandard
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wxcu4 _ CSINot enabled _ Interface StabilityStandard
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wesu _ CSIEnabled _ Interface StabilityStandard
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wxcu4 _ CSIEnabled _ Interface StabilityStandard
auths(1), crontab(1), csh(1), date(1), ksh(1), sh(1), touch(1), ulimit(1), umask(1), cron(1M), getdate(3C),
auth_attr(4), shadow(4), queuedefs(4), attributes(5), environ(5), standards(5)
Regardless of queue used, cron(1M) has a limit of 100 jobs in execution at any time.
There can be delays in cron at job execution. In some cases, these delays can compound to the point that cron job
processing appears to be hung. All jobs are executed eventually. When the delays are excessive, the only workaround
is to kill and restart cron.
atan2.3m <beginning of page>
atan2, atan2f, atan2l <-> arc tangent function
c99 [ flag... ] file... -lm [ library... ]
#include <math.h>
double atan2(double y, double x);
float atan2f(float y, float x);
long double atan2l(long double y, long double x);
These functions compute the principal value of the arc tangent of y/x, using the signs of both arguments to determine
the quadrant of the return value.
Upon successful completion, these functions return the arc tangent of y/x in the range [ <mi><*p> ,<*p>  ] radians.
If y is <+->0 and x is < 0, <+-><*p>  is returned.
If y is <+->0 and x is > 0, <+->0 is returned.
If y is < 0 and x is <+->0, <mi><*p> /2 is returned.
If y is > 0 and x is <+->0, <*p> /2 is returned.
If x is 0, a pole error does not occur.
If either x or y is NaN, a NaN is returned.
If y is <+->0 and x is -0, <+-><*p>  is returned.
If y is <+->0 and x is +0, <+->0 is returned.
For finite values of <+->y > 0, if x is <mi>Inf, <+-><*p>  is returned.
For finite values of <+->y > 0, if x is +Inf, <+->0 is returned.
For finite values of x, if y is <+->Inf, <+-><*p> /2 is returned.
If y is <+->Inf and x is <mi>Inf, <+->3<*p> /4 is returned.
If y is <+->Inf and x is +Inf, <+-><*p> /4 is returned.
If both arguments are 0, a domain error does not occur.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
atan(3M), isnan(3M), math.h(3HEAD)tan(3M), attributes(5), standards(5)
atanh.3m <beginning of page>
atanh, atanhf, atanhl <-> inverse hyperbolic tangent functions
c99 [ flag... ] file... -lm [ library... ]
#include <math.h>
double atanh(double x);
float atanhf(float x);
long double atanhl(long double x);
These functions compute the inverse hyperbolic tangent of their argument x.
Upon successful completion, these functions return the inverse hyperbolic tangent of their argument.
If x is <+->1, a pole error occurs and atanh(), atanhf(), and atanhl() return the value of the macro HUGE_VAL,
HUGE_VALF, and HUGE_VALL, respectively, with the same sign as the correct value of the function.
For finite |x| > 1, a domain error occurs and a NaN is returned.
If x is NaN, NaN is returned.
If x is +0, x is returned.
If x is +Inf, a domain error occurs and a NaN is returned.
For exceptional cases, matherr(3M) tabulates the values to be returned by atanh() as specified by SVID3 and
XPG3.
These functions will fail if:
Domain Error The x argument is finite and not in the range [-1,1], or is <+->Inf.
If the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, the invalid floating-point ex<hy>
ception is raised.
The atanh() function sets errno to EDOM if the absolute value of x is greater than 1.0.
Pole Error The x argument is <+->1.
If the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-
point exception is raised.
The atanh() function sets errno to ERANGE if the absolute value of x is equal to 1.0.
An application wanting to check for exceptions should call feclearexcept(FE_ALL_EXCEPT) before calling these
functions. On return, if fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDER<hy>
FLOW) is non-zero, an exception has been raised. An application should either examine the return value or check
the floating point exception flags to detect exceptions.
An application can also set errno to 0 before calling atanh(). On return, if errno is non-zero, an error has occurred.
The atanhf() and atanhl() functions do not set errno.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
feclearexcept(3M), fetestexcept(3M), math.h(3HEAD), matherr(3M), tanh(3M), attributes(5), standards(5)
atge.7d <beginning of page>
atge <-> Device driver for Atheros/Attansic Ethernet chipsets
The atge ethernet driver is GLD based supporting the Atheros/Attansic L1E Gigabit Ethernet 10/100/1000 Base
(AR8121/AR8113) chipsets:
 pciex1969,1026 Atheros/Attansic GigabitE 10/100/1000 Base (AR8121/AR8113)
The atge driver supports IEEE 802.3 auto-negotiation, flow control and VLAN tagging.
The default configuration is auto-negotiation with bi-directional flow control. The advertised capabilities for auto-
negotiation are based on the capabilities of the PHY.
You can set the capabilities advertised by the atge controlled device using dladm(1M). The driver supports only
those parameters which begin with en (enabled) in the parameters listed by the command dladm(1M). Each of these
boolean parameters determines if the device advertises that mode of operation when the hardware supports it.
/dev/atge Special character device
/kernel/drv/atge 32-bit device drive (x86)
/kernel/drv/amd64/atge 64-bit device driver (x86)
See attributes(5) for a description of the following attribute:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC, x86
dladm(1M), ndd(1M), netstat(1M), driver.conf(4), attributes(5), ieee802.3(5), dlpi(7P), streamio(7I)
Writing Device Drivers
Network Interface Guide
STREAMS Programmer's Guide
IEEE 802.3ae Specification, 2002
atohexlabel.1m <beginning of page>
atohexlabel <-> convert a human readable label to its internal text equivalent
/usr/sbin/atohexlabel [human-readable-sensitivity-label]
/usr/sbin/atohexlabel -c [human-readable-clearance]
atohexlabel converts a human readable label into an internal text representation that is safe for storing in a public
object. If no option is supplied, the label is assumed to be a sensitivity label.
Internal conversions can later be parsed to their same value. This internal form is often hexadecimal. The converted
label is written to the standard output file. If no human readable label is specified, the label is read from the standard
input file. The expected use of this command is emergency repair of labels that are stored in internal databases.
-c Identifies the human readable label as a clearance.
The following exit values are returned:
0 On success.
1 On failure, and writes diagnostics to the standard error file.
/etc/security/tsol/label_encodings
The label encodings file contains the classification names, words, constraints, and values for the defined labels of
this system.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Availability<hy>
SUNWtsu _ Interface StabilitySee below.
The command output is Committed for systems with the same label_encodings file. The command invocation is
Committed for systems that implement the DIA MAC policy.
hextoalabel(1M), label_to_str(3TSOL), str_to_label(3TSOL), label_encodings(4), attributes(5)
How to Get the Hexadecimal Equivalent for a Label in Solaris Trusted Extensions Administrator's Procedures
The functionality described on this manual page is available only if the system is configured with Trusted Exten<hy>
sions.
This file is part of the Defense Intelligence Agency (DIA) Mandatory Access Control (MAC) policy. This file might
not be applicable to other MAC policies that might be developed for future releases of Solaris Trusted Extensions
software.
atomic_add.9f <beginning of page>
atomic_add, atomic_add_8, atomic_add_char, atomic_add_16, atomic_add_short, atomic_add_32, atomic_add_int,
atomic_add_long, atomic_add_64, atomic_add_ptr, atomic_add_8_nv, atomic_add_char_nv, atomic_add_16_nv,
atomic_add_short_nv, atomic_add_32_nv, atomic_add_int_nv, atomic_add_long_nv, atomic_add_64_nv, atom<hy>
ic_add_ptr_nv <-> atomic add operations
#include <sys/atomic.h>
void atomic_add_8(volatile uint8_t *target, int8_t delta);
void atomic_add_char(volatile uchar_t *target, signed char delta);
void atomic_add_16(volatile uint16_t *target, int16_t delta);
void atomic_add_short(volatile ushort_t *target, short delta);
void atomic_add_32(volatile uint32_t *target, int32_t delta);
void atomic_add_int(volatile uint_t *target, int delta);
void atomic_add_long(volatile ulong_t *target, long delta);
void atomic_add_64(volatile uint64_t *target, int64_t delta);
void atomic_add_ptr(volatile void *target, ssize_t delta);
uint8_t atomic_add_8_nv(volatile uint8_t *target, int8_t delta);
uchar_t atomic_add_char_nv(volatile uchar_t *target, signed char delta);
uint16_t atomic_add_16_nv(volatile uint16_t *target, int16_t delta);
ushort_t atomic_add_short_nv(volatile ushort_t *target, shortdelta);
uint32_t atomic_add_32_nv(volatile uint32_t *target, int32_t delta);
uint_t atomic_add_int_nv(volatile uint_t *target, int delta);
ulong_t atomic_add_long_nv(volatile ulong_t *target, long delta);
uint64_t atomic_add_64_nv(volatile uint64_t *target, int64_t delta);
void *atomic_add_ptr_nv(volatile void *target, ssize_t delta);
These functions enable the addition of delta to the value stored in target to occur in an atomic manner.
The *_nv() variants of these functions return the new value of target.
No errors are defined.
These functions can be called from user, interrupt, or kernel context.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed
atomic_and(9F), atomic_bits(9F), atomic_cas(9F), atomic_dec(9F), atomic_inc(9F), atomic_or(9F), atom<hy>
ic_swap(9F), membar_ops(9F), attributes(5), atomic_ops(3C)
The *_nv() variants are substantially more expensive on some platforms than the versions that do not return values.
Do not use them unless you need to know the new value atomically (for example, when decrementing a reference
count and checking whether it went to zero).
atomic_and.9f <beginning of page>
atomic_and, atomic_and_8, atomic_and_uchar, atomic_and_16, atomic_and_ushort, atomic_and_32, atom<hy>
ic_and_uint, atomic_and_ulong, atomic_and_64, atomic_and_8_nv, atomic_and_uchar_nv, atomic_and_16_nv,
atomic_and_ushort_nv, atomic_and_32_nv, atomic_and_uint_nv, atomic_and_ulong_nv, atomic_and_64_nv <-> atom<hy>
ic AND operations
#include <sys/atomic.h>
void atomic_and_8(volatile uint8_t *target, uint8_t bits);
void atomic_and_uchar(volatile uchar_t *target, uchar_t bits);
void atomic_and_16(volatile uint16_t *target, uint16_t bits);
void atomic_and_ushort(volatile ushort_t *target, ushort_t bits);
void atomic_and_32(volatile uint32_t *target, uint32_t bits);
void atomic_and_uint(volatile uint_t *target, uint_t bits);
void atomic_and_ulong(volatile ulong_t *target, ulong_t bits);
void atomic_and_64(volatile uint64_t *target, uint64_t bits);
uint8_t atomic_and_8_nv(volatile uint8_t *target, uint8_t bits);
uchar_t atomic_and_uchar_nv(volatile uchar_t *target, uchar_t bits);
uint16_t atomic_and_16_nv(volatile uint16_t *target, uint16_t bits);
ushort_t atomic_and_ushort_nv(volatile ushort_t *target, ushort_t bits);
uint32_t atomic_and_32_nv(volatile uint32_t *target, uint32_t bits);
uint_t atomic_and_uint_nv(volatile uint_t *target, uint_t bits);
ulong_t atomic_and_ulong_nv(volatile ulong_t *target, ulong_t bits);
uint64_t atomic_and_64_nv(volatile uint64_t *target, uint64_t bits);
These functions enable the bitwise AND of bits to the value stored in target to occur in an atomic manner.
The *_nv() variants of these functions return the new value of target.
No errors are defined.
These functions can be called from user, interrupt, or kernel context.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed
atomic_add(9F), atomic_bits(9F), atomic_cas(9F), atomic_dec(9F), atomic_inc(9F), atomic_or(9F), atom<hy>
ic_swap(9F), membar_ops(9F), attributes(5), atomic_ops(3C)
The *_nv() variants are substantially more expensive on some platforms than the versions that do not return values.
Do not use them unless you need to know the new value atomically.
atomic_bits.9f <beginning of page>
atomic_bits, atomic_set_long_excl, atomic_clear_long_excl <-> atomic set and clear bit operations
#include <sys/atomic.h>
int atomic_set_long_excl(volatile ulong_t *target, uint_t bit);
int atomic_clear_long_excl(volatile ulong_t *target, uint_t bit);
The atomic_set_long_excl() and atomic_clear_long_excl() functions perform an exclusive atomic bit set or clear
operation on target. The value of bit specifies the number of the bit to be modified within target. Bits are numbered
from zero to one less than the maximum number of bits in a long. If the value of bit falls outside of this range, the
result of the operation is undefined.
The atomic_set_long_excl() and atomic_clear_long_excl() functions return 0 if bit was successfully set or cleared.
They return -1 if bit was already set or cleared.
No errors are defined.
These functions can be called from user, interrupt, or kernel context.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed
atomic_add(9F), atomic_and(9F), atomic_cas(9F), atomic_dec(9F), atomic_inc(9F), atomic_or(9F), atom<hy>
ic_swap(9F), membar_ops(9F), attributes(5), atomic_ops(3C)
atomic_cas.9f <beginning of page>
atomic_cas, atomic_cas_8, atomic_cas_uchar, atomic_cas_16, atomic_cas_ushort, atomic_cas_32, atomic_cas_uint,
atomic_cas_ulong, atomic_cas_64, atomic_cas_ptr <-> atomic compare and swap operations
#include <sys/atomic.h>
uint8_t atomic_cas_8(volatile uint8_t *target, uint8_t cmp, uint8_t
 newval);
uchar_t atomic_cas_uchar(volatile uchar_t *target, uchar_t cmp, uchar_t
 newval);
uint16_t atomic_cas_16(volatile uint16_t *target, uint16_t cmp, uint16_t
 newval);
ushort_t atomic_cas_ushort(volatile ushort_t *target, ushort_t cmp,
 ushort_t newval);
uint32_t atomic_cas_32(volatile uint32_t *target, uint32_t cmp, uint32_t
 newval);
uint_t atomic_cas_uint(volatile uint_t *target, uint_t cmp, uint_t newval);
ulong_t atomic_cas_ulong(volatile ulong_t *target, ulong_t cmp, ulong_t
 newval);
uint64_t atomic_cas_64(volatile uint64_t *target, uint64_t cmp, uint64_t
 newval);
void *atomic_cas_ptr(volatile void *target, void *cmp, void *newval);
These functions enable a compare and swap operation to occur atomically. The value stored in target is compared
with cmp. If these values are equal, the value stored in target is replaced with newval. The old value stored in target
is returned by the function whether or not the replacement occurred.
These functions return the old of *target.
No errors are defined.
These functions can be called from user, interrupt, or kernel context.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed
atomic_add(9F), atomic_and(9F), atomic_bits(9F), atomic_dec(9F), atomic_inc(9F), atomic_or(9F), atom<hy>
ic_swap(9F), membar_ops(9F), attributes(5), atomic_ops(3C)
atomic_dec.9f <beginning of page>
atomic_dec, atomic_dec_8, atomic_dec_uchar, atomic_dec_16, atomic_dec_ushort, atomic_dec_32, atom<hy>
ic_dec_uint, atomic_dec_ulong, atomic_dec_64, atomic_dec_ptr, atomic_dec_8_nv, atomic_dec_uchar_nv, atom<hy>
ic_dec_16_nv, atomic_dec_ushort_nv, atomic_dec_32_nv, atomic_dec_uint_nv, atomic_dec_ulong_nv, atom<hy>
ic_dec_64_nv, atomic_dec_ptr_nv <-> atomic decrement operations
#include <sys/atomic.h>
void atomic_dec_8(volatile uint8_t *target);
void atomic_dec_uchar(volatile uchar_t *target);
void atomic_dec_16(volatile uint16_t *target);
void atomic_dec_ushort(volatile ushort_t *target);
void atomic_dec_32(volatile uint32_t *target);
void atomic_dec_uint(volatile uint_t *target);
void atomic_dec_ulong(volatile ulong_t *target);
void atomic_dec_64(volatile uint64_t *target);
void atomic_dec_ptr(volatile void *target);
uint8_t atomic_dec_8_nv(volatile uint8_t *target);
uchar_t atomic_dec_uchar_nv(volatile uchar_t *target);
uint16_t atomic_dec_16_nv(volatile uint16_t *target);
ushort_t atomic_dec_ushort_nv(volatile ushort_t *target);
uint32_t atomic_dec_32_nv(volatile uint32_t *target);
uint_t atomic_dec_uint_nv(volatile uint_t *target);
ulong_t atomic_dec_ulong_nv(volatile ulong_t *target);
uint64_t atomic_dec_64_nv(volatile uint64_t *target);
void *atomic_dec_ptr_nv(volatile void *target);
These functions enable the decrementing (by one) of the value stored in target to occur in an atomic manner.
The *_nv() variants of these functions return the new value of target.
No errors are defined.
These functions can be called from user, interrupt, or kernel context.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed
atomic_add(9F), atomic_and(9F), atomic_bits(9F), atomic_cas(9F), atomic_inc(9F), atomic_or(9F), atom<hy>
ic_swap(9F), membar_ops(9F), attributes(5), atomic_ops(3C)
The *_nv() variants are substantially more expensive on some platforms than the versions that do not return values.
Do not use them unless you need to know the new value atomically (for example, when decrementing a reference
count and checking whether it went to zero).
atomic_inc.9f <beginning of page>
atomic_inc, atomic_inc_8, atomic_inc_uchar, atomic_inc_16, atomic_inc_ushort, atomic_inc_32, atomic_inc_uint,
atomic_inc_ulong, atomic_inc_64, atomic_inc_ptr, atomic_inc_8_nv, atomic_inc_uchar_nv, atomic_inc_16_nv,
atomic_inc_ushort_nv, atomic_inc_32_nv, atomic_inc_uint_nv, atomic_inc_ulong_nv, atomic_inc_64_nv, atom<hy>
ic_inc_ptr_nv <-> atomic inrement operations
#include <sys/atomic.h>
void atomic_inc_8(volatile uint8_t *target);
void atomic_inc_uchar(volatile uchar_t *target);
void atomic_inc_16(volatile uint16_t *target);
void atomic_inc_ushort(volatile ushort_t *target);
void atomic_inc_32(volatile uint32_t *target);
void atomic_inc_uint(volatile uint_t *target);
void atomic_inc_ulong(volatile ulong_t *target);
void atomic_inc_64(volatile uint64_t *target);
void atomic_inc_ptr(volatile void *target);
uint8_t atomic_inc_8_nv(volatile uint8_t *target);
uchar_t atomic_inc_uchar_nv(volatile uchar_t *target);
uint16_t atomic_inc_16_nv(volatile uint16_t *target);
ushort_t atomic_inc_ushort_nv(volatile ushort_t *target);
uint32_t atomic_inc_32_nv(volatile uint32_t *target);
uint_t atomic_inc_uint_nv(volatile uint_t *target);
ulong_t atomic_inc_ulong_nv(volatile ulong_t *target);
uint64_t atomic_inc_64_nv(volatile uint64_t *target);
void *atomic_inc_ptr_nv(volatile void *target);
These functions enable the inrementing (by one) of the value stored in target to occur in an atomic manner.
The *_nv() variants of these functions return the new value of target.
No errors are defined.
These functions can be called from user, interrupt, or kernel context.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed
atomic_add(9F), atomic_and(9F), atomic_bits(9F), atomic_cas(9F), atomic_dec(9F), atomic_or(9F), atom<hy>
ic_swap(9F), membar_ops(9F), attributes(5), atomic_ops(3C)
The *_nv() variants are substantially more expensive on some platforms than the versions that do not return values.
Do not use them unless you need to know the new value atomically.
atomic_ops.9f <beginning of page>
atomic_ops <-> atomic operations
#include <sys/atomic.h>
This collection of functions provides atomic memory operations. There are 8 different classes of atomic operations:
atomic_add(9F) These functions provide an atomic addition of a signed value to a variable.
atomic_and(9F) These functions provide an atomic logical 'and' of a value to a variable.
atomic_bits(9F) These functions provide atomic bit setting and clearing within a variable.
atomic_cas(9F) These functions provide an atomic comparison of a value with a variable. If the comparison is
equal, then swap in a new value for the variable, returning the old value of the variable in either case.
atomic_dec(9F) These functions provide an atomic decrement on a variable.
atomic_inc(9F) These functions provide an atomic increment on a variable.
atomic_or(9F) These functions provide an atomic logical 'or' of a value to a variable.
atomic_swap(9F) These functions provide an atomic swap of a value with a variable, returning the old value of the
variable.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed
atomic_add(9F), atomic_and(9F), atomic_bits(9F), atomic_cas(9F), atomic_dec(9F), atomic_inc(9F), atom<hy>
ic_or(9F), atomic_swap(9F), membar_ops(9F), attributes(5)
Atomic instructions ensure global visibility of atomically-modified variables on completion. In a relaxed store order
system, this does not guarantee that the visibility of other variables will be synchronized with the completion of the
atomic instruction. If such synchronization is required, memory barrier instructions must be used. See mem<hy>
bar_ops(9F).
Atomic instructions can be expensive. since they require synchronization to occur at a hardware level. This means
they should be used with care to ensure that forcing hardware level synchronization occurs a minimum number of
times. For example, if you have several variables that need to be incremented as a group, and each needs to be done
atomically, then do so with a mutex lock protecting all of them being incremented rather than using the atom<hy>
ic_inc(9F) operation on each of them.
atomic_or.9f <beginning of page>
atomic_or, atomic_or_8, atomic_or_uchar, atomic_or_16, atomic_or_ushort, atomic_or_32, atomic_or_uint, atom<hy>
ic_or_ulong, atomic_or_64, atomic_or_8_nv, atomic_or_uchar_nv, atomic_or_16_nv, atomic_or_ushort_nv, atom<hy>
ic_or_32_nv, atomic_or_uint_nv, atomic_or_ulong_nv, atomic_or_64_nv <-> atomic OR operations
#include <sys/atomic.h>
void atomic_or_8(volatile uint8_t *target, uint8_t bits);
void atomic_or_uchar(volatile uchar_t *target, uchar_t bits);
void atomic_or_16(volatile uint16_t *target, uint16_t bits);
void atomic_or_ushort(volatile ushort_t *target, ushort_t bits);
void atomic_or_32(volatile uint32_t *target, uint32_t bits);
void atomic_or_uint(volatile uint_t *target, uint_t bits);
void atomic_or_ulong(volatile ulong_t *target, ulong_t bits);
void atomic_or_64(volatile uint64_t *target, uint64_t bits);
uint8_t atomic_or_8_nv(volatile uint8_t *target, uint8_t bits);
uchar_t atomic_or_uchar_nv(volatile uchar_t *target, uchar_t bits);
uint16_t atomic_or_16_nv(volatile uint16_t *target, uint16_t bits);
ushort_t atomic_or_ushort_nv(volatile ushort_t *target, ushort_t bits);
uint32_t atomic_or_32_nv(volatile uint32_t *target, uint32_t bits);
uint_t atomic_or_uint_nv(volatile uint_t *target, uint_t bits);
ulong_t atomic_or_ulong_nv(volatile ulong_t *target, ulong_t bits);
uint64_t atomic_or_64_nv(volatile uint64_t *target, uint64_t bits);
These functions enable the bitwise OR of bits to the value stored in target to occur in an atomic manner.
The *_nv() variants of these functions return the new value of target.
No errors are defined.
These functions can be called from user, interrupt, or kernel context.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed
atomic_add(9F), atomic_and(9F), atomic_bits(9F), atomic_cas(9F), atomic_dec(9F), atomic_inc(9F), atom<hy>
ic_swap(9F), membar_ops(9F), attributes(5), atomic_ops(3C)
The *_nv() variants are substantially more expensive on some platforms than the versions that do not return values.
Do not use them unless you need to know the new value atomically.
atomic_swap.9f <beginning of page>
atomic_swap, atomic_swap_8, atomic_swap_uchar, atomic_swap_16, atomic_swap_ushort, atomic_swap_32, atom<hy>
ic_swap_uint, atomic_swap_ulong, atomic_swap_64, atomic_swap_ptr <-> atomic swap operations
#include <sys/atomic.h>
uint8_t atomic_swap_8(volatile uint8_t *target, uint8_t newval);
uchar_t atomic_swap_uchar(volatile uchar_t *target, uchar_t newval);
uint16_t atomic_swap_16(volatile uint16_t *target, uint16_t newval);
ushort_t atomic_swap_ushort(volatile ushort_t *target, ushort_t newval);
uint32_t atomic_swap_32(volatile uint32_t *target, uint32_t newval);
uint_t atomic_swap_uint(volatile uint_t *target, uint_t newval);
ulong_t atomic_swap_ulong(volatile ulong_t *target, ulong_t newval);
uint64_t atomic_swap_64(volatile uint64_t *target, uint64_t newval);
void *atomic_swap_ptr(volatile void *target, void *newval);
These functions enable a swap operation to occur atomically. The value stored in target is replaced with newval. The
old value is returned by the function.
These functions return the old of *target.
No errors are defined.
These functions can be called from user, interrupt, or kernel context.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed
atomic_add(9F), atomic_and(9F), atomic_bits(9F), atomic_dec(9F), atomic_inc(9F), atomic_or(9F), atom<hy>
ic_cas(9F), membar_ops(9F), attributes(5), atomic_ops(3C)
atrm.1 <beginning of page>
atrm <-> remove jobs spooled by at or batch
atrm [-afi] [ [job #] [user]...]
The atrm utility removes delayed-execution jobs that were created with the at(1) command, but have not yet execut<hy>
ed. The list of these jobs and associated job numbers can be displayed by using atq(1).
atrm removes each job-number you specify, and/or all jobs belonging to the user you specify, provided that you own
the indicated jobs.
You can only remove jobs belonging to other users if you have solaris.jobs.admin privileges.
The following options are supported:
-a All. Removes all unexecuted jobs that were created by the current user. If invoked by the privileged user, the en<hy>
tire queue is flushed.
-f Force. All information regarding the removal of the specified jobs is suppressed.
-i Interactive. atrm asks if a job should be removed. If the response is affirmative, the job is removed.
/var/spool/cron/atjobs Spool area for at jobs
See environ(5) for descriptions of the following environment variables that affect the execution of atrm: LANG,
LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, and NLSPATH.
Affirmative responses are processed using the extended regular expression defined for the yesexpr keyword in the
LC_MESSAGES category of the user's locale. The locale specified in the LC_COLLATE category defines the be<hy>
havior of ranges, equivalence classes, and multi-character collating elements used in the expression defined for ye<hy>
sexpr. The locale specified in LC_CTYPE determines the locale for interpretation of sequences of bytes of text data
a characters, the behavior of character classes used in the expression defined for the yesexpr. See locale(5)
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
at(1), atq(1), auths(1), cron(1M), auth_attr(4), attributes(5), environ(5), locale(5)
attr_get.3xcurses <beginning of page>
attr_get, attr_off, attr_on, attr_set, color_set, wattr_get, wattr_off, wattr_on, wattr_set, wcolor_set <-> control window
attributes
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library... ]
#include <curses.h>
int attr_get(attr_t *attrs, short *color, void *opts);
int attr_off(attr_t attrs, void *opts);
int attr_on(attr_t attrs, void *opts);
int attr_set(attr_t attrs, short color, void *opts);
int color_set(short *color, void *opts);
int wattr_get(WINDOW *win, attr_t attrs, short *color, void *opts);
int wattr_off(WINDOW *win, attr_t attrs, void *opts);
int wattr_on(WINDOW *win, attr_t attrs, void *opts);
int wattr_set(WINDOW *win, attr_t attrs, short color, void *opts);
int wcolor_set(WINDOW *win, short color, void *opts);
The attr_get() function retrieves the current rendition of stdscr. The wattr_get() function retrieves the current rendi<hy>
tion of window win. If attrs or color is a null pointer, no information is retrieved.
The attr_off() and attr_on() functions unset and set, respectively, the specified window attributes of stdscr. These
functions only affect the attributes specified; attributes that existed before the call are retained.
The wattr_off() and wattr_on() functions unset or set the specified attributes for window win.
The attr_set() and wattr_set() functions change the rendition of stdscr and win; the old values are not retained.
The color_set() and wcolor_set() functions set the window color of stdscr and win to color.
The attributes and color pairs that can be used are specified in the Attributes, Color Pairs, and Renditions section
of the curses(3XCURSES) man page.
attrs Is a pointer to the foreground window attributes to be set or unset.
color Is a pointer to a color pair number .
opts Is reserved for future use.
win Is a pointer to the window in which attribute changes are to be made.
These functions always return OK.
None.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
<beginning of page>
Standard _ MT-LevelUnsafe
add_wch(3XCURSES), addnwstr(3XCURSES), attroff(3XCURSES), bkgrndset(3XCURSES), curs<hy>
es(3XCURSES), init_color(3XCURSES), libcurses(3XCURSES), start_color(3XCURSES), attributes(5), stan<hy>
dards(5)
attroff.3xcurses <beginning of page>
attroff, attron, attrset, wattroff, wattron, wattrset <-> change foreground window attributes
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library... ]
#include <curses.h>
int attroff(int attrs);
int attron(int attrs);
int attrset(int attrs);
int wattroff(WINDOW *win, int attrs);
int wattron(WINDOW *win, int attrs);
int wattrset(WINDOW *win, int attrs);
The attroff() and attron() functions unset and set, respectively, the specified window attributes of stdscr. These
functions only affect the attributes specified; attributes that existed before the call are retained. The wattroff() and
wattron() functions unset or set the specified attributes for window win.
The attrset() and wattrset() functions change the specified window renditions of stdscr and win to new values; the
old values are not retained.
The attributes that can be used are specified in the Attributes, Color Pairs, and Renditions section of the curs<hy>
es(3XCURSES) man page.
Here is an example that prints some text using the current window rendition, adds underlining, changes the at<hy>
tributes, prints more text, then changes the attributes back.
 printw("This word is");
 attron(A_UNDERLINE);
 printw("underlined.");
 attroff(A_NORMAL);
 printw("This is back to normal text.\n");
 refresh();
attrs are the foreground window attributes to be set or unset.
win Is a pointer to the window in which attribute changes are to be made.
These functions always return OK or 1.
None.
All of these functions may be macros.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
addch(3XCURSES), addnstr(3XCURSES), attr_get(3XCURSES), bkgdset(3XCURSES), curses(3XCURSES),
init_color(3XCURSES), libcurses(3XCURSES), start_color(3XCURSES), attributes(5), standards(5)
atu.7d <beginning of page>
atu <-> Atmel AT76C50x USB IEEE 802.11b Wireless Device Driver
The atu 802.11b wireless driver is a multi-threaded, loadable, clonable, GLDv3-based STREAMS driver supporting
the Atmel AT76C50x chipset-based wireless devices.
The atu driver performs auto-negotiation to determine the data rate and mode. Supported 802.11b data rates are 1, 2,
5.5, and 11 Mbits/sec.
The atu driver supports only BSS networks (also known as ap or infrastructure networks).
open (or open-system) and shared key authentication modes are supported. Encryption types WEP40 and WEP104
are supported.
/dev/atu* Special character device
/kernel/drv/atu 32-bit ELF kernel module (x86)
/kernel/drv/amd64/atu 64-bit ELF kernel module (x86)
See attributes(5) for a description of the following attributes:
tab() box; lw(2.75i) |lw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86 _
AvailabilitySUNWatu _ Interface StabilityCommitted
dladm(1M), wificonfig(1M), attributes(5), dlpi(7P), gld(7D)
802.11 - Wireless LAN Media Access Control and Physical Layer Specification - IEEE, 2001
audio1575.7d <beginning of page>
audio1575 <-> Uli M1575 Super South Bridge audio digital controller interface
The audio1575 device uses the Uli M1575 AC97-compatible audio digital controller and an AC-97 Codec to imple<hy>
ment the audio device interface. This interface allows analog only inputs and outputs.
/kernel/drv/sparcv9/audio1575
64-bit driver module
/kernel/drv/audio1575.conf
Driver configuration file
See attributes(5) for descriptions of the following attributes:
tab() box; cw(1.83i) |cw(3.67i) lw(1.83i) |lw(3.67i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC, x86 _ AvailabilitySUNWaudd _ Stability levelUncommitted
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
Uli M1575 Super South Bridge Data Sheet Data Sheet<em> Uli USA Inc.
AD1981B AC '97 SoundMAX(R) Codec Data Sheet<em> Analog Devices Inc.
In addition to being logged, the following messages might appear on the system console:
play-interrupts too low
record-interrupts too low The interrupt rate specified in audio1575.conf is set too low. It has been reset to the rate
specified in the message. Update audio1575.conf to a higher interrupt rate.
play-interrupts too high
record-interrupts too high The interrupt rate specified in audio1575.conf is set too high. It has been reset to the
rate specified in the message. Update audio1575.conf to a lower interrupt rate.
audio.7i <beginning of page>
audio <-> generic audio device interface
#include <sys/audio.h>
An audio device is used to play and/or record a stream of audio data. Since a specific audio device may not support
all functionality described below, refer to the device-specific manual pages for a complete description of each hard<hy>
ware device. An application can use the AUDIO_GETDEV ioctl(2) to determine the current audio hardware associ<hy>
ated with /dev/audio.
The audio framework provides a software mixing engine (audio mixer) for all audio devices, allowing more than one
process to play or record audio at the same time.
It is no longer possible to disable the mixing function. Applications must not assume that they have exclusive access
to the audio device.
The audio mixer supports multi-stream Codecs. These devices have DSP engines that provide sample rate conver<hy>
sion, hardware mixing, and other features. The use of such hardware features is opaque to applications.
Digital audio data represents a quantized approximation of an analog audio signal waveform. In the simplest case,
these quantized numbers represent the amplitude of the input waveform at particular sampling intervals. To achieve
the best approximation of an input signal, the highest possible sampling frequency and precision should be used.
However, increased accuracy comes at a cost of increased data storage requirements. For instance, one minute of
monaural audio recorded in <*m>-Law format (pronounced mew-law) at 8 KHz requires nearly 0.5 megabytes of stor<hy>
age, while the standard Compact Disc audio format (stereo 16-bit linear PCM data sampled at 44.1 KHz) requires
approximately 10 megabytes per minute.
Audio data may be represented in several different formats. An audio device's current audio data format can be de<hy>
termined by using the AUDIO_GETINFO ioctl(2) described below.
An audio data format is characterized in the audio driver by four parameters: Sample Rate, Encoding, Precision, and
Channels. Refer to the device-specific manual pages for a list of the audio formats that each device supports. In addi<hy>
tion to the formats that the audio device supports directly, other formats provide higher data compression. Applica<hy>
tions may convert audio data to and from these formats when playing or recording.
Sample rate is a number that represents the sampling frequency (in samples per second) of the audio data.
The audio mixer always configures the hardware for the highest possible sample rate for both play and record. This
ensures that none of the audio streams require compute-intensive low pass filtering. The result is that high sample
rate audio streams are not degraded by filter ing.
Sample rate conversion can be a compute-intensive operation, depending on the number of channels and a device's
sample rate. For example, an 8KHz signal can be easily converted to 48KHz, requiring a low cost up sampling by 6.
However, converting from 44.1KHz to 48KHz is compute intensive because it must be up sampled by 160 and then
down sampled by 147. This is only done using integer multipliers.
Applications can greatly reduce the impact of sample rate conversion by carefully picking the sample rate. Applica<hy>
tions should always use the highest sample rate the device supports. An application can also do its own sample rate
conversion (to take advantage of floating point and accelerated instruction or use small integers for up and down
sampling.
All modern audio devices run at 48 kHz or a multiple thereof, hence just using 48 kHz may be a reasonable compro<hy>
mise if the application is not prepared to select higher sample rates.
An encoding parameter specifies the audio data representation. <*m>-Law encoding corresponds to CCITT G.711, and is
the standard for voice data used by telephone companies in the United States, Canada, and Japan. A-Law encoding
is also part of CCITT G.711 and is the standard encoding for telephony elsewhere in the world. A-Law and <*m>-Law
audio data are sampled at a rate of 8000 samples per second with 12-bit precision, with the data compressed to 8-bit
samples. The resulting audio data quality is equivalent to that of standard analog telephone service.
Linear Pulse Code Modulation (PCM) is an uncompressed, signed audio format in which sample values are directly
proportional to audio signal voltages. Each sample is a 2's complement number that represents a positive or negative
amplitude.
Precision indicates the number of bits used to store each audio sample. For instance, u-Law and A-Law data are
stored with 8-bit precision. PCM data may be stored at various precisions, though 16-bit is the most common.
<beginning of page>
Multiple channels of audio may be interleaved at sample boundaries. A sample frame consists of a single sample
from each active channel. For example, a sample frame of stereo 16-bit PCM data consists of two 16-bit samples,
corresponding to the left and right channel data.
The audio mixer sets the hardware to the maximum number of channels supported. If a mono signal is played or
recorded, it is mixed on the first two (usually the left and right) channels only. Silence is mixed on the remaining
channels
The audio mixer supports the following audio formats:
 Encoding Precision Channels
 Signed Linear PCM 32-bit Mono or Stereo
 Signed Linear PCM 16-bit Mono or Stereo
 Signed Linear PCM 8-bit Mono or Stereo
 u-Law 8-bit Mono or Stereo
 A-Law 8-bit Mono or Stereo
The audio mixer converts all audio streams to 24-bit Linear PCM before mixing. After mixing, conversion is made
to the best possible Codec format. The conversion process is not compute intensive and audio applications can
choose the encoding format that best meets their needs.
Note that the mixer discards the low order 8 bits of 32-bit Signed Linear PCM in order to perform mixing. (This is
done to allow for possible overflows to fit into 32-bits when mixing multiple streams together.) Hence, the maximum
effective precision is 24-bits.
The device /dev/audio is a device driver that dispatches audio requests to the appropriate underlying audio hard<hy>
ware. The audio driver is implemented as a STREAMS driver. In order to record audio input, applications open(2)
the /dev/audio device and read data from it using the read(2) system call. Similarly, sound data is queued to the au<hy>
dio output port by using the write(2) system call. Device configuration is performed using the ioctl(2) interface.
Because some systems may contain more than one audio device, application writers are encouraged to query the
AUDIODEV environment variable. If this variable is present in the environment, its value should identify the path
name of the default audio device.
The audio device is not treated as an exclusive resource. Each process may open the audio device once.
Each open() completes as long as there are channels available to be allocated. If no channels are available to be allo<hy>
cated: <bu> if either the O_NDELAY or O_NONBLOCK flags are set in the open() oflag argument, then -1 is immedi<hy>
ately returned, with errno set to EBUSY. <bu> if neither the O_NDELAY nor the O_NONBLOCK flag are set, then
open() hangs until the device is available or a signal is delivered to the process, in which case a -1 is returned with
errno set to EINTR.
Upon the initial open() of the audio channel, the audio mixer sets the data format of the audio channel to the default
state of 8-bit, 8Khz, mono u-Law data. If the audio device does not support this configuration, it informs the audio
mixer of the initial configuration. Audio applications should explicitly set the encoding characteristics to match the
audio data requirements, and not depend on the default configuration.
The read() system call copies data from the system's buffers to the application. Ordinarily, read() blocks until the
user buffer is filled. The I_NREAD ioctl (see streamio(7I)) may be used to determine the amount of data that may
be read without blocking. The device may alternatively be set to a non-blocking mode, in which case read() com<hy>
pletes immediately, but may return fewer bytes than requested. Refer to the read(2) manual page for a complete de<hy>
scription of this behavior.
When the audio device is opened with read access, the device driver immediately starts buffering audio input data.
Since this consumes system resources, processes that do not record audio data should open the device write-only
(O_WRONLY).
The transfer of input data to STREAMS buffers may be paused (or resumed) by using the AUDIO_SETINFO ioctl
to set (or clear) the record.pause flag in the audio information structure (see below). All unread input data in the
STREAMS queue may be discarded by using the I_FLUSH STREAMS ioctl. See streamio(7I). When changing
record parameters, the input stream should be paused and flushed before the change, and resumed afterward. Other<hy>
wise, subsequent reads may return samples in the old format followed by samples in the new format. This is particu<hy>
larly important when new parameters result in a changed sample size.
<beginning of page>
Input data can accumulate in STREAMS buffers very quickly. At a minimum, it will accumulate at 8000 bytes per
second for 8-bit, 8 KHz, mono, u-Law data. If the device is configured for 16-bit linear or higher sample rates, it will
accumulate even faster. If the application that consumes the data cannot keep up with this data rate, the STREAMS
queue may become full. When this occurs, the record.error flag is set in the audio information structure and input
sampling ceases until there is room in the input queue for additional data. In such cases, the input data stream con<hy>
tains a discontinuity. For this reason, audio recording applications should open the audio device when they are pre<hy>
pared to begin reading data, rather than at the start of extensive initialization.
The write() system call copies data from an application's buffer to the STREAMS output queue. Ordinarily, write()
blocks until the entire user buffer is transferred. The device may alternatively be set to a non-blocking mode, in
which case write() completes immediately, but may have transferred fewer bytes than requested. See write(2).
Although write() returns when the data is successfully queued, the actual completion of audio output may take con<hy>
siderably longer. The AUDIO_DRAIN ioctl may be issued to allow an application to block until all of the queued
output data has been played. Alternatively, a process may request asynchronous notification of output completion by
writing a zero-length buffer (end-of-file record) to the output stream. When such a buffer has been processed, the
play.eof flag in the audio information structure is incremented.
The final close(2) of the file descriptor hangs until all of the audio output has drained. If a signal interrupts the
close(), or if the process exits without closing the device, any remaining data queued for audio output is flushed and
the device is closed immediately.
The consumption of output data may be paused (or resumed) by using the AUDIO_SETINFO ioctl to set (or clear)
the play.pause flag in the audio information structure. Queued output data may be discarded by using the I_FLUSH
STREAMS ioctl. (See streamio(7I)).
Output data is played from the STREAMS buffers at a default rate of at least 8000 bytes per second for <*m>-Law, A-
Law or 8-bit PCM data (faster for 16-bit linear data or higher sampling rates). If the output queue becomes empty,
the play.error flag is set in the audio information structure and output is stopped until additional data is written. If an
application attempts to write a number of bytes that is not a multiple of the current sample frame size, an error is
generated and the bad data is thrown away. Additional writes are allowed.
The I_SETSIG STREAMS ioctl enables asynchronous notification, through the SIGPOLL signal, of input and
output ready condition changes. The O_NONBLOCK flag may be set using the F_SETFL fcntl(2) to enable non-
blocking read() and write() requests. This is normally sufficient for applications to maintain an audio stream in the
background.
It is sometimes convenient to have an application, such as a volume control panel, modify certain characteristics of
the audio device while it is being used by an unrelated process.
The /dev/audioctl pseudo-device is provided for this purpose. Any number of processes may open /dev/audioctl si<hy>
multaneously. However, read() and write() system calls are ignored by /dev/audioctl. The AUDIO_GETINFO and
AUDIO_SETINFO ioctl commands may be issued to /dev/audioctl to determine the status or alter the behavior of
/dev/audio. Note: In general, the audio control device name is constructed by appending the letters "ctl" to the path
name of the audio device.
Applications that open the audio control pseudo-device may request asynchronous notification of changes in the
state of the audio device by setting the S_MSG flag in an I_SETSIG STREAMS ioctl. Such processes receive a
SIGPOLL signal when any of the following events occur: <bu> An AUDIO_SETINFO ioctl has altered the device
state. <bu> An input overflow or output underflow has occurred. <bu> An end-of-file record (zero-length buffer) has been
processed on output. <bu> An open() or close() of /dev/audio has altered the device state. <bu> An external event (such as
speakerbox's volume control) has altered the device state.
The state of the audio device may be polled or modified using the AUDIO_GETINFO and AUDIO_SETINFO
ioctl commands. These commands operate on the audio_info structure as defined, in <sys/audio.h>, as follows:
 /*
 * This structure contains state information for audio device
 * IO streams
 */
 struct audio_prinfo {
  /*
  * The following values describe the
  * audio data encoding
  */
<beginning of page>
  uint_t sample_rate; /* samples per second */
  uint_t channels; /* number of interleaved channels */
  uint_t precision; /* number of bits per sample */
  uint_t encoding; /* data encoding method */
  /*
  * The following values control audio device
  * configuration
  */
  uint_t gain; /* volume level */
  uint_t port; /* selected I/O port */
  uint_t buffer_size; /* I/O buffer size */
  /*
  * The following values describe the current device
  * state
  */
  uint_t samples; /* number of samples converted */
  uint_t eof; /* End Of File counter (play only) */
  uchar_t pause; /* non-zero if paused, zero to resume */
  uchar_t error; /* non-zero if overflow/underflow */
  uchar_t waiting; /* non-zero if a process wants access */
  uchar_t balance; /* stereo channel balance */
  /*
  * The following values are read-only device state
  * information
  */
  uchar_t open;/* non-zero if open access granted */
  uchar_t active; /* non-zero if I/O active */
  uint_t avail_ports; /* available I/O ports */
  uint_t mod_ports; /* modifiable I/O ports */
 };
 typedef struct audio_prinfo audio_prinfo_t;
  /*
  * This structure is used in AUDIO_GETINFO and AUDIO_SETINFO ioctl
  * commands
  */
 struct audio_info {
  audio_prinfo_t record;/* input status info */
  audio_prinfo_t play;/* output status info */
  uint_t monitor_gain; /* input to output mix */
  uchar_toutput_muted; /* non-zero if output muted */
  uint_t hw_features; /* supported H/W features */
  uint_t sw_features;/* supported S/W features */
  uint_t sw_features_enabled;
  /* supported S/W features enabled */
 };
 typedef struct audio_info audio_info_t;
 /* Audio encoding types */
 #define AUDIO_ENCODING_ULAW (1) /* u-Law encoding */
 #define AUDIO_ENCODING_ALAW (2) /* A-Law encoding */
 #define AUDIO_ENCODING_LINEAR (3) /* Signed Linear PCM encoding */
 /*
 * These ranges apply to record, play, and
 * monitor gain values
  */
 #define AUDIO_MIN_GAIN (0)/* minimum gain value */
 #define AUDIO_MAX_GAIN (255) /* maximum gain value */
 /*
 * These values apply to the balance field to adjust channel
 * gain values
  */
<beginning of page>
 #define AUDIO_LEFT_BALANCE(0) /* left channel only */
 #define AUDIO_MID_BALANCE (32) /* equal left/right balance */
 #define AUDIO_RIGHT_BALANCE (64) /* right channel only */
 /*
 * Define some convenient audio port names
 * (for port, avail_ports and mod_ports)
  */
 /* output ports (several might be enabled at once) */
 #define AUDIO_SPEAKER (0x01)/* built-in speaker */
 #define AUDIO_HEADPHONE (0x02)/* headphone jack */
 #define AUDIO_LINE_OUT (0x04)/* line out */
 #define AUDIO_SPDIF_OUT (0x08)/* SPDIF port */
 #define AUDIO_AUX1_OUT (0x10)/* aux1 out */
 #define AUDIO_AUX2_OUT (0x20)/* aux2 out */
 /* input ports (usually only one may be
 * enabled at a time)
  */
 #define AUDIO_MICROPHONE (0x01) /* microphone */
 #define AUDIO_LINE_IN (0x02) /* line in */
 #define AUDIO_CD(0x04) /* on-board CD inputs */
 #define AUDIO_SPDIF_IN (0x08) /* SPDIF port */
 #define AUDIO_AUX1_IN (0x10) /* aux1 in */
 #define AUDIO_AUX2_IN (0x20) /* aux2 in */
 #define AUDIO_CODEC_LOOPB_IN (0x40) /* Codec inter.loopback */
 /* These defines are for hardware features */
 #define AUDIO_HWFEATURE_DUPLEX (0x00000001u)
 /*simult. play & cap. supported */
 #define AUDIO_HWFEATURE_MSCODEC (0x00000002u)
 /* multi-stream Codec */
 /* These defines are for software features *
 #define AUDIO_SWFEATURE_MIXER (0x00000001u)
  /* audio mixer audio pers. mod. */
 /*
 * Parameter for the AUDIO_GETDEV ioctl
 * to determine current audio devices
 */#define MAX_AUDIO_DEV_LEN(16)
 struct audio_device {
  char name[MAX_AUDIO_DEV_LEN];
  char version[MAX_AUDIO_DEV_LEN];
  char config[MAX_AUDIO_DEV_LEN];
 };
 typedef struct audio_device audio_device_t;
The play.gain and record.gain fields specify the output and input volume levels. A value of AUDIO_MAX_GAIN
indicates maximum volume. Audio output may also be temporarily muted by setting a non-zero value in the out<hy>
put_muted field. Clearing this field restores audio output to the normal state.
The monitor_gain field is present for compatibility, and is no longer supported. See dsp(7I) for more detail.
Likewise, the play.port, play.ports, play.mod_ports, record.port, record.ports, and record.mod_ports are no longer
supported. See dsp(7I) for more detail.
The play.balance and record.balance fields are fixed to AUDIO_MID_BALANCE. Changes to volume levels for
different channels can be made using the interfaces in dsp(7I).
The play.pause and record.pause flags may be used to pause and resume the transfer of data between the audio de<hy>
vice and the STREAMS buffers. The play.error and record.error flags indicate that data underflow or overflow has
occurred. The play.active and record.active flags indicate that data transfer is currently active in the corresponding
<beginning of page>
direction.
The play.open and record.open flags indicate that the device is currently open with the corresponding access permis<hy>
sion. The play.waiting and record.waiting flags provide an indication that a process may be waiting to access the de<hy>
vice. These flags are set automatically when a process blocks on open(), though they may also be set using the AU<hy>
DIO_SETINFO ioctl command. They are cleared only when a process relinquishes access by closing the device.
The play.samples and record.samples fields are zeroed at open() and are incremented each time a data sample is
copied to or from the associated STREAMS queue. Some audio drivers may be limited to counting buffers of sam<hy>
ples, instead of single samples for their samples accounting. For this reason, applications should not assume that the
samples fields contain a perfectly accurate count. The play.eof field increments whenever a zero-length output buffer
is synchronously processed. Applications may use this field to detect the completion of particular segments of audio
output.
The record.buffer_size field controls the amount of input data that is buffered in the device driver during record oper<hy>
ations. Applications that have particular requirements for low latency should set the value appropriately. Note how<hy>
ever that smaller input buffer sizes may result in higher system overhead. The value of this field is specified in bytes
and drivers will constrain it to be a multiple of the current sample frame size. Some drivers may place other require<hy>
ments on the value of this field. Refer to the audio device-specific manual page for more details. If an application
changes the format of the audio device and does not modify the record.buffer_size field, the device driver may use a
default value to compensate for the new data rate. Therefore, if an application is going to modify this field, it should
modify it during or after the format change itself, not before. When changing the record.buffer_size parameters, the
input stream should be paused and flushed before the change, and resumed afterward. Otherwise, subsequent reads
may return samples in the old format followed by samples in the new format. This is particularly important when
new parameters result in a changed sample size. If you change the record.buffer_size for the first packet, this proto<hy>
col must be followed or the first buffer will be the default buffer size for the device, followed by packets of the re<hy>
quested change size.
The record.buffer_size field may be modified only on the /dev/audio device by processes that have it opened for
reading.
The play.buffer_size field is currently not supported.
The audio data format is indicated by the sample_rate, channels, precision and encoding fields. The values of these
fields correspond to the descriptions in the AUDIO FORMATS section of this man page. Refer to the audio device-
specific manual pages for a list of supported data format combinations.
The data format fields can be modified only on the /dev/audio device.
If the parameter changes requested by an AUDIO_SETINFO ioctl cannot all be accommodated, ioctl() returns with
errno set to EINVAL and no changes are made to the device state.
All of the streamio(7I) ioctl commands may be issued for the /dev/audio device. Because the /dev/audioctl device
has its own STREAMS queues, most of these commands neither modify nor report the state of /dev/audio if issued
for the /dev/audioctl device. The I_SETSIG ioctl may be issued for /dev/audioctl to enable the notification of au<hy>
dio status changes, as described above.
The audio device additionally supports the following ioctl commands:
AUDIO_DRAIN The argument is ignored. This command suspends the calling process until the output STREAMS
queue is empty and all queued samples have been played, or until a signal is delivered to the calling process. It may
not be issued for the /dev/audioctldevice. An implicit AUDIO_DRAIN is performed on the final close() of
/dev/audio.
AUDIO_GETDEV The argument is a pointer to an audio_device_t structure. This command may be issued for ei<hy>
ther /dev/audio or /dev/audioctl. The returned value in the name field will be a string that will identify the current
/dev/audio hardware device, the value in version will be a string indicating the current version of the hardware, and
config will be a device-specific string identifying the properties of the audio stream associated with that file descrip<hy>
tor. Refer to the audio device-specific manual pages to determine the actual strings returned by the device driver.
AUDIO_GETINFO The argument is a pointer to an audio_info_t structure. This command may be issued for ei<hy>
ther /dev/audio or /dev/audioctl. The current state of the /dev/audio device is returned in the structure.
Values return pertain to a logical view of the device as seen by and private to the process, and do not necessarily re<hy>
<beginning of page>
flect the actual hardware device itself.
AUDIO_SETINFO The argument is a pointer to an audio_info_t structure. This command may be issued for either
the /dev/audio or the /dev/audioctl device with some restrictions. This command configures the audio device ac<hy>
cording to the supplied structure and overwrites the existing structure with the new state of the device. Note: The
play.samples, record.samples, play.error, record.error, and play.eof fields are modified to reflect the state of the de<hy>
vice when the AUDIO_SETINFO is issued. This allows programs to automatically modify these fields while re<hy>
trieving the previous value.
As with AUDIO_SETINFO, the settings managed by this ioctl deal with a logical view of the device which is pri<hy>
vate to the process, and don't necessarily have any impact on the hardware device itself.
Certain fields in the audio information structure, such as the pause flags, are treated as read-only when /dev/audio is
not open with the corresponding access permission. Other fields, such as the gain levels and encoding information,
may have a restricted set of acceptable values. Applications that attempt to modify such fields should check the re<hy>
turned values to be sure that the corresponding change took effect. The sample_rate, channels, precision, and encod<hy>
ing fields treated as read-only for /dev/audioctl, so that applications can be guaranteed that the existing audio for<hy>
mat will stay in place until they relinquish the audio device. AUDIO_SETINFO will return EINVAL when the de<hy>
sired configuration is not possible, or EBUSY when another process has control of the audio device.
All of the logical device state is reset when the corresponding I/O stream of /dev/audio is closed.
The audio_info_t structure may be initialized through the use of the AUDIO_INITINFO macro. This macro sets all
fields in the structure to values that are ignored by the AUDIO_SETINFO command. For instance, the following
code switches the output port from the built-in speaker to the headphone jack without modifying any other audio pa<hy>
rameters:
 audio_info_t info;
 AUDIO_INITINFO();
 info.play.port = AUDIO_HEADPHONE;
 err = ioctl(audio_fd, AUDIO_SETINFO, );
This technique eliminates problems associated with using a sequence of AUDIO_GETINFO followed by AU<hy>
DIO_SETINFO.
An open() will fail if:
EBUSY The requested play or record access is busy and either the O_NDELAY or O_NONBLOCK flag was set in
the open() request.
EINTR The requested play or record access is busy and a signal interrupted the open() request.
An ioctl() will fail if:
EINVAL The parameter changes requested in the AUDIO_SETINFO() ioctl are invalid or are not supported by the
device.
The physical audio device names are system dependent and are rarely used by programmers. Programmers should
use the following generic device names:
/dev/audio Symbolic link to the system's primary audio device
/dev/audioctl Symbolic link to the control device for /dev/audio
/dev/sound/0 First audio device in the system
<beginning of page>
/dev/sound/0ctl Audio control device for /dev/sound/0
/usr/share/audio/samples Audio files
See attributes(5) for a description of the following attributes:
tab() box; cw(1.82i) |cw(3.68i) lw(1.82i) |lw(3.68i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC, x86 _ AvailabilitySUNWcsu, SUNWaudd, SUNWaudh _ Stability LevelObsolete Uncommitted
close(2), fcntl(2), ioctl(2), open(2), poll(2), read(2), write(2), attributes(5), dsp(7I), streamio(7I)
Due to a feature of the STREAMS implementation, programs that are terminated or exit without closing the audio
device may hang for a short period while audio output drains. In general, programs that produce audio output should
catch the SIGINT signal and flush the output stream before exiting.
audiocmi.7d <beginning of page>
audiocmi <-> C-Media 8738, 8768, and 8338 driver support
The audiocmi driver provides support for the C-Media 8738, 8768, and 8338 audio controllers. These are found on
some motherboards and some add-in PCI cards.
/kernel/drv/audiocmi
32-bit kernel driver module
/kernel/drv/amd64/audiocmi
64-bit x86 kernel driver module
/kernel/drv/sparcv9/audiocmi
64-bit SPARC kernel driver module
/kernel/drv/audiocmi.conf
Driver configuration file
See attributes(5) for a descriptions of the following attributes:
tab() box; cw(1.83i) |cw(3.67i) lw(1.83i) |lw(3.67i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitecturePC-
based system _ AvailabilitySUNWaudiocmi
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
audiocs.7d <beginning of page>
audiocs <-> Crystal Semiconductor 4231 Audio driver
The audiocs driver supports the Crystal Semiconductor 4231 Codec to implement the audio device interface.
The audiocs device provides support for the internal speaker, headphone, line out, line in, microphone, and, on some
platforms, internal CD-ROM audio in.
audiocs errors are described in the audio(7I) manual page.
/kernel/drv/sparcv9/audiocs
64-bit audiocs driver
/kernel/drv/audiocs.conf
audiocs driver configuration file
See attributes(5) for descriptions of the following attributes:
tab() box; cw(1.83i) |cw(3.67i) lw(1.83i) |lw(3.67i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC _ AvailabilitySUNWaudd _ Stability levelUncommitted
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
Crystal Semiconductor, Inc. CS4231 Data Sheet
In addition to being logged, the following messages can appear on the system console:
play-interrupts too low
record-interrupts too low The interrupt rate specified in audiocs.conf is set too low. It is being reset to the rate
specified in the message. Update audiocs.conf to a higher interrupt rate.
play-interrupts too high
record-interrupts too high The interrupt rate specified in audiocs.conf is set too high. It is being reset to the rate
specified in the message. Update audiocs.conf to a lower interrupt rate.
audiohd.7d <beginning of page>
audiohd <-> Intel High Definition Audio Controller support
The audiohd driver provides support for the generic codec chips which are compatible with the Intel High-Defini<hy>
tion Audio Controller 1.0 specification.
/kernel/drv/audiohd.conf audiohd driver configuration file
/kernel/drv/audiohd 32-bit x86 kernel driver module
/kernel/drv/amd64/audiohd 64-bit x86 kernel driver module
See attributes(5) for a descriptions of the following attributes:
tab() box; cw(1.83i) |cw(3.67i) lw(1.83i) |lw(3.67i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitecturePC-
based system _ AvailabilitySUNWaudiohd _ Stability levelUncommitted
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
Intel High-Definition Audio Specification 1.0. - Intel Corporation
ALC880 Specification <em> Realtek Inc.
In addition to being logged, the following messages can appear on the system console:
play-interrupts too low
record-interrupts too low The interrupt rate in audiohd.conf is set too low. It has been reset to the rate specified in
the message. Update audiohd.conf to a higher interrupt rate.
redcord-interrupts too low
record-interrupts too high The interrupt rate in audiohd.conf is set too low. It has been reset to the rate specified
in the message. Update audiohd.conf to a higher interrupt rate
audiols.7d <beginning of page>
audiols <-> Creative Audigy LS audio device support
The audiols driver provides support for the Creative Audigy LS audio device.
There are numerous devices marketed under the Audigy brand by Creative, but only Audigy LS devices are support<hy>
ed by this driver.
This device is capable of 5.1 surround sound.
/kernel/drv/audiols 32-bit kernel driver module
/kernel/drv/amd64/audiols 64-bit kernel driver module
See attributes(5) for a descriptions of the following attributes:
tab() box; cw(1.83i) |cw(3.67i) lw(1.83i) |lw(3.67i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86 _
AvailabilitySUNWaudiols
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
audiopci.7d <beginning of page>
audiopci <-> Ensoniq 1370 driver support
The audiopci driver provides support for the Ensoniq 1370 audio controller. Ensoniq 1370 chips are found on add-in
PCI cards commonly identified as Audio PCI and SoundBlaster PCI.
/kernel/drv/audiopci 32-bit kernel driver module
/kernel/drv/amd64/audiopci 64-bit x86 kernel driver module
/kernel/drv/amd64/audiopci 64-bit SPARC kernel driver module
/kernel/drv/audiopci.conf Driver configuration file
See attributes(5) for a description of the following attributes:
tab() box; lw(2.75i) |lw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitecturePCI-
based systems _ AvailabilitySUNWaudd
ioctl(2), attributes(5), audio(7I), mixer(7I), streamio(7I)
Creative Technology Ltd ES1370 Specification
http://www.sun.com
audiorecord.1 <beginning of page>
audiorecord <-> record an audio file
audiorecord [-af] [-v vol] [-c channels] [-s rate]
 [-e encoding] [-t time] [-i info] [-d dev]
 [-T au | aif[f] | wav] [file[.au|.aif[f]]|.wav]
The audiorecord utility copies audio data from the audio device to a named audio file, or to the standard output if
no filename is present. If no output file is specified and standard output is a tty, the program exits with an error mes<hy>
sage.
By default, monaural audio data is recorded at 8 kHz and encoded in -law format. If the audio device supports addi<hy>
tional configurations, the -c, -s, and -e options may be used to specify the data format. The output file is prefixed by
an audio file header that identifies the format of the data encoded in the file.
Recording begins immediately and continues until a SIGINT signal (for example, Control-c) is received. If the -t
option is specified, audiorecord stops when the specified quantity of data has been recorded.
If the audio device is unavailable, that is, if another process currently has read access, audiorecord prints an error
message and exits immediately.
The following options are supported:
-\? Help: Prints a command line usage message.
-a Append: Appends the data on the end of the named audio file. The audio device must support the audio data for<hy>
mat of the existing file.
-c channels Channels: Specifies the number of audio channels (1 or 2). The value may be specified as an integer or
as the string mono or stereo. The default value is mono.
-d dev Device: The dev argument specifies an alternate audio device from which input should be taken. If the -d op<hy>
tion is not specified, the AUDIODEV environment variable is consulted (see below). Otherwise, /dev/audio is used
as the default audio device.
-e encoding Encoding: Specifies the audio data encoding. This value may be one of ulaw, alaw, or linear. The de<hy>
fault encoding is ulaw.
-f Force: When the -a flag is specified, the sample rate of the audio device must match the sample rate at which the
original file was recorded. If the -f flag is also specified, sample rate differences are ignored, with a warning message
printed on the standard error.
-i info Information: The `information' field of the output file header is set to the string specified by the info argu<hy>
ment. This option cannot be specified in conjunction with the -a argument.
-s rate Sample Rate: Specifies the sample rate, in samples per second. If a number is followed by the letter k, it is
multiplied by 1000 (for example, 44.1k = 44100). The default sample rate is 8 kHz.
-t time Time: The time argument specifies the maximum length of time to record. Time can be specified as a floating-
point value, indicating the number of seconds, or in the form: hh:mm:ss.dd, where the hour and minute specifica<hy>
tions are optional.
-T au | aif[f] | wav Specifies the audio file type to create. If the -a option is used, the file type must match the file to
which it is being appended. Regardless of the file suffix, the type is set as specified in this option. If this option is not
specified, the file suffix determines the type.
<beginning of page>
-v vol Volume: The recording gain is set to the specified value before recording begins, and is reset to its previous
level when audiorecord exits. The vol argument is an integer value between 0 and 100, inclusive. If this argument is
not specified, the input volume remains at the level most recently set by any process.
file[.au|.aif[f]]|.wav
File Specification: The named audio file is rewritten, or appended. If no filename is present, and standard output is
not a tty, or if the special filename "<mi>" is specified, output is directed to the the standard output.
If the -T option is not specified, the file suffix determines the type of file. If the suffix is not recognized, the default is
.au. If the -T option is specified, that file type is used regardless of the file suffix.
See largefile(5) for the description of the behavior of audiorecord when encountering files greater than or equal to 2
Gbyte ( 2^31 bytes).
AUDIODEV The full path name of the audio device to record from, if no -d argument is supplied. If the AU<hy>
DIODEV variable is not set, /dev/audio is used.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC, x86 _ AvailabilitySUNWauda _ Interface StabilityCommitted
audioconvert(1), audioplay(1), mixerctl(1), attributes(5), largefile(5), audio(7I)
audiotest.1 <beginning of page>
audiotest <-> test audio device
audiotest [-24571] [dev] ...
The audiotest utility runs a test for the named audio device (or all audio devices found on the system if none is giv<hy>
en). The test includes playing an audio sample over each channel and measuring the rate of playback for clock drift.
The following options are supported:
-1 Loop mode. The test is run in an infinite loop.
-2 Stereo (2-channel) mode. This is the default mode. Playback assumes 2 channels are present.
-4 Quadraphonic mode (4-channel surround). The test assumes that four surround channels are present.
-5 Surround sound mode (5.1). The test checks the left, right, surround left, surround right, and center channels. The
low frequency effects channel is not tested.
-7 Surround sound mode (7.1). The test checks the left, right, surround left, surround right, back surround left, back
surround right, and center channels. The low frequency effects channel is not tested.
dev The path the device to test, for example, /dev/dsp0.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC, x86 _ AvailabilitySUNWauda _ Interface StabilityCommitted
audioconvert(1), audiorecord(1), mixerctl(1), attributes(5), audio(7I)
audiotest has no way to detect the number of actual audio channels supported by the physical device.
audiotest does not test the low-frequency effects (LFE) channel.
There is no test for audio capture, volume controls, or other advanced device features.
audiovia823x.7d <beginning of page>
audiovia823x <-> VIA VT8233, VT8235, and VT8237) support
The audiovia823x driver provides support for the VIA VT8233, VT8235, and VT8237 AC'97 devices found on
motherboards with certain VIA chip sets.
/kernel/drv/audiovia823x
32-bit x86 kernel module
/kernel/drv/amd64/audiovia823x
64-bit x86 kernel module
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.27i) |cw(3.23i) lw(2.27i) |lw(3.23i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86 _
AvailabilitySUNWvia823x _ Interface StabilityCommitted
attributes(5), audio(7I), dsp(7I), mixer(7I)
audit.1m <beginning of page>
audit <-> control the behavior of the audit daemon
audit -n | -s | -t | -v [path]
The audit command is the system administrator's interface to maintaining the audit trail. The audit daemon can be
notified to read the contents of the audit_control(4) file and re-initialize the current audit directory to the first direc<hy>
tory listed in the audit_control file or to open a new audit file in the current audit directory specified in the au<hy>
dit_control file, as last read by the audit daemon. Reading audit_control also causes the minfree and plugin con<hy>
figuration lines to be re-read and reset within auditd. The audit daemon can also be signaled to close the audit trail
and disable auditing.
-n Notify the audit daemon to close the current audit file and open a new audit file in the current audit directory.
-s Notify the audit daemon to read the audit control file. The audit daemon stores the information internally. If the
audit daemon is not running but audit has been enabled by means of bsmconv(1M), the audit daemon is started.
-t Direct the audit daemon to close the current audit trail file, disable auditing, and die. Use -s to restart auditing.
-v path Verify the syntax for the audit control file stored in path. The audit command displays an approval message
or outputs specific error messages for each error found.
The audit command will exit with 0 upon success and a positive integer upon failure. <bu> /etc/security/audit_user <bu>
/etc/security/audit_control
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ StabilityEvolving
bsmconv(1M), praudit(1M), audit(2), audit_control(4), audit_user(4), attributes(5)
See the section on Solaris Auditing in System Administration Guide: Security Services.
The functionality described in this man page is available only if the Solaris Auditing feature has been enabled. See
bsmconv(1M) for more information.
The audit command does not modify a process's preselection mask. It functions are limited to the following: <bu> af<hy>
fects which audit directories are used for audit data storage; <bu> specifies the minimum free space setting; <bu> resets the
parameters supplied by means of the plugin directive.
For the -s option, audit validates the audit_control syntax and displays an error message if a syntax error is found.
If a syntax error message is displayed, the audit daemon does not re-read audit_control. Because audit_control is
processed at boot time, the -v option is provided to allow syntax checking of an edited copy of audit_control. Using
-v, audit exits with 0 if the syntax is correct; otherwise, it returns a positive integer.
The -v option can be used in any zone, but the -t, -s, and -n options are valid only in local zones and, then, only if
the perzone audit policy is set. See auditd(1M) and auditconfig(1M) for per-zone audit configuration.
audit_binfile.5 <beginning of page>
audit_binfile <-> generation of Solaris audit logs
/usr/lib/security/audit_binfile.so
The audit_binfile plugin module for Solaris audit, /usr/lib/security/audit_binfile.so, writes binary audit data to
files as configured in audit_control(4); it is the default plugin for the Solaris audit daemon auditd(1M). Its output is
described by audit.log(4).
The audit_binfile plugin is loaded by auditd if audit_control contains one or more lines defining audit directories
by means of the dir: specification or if audit_control has a plugin: specification of name=audit_binfile.so.
The p_dir and p_minfree attributes are equivalent to the dir: and minfree: lines described in audit_control. If both
the dir: line and the p_dir attribute are used, the plugin combines all directories into a single list with those speci<hy>
fied by means of dir: at the front of the list. If both the minfree and the p_minfree attributes are given, the p_min<hy>
free value is used.
The p_fsize attribute defines the maximum size in bytes that an audit file can become before it is automatically
closed and a new audit file opened. This is equivalent to an administrator issuing an audit -n command when the au<hy>
dit file contains the specified number of bytes. The default size is zero (0), which allows the file to grow without
bound. The value specified must be within the range of [512,000, 2,147,483,647].
The following directives cause audit_binfile.so to be loaded, specify the directories for writing audit logs, and speci<hy>
fy the percentage of required free space per directory.
 flags: lo,ad,-fm
 naflags: lo,ad
 plugin: name=audit_binfile.so;\
 p_minfree=20;\
 p_dir=/var/audit/jedgar/eggplant,\
 /var/audit/jedgar.aux/eggplant,\
 /var/audit/global/eggplant
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT LevelMT-
Safe _ Interface StabilityCommitted
auditd(1M), audit_control(4), syslog.conf(4), attributes(5)
System Administration Guide: Security Services
auditconfig.1m <beginning of page>
auditconfig <-> configure auditing
auditconfig option...
auditconfig provides a command line interface to get and set kernel audit parameters.
This functionality is available only if the Solaris Auditing feature has been enabled. See bsmconv(1M) for more in<hy>
formation.
The setting of the perzone policy determines the scope of the audit setting controlled by auditconfig. If perzone is
set, then the values reflect the local zone except as noted. Otherwise, the settings are for the entire system. Any re<hy>
striction based on the perzone setting is noted for each option to which it applies.
A non-global zone administrator can set all audit policy options except perzone and ahlt. perzone and ahlt apply
only to the global zone; setting these policies requires the privileges of a global zone administrator. perzone and
ahlt are described under the -setpolicy option, below.
-aconf
Set the non-attributable audit mask from the audit_control(4) file. For example:
 # auditconfig -aconf
 Configured non-attributable events.
-audit event sorf retval string
This command constructs an audit record for audit event event using the process's audit characteristics containing a
text token string. The return token is constructed from the sorf (success/failure flag) and the retval (return value).
The event is type char*, the sorf is 0/1 for success/failure, retval is an errno value, string is type *char. This com<hy>
mand is useful for constructing an audit record with a shell script. An example of this option:
 # auditconfig -audit AUE_ftpd 0 0 "test string"
 #
 audit record from audit trail:
  header,76,2,ftp access,,Fri Dec 08 08:44:02 2000, + 669 msec
  subject,abc,root,other,root,other,104449,102336,235 197121 elbow
  text,test string
  return,success,0
-chkaconf
Checks the configuration of the non-attributable events set in the kernel against the entries in audit_control(4). If
the runtime class mask of a kernel audit event does not match the configured class mask, a mismatch is reported.
-chkconf
Check the configuration of kernel audit event to class mappings. If the runtime class mask of a kernel audit event
does not match the configured class mask, a mismatch is reported.
-conf
Configure kernel audit event to class mappings. Runtime class mappings are changed to match those in the audit
event to class database file.
-getasid
Prints the audit session ID of the current process. For example:
 # auditconfig -getasid
<beginning of page>
 audit session id = 102336
-getaudit
Returns the audit characteristics of the current process.
 # auditconfig -getaudit
 audit id = abc(666)
 process preselection mask = lo(0x1000,0x1000)
 terminal id (maj,min,host) = 235,197121,elbow(172.146.89.77)
 audit session id = 102336
-getauid
Prints the audit ID of the current process. For example:
 # auditconfig -getauid
 audit id = abc(666)
-getcar
Prints current active root location (anchored from root [or local zone root] at system boot). For example:
 # auditconfig -getcar
 current active root = /
-getclass event
Display the preselection mask associated with the specified kernel audit event. event is the kernel event number or
event name.
-getcond
Display the kernel audit condition. The condition displayed is the literal string auditing meaning auditing is enabled
and turned on (the kernel audit module is constructing and queuing audit records); noaudit, meaning auditing is en<hy>
abled but turned off (the kernel audit module is not constructing and queuing audit records); disabled, meaning that
the audit module has not been enabled; or nospace, meaning there is no space for saving audit records. See audi<hy>
ton(2) and auditd(1M) for further information.
-getestate event
For the specified event (string or event number), print out classes event has been assigned. For example:
 # auditconfig -getestate 20
 audit class mask for event AUE_REBOOT(20) = 0x800
 # auditconfig -getestate AUE_RENAME
 audit class mask for event AUE_RENAME(42) = 0x30
-getkaudit
Get audit characteristics of the current zone. For example:
<beginning of page>
 # auditconfig -getkaudit
 audit id = unknown(-2)
 process preselection mask = lo,na(0x1400,0x1400)
 terminal id (maj,min,host) = 0,0,(0.0.0.0)
 audit session id = 0
If the audit policy perzone is not set, the terminal id is that of the global zone. Otherwise, it is the terminal id of the
local zone.
-getkmask
Get non-attributable pre-selection mask for the current zone. For example:
 # auditconfig -getkmask
 audit flags for non-attributable events = lo,na(0x1400,0x1400)
If the audit policy perzone is not set, the kernel mask is that of the global zone. Otherwise, it is that of the local
zone.
-getpinfo pid
Display the audit ID, preselection mask, terminal ID, and audit session ID for the specified process.
-getpolicy
Display the kernel audit policy. The ahlt and perzone policies reflect the settings from the global zone. If perzone is
set, all other policies reflect the local zone's settings. If perzone is not set, the policies are machine-wide.
-getcwd
Prints current working directory (anchored from zone root at system boot). For example:
 # cd /usr/tmp
 # auditconfig -getcwd
 current working directory = /var/tmp
-getqbufsz
Get audit queue write buffer size. For example:
 # auditconfig -getqbufsz
  audit queue buffer size (bytes) = 1024
-getqctrl
Get audit queue write buffer size, audit queue hiwater mark, audit queue lowater mark, audit queue prod interval
(ticks).
 # auditconfig -getqctrl
 audit queue hiwater mark (records) = 100
 audit queue lowater mark (records) = 10
 audit queue buffer size (bytes) = 1024
 audit queue delay (ticks) = 20
<beginning of page>
-getqdelay
Get interval at which audit queue is prodded to start output. For example:
 # auditconfig -getqdelay
 audit queue delay (ticks) = 20
-getqhiwater
Get high water point in undelivered audit records when audit generation will block. For example:
 # ./auditconfig -getqhiwater
 audit queue hiwater mark (records) = 100
-getqlowater
Get low water point in undelivered audit records where blocked processes will resume. For example:
 # auditconfig -getqlowater
 audit queue lowater mark (records) = 10
-getstat
Print current audit statistics information. For example:
 # auditconfig -getstat
 gen nona kern aud ctl enq wrtn wblk rblk drop tot mem
 910 1 725 184 0 910 910 0 231 0 88 48
See auditstat(1M) for a description of the headings in -getstat output.
-gettid
Print audit terminal ID for current process. For example:
 # auditconfig -gettid
 terminal id (maj,min,host) = 235,197121,elbow(172.146.89.77)
-lsevent
Display the currently configured (runtime) kernel and user level audit event information.
-lspolicy
Display the kernel audit policies with a description of each policy.
-setasid session-ID [cmd]
Execute shell or cmd with specified session-ID. For example:
 # ./auditconfig -setasid 2000 /bin/ksh
 #
 # ./auditconfig -getpinfo 104485
 audit id = abc(666)
<beginning of page>
 process preselection mask = lo(0x1000,0x1000)
 terminal id (maj,min,host) = 235,197121,elbow(172.146.89.77)
 audit session id = 2000
-setaudit audit-ID preselect_flags term-ID session-ID [cmd]
Execute shell or cmd with the specified audit characteristics.
-setauid audit-ID [cmd]
Execute shell or cmd with the specified audit-ID.
-setclass event audit_flag[,audit_flag ...]
Map the kernel event event to the classes specified by audit_flags. event is an event number or name. An audit_flag
is a two character string representing an audit class. See audit_control(4) for further information. If perzone is not
set, this option is valid only in the global zone.
-setkaudit IP-address_type IP_address
Set IP address of machine to specified values. IP-address_type is ipv6 or ipv4.
If perzone is not set, this option is valid only in the global zone.
-setkmask audit_flags
Set non-attributes selection flags of machine.
If perzone is not set, this option is valid only in the global zone.
-setpmask pid flags
Set the preselection mask of the specified process. flags is the ASCII representation of the flags similar to that in au<hy>
dit_control(4).
If perzone is not set, this option is valid only in the global zone.
-setpolicy [+|-]policy_flag[,policy_flag ...]
Set the kernel audit policy. A policy policy_flag is literal strings that denotes an audit policy. A prefix of + adds the
policies specified to the current audit policies. A prefix of - removes the policies specified from the current audit
policies. No policies can be set from a local zone unless the perzone policy is first set from the global zone. The fol<hy>
lowing are the valid policy flag strings (auditconfig -lspolicy also lists the current valid audit policy flag strings):
all Include all policies that apply to the current zone.
ahlt Panic is called and the system dumps core if an asynchronous audit event occurs that cannot be delivered be<hy>
cause the audit queue has reached the high-water mark or because there are insufficient resources to construct an au<hy>
dit record. By default, records are dropped and a count is kept of the number of dropped records.
arge Include the execv(2) system call environment arguments to the audit record. This information is not included
by default.
argv Include the execv(2) system call parameter arguments to the audit record. This information is not included by
default.
<beginning of page>
cnt Do not suspend processes when audit resources are exhausted. Instead, drop audit records and keep a count of
the number of records dropped. By default, process are suspended until audit resources become available.
group Include the supplementary group token in audit records. By default, the group token is not included.
none Include no policies. If used in other than the global zone, the ahlt and perzone policies are not changed.
path Add secondary path tokens to audit record. These are typically the pathnames of dynamically linked shared li<hy>
braries or command interpreters for shell scripts. By default, they are not included.
perzone Maintain separate configuration, queues, and logs for each zone and execute a separate version of au<hy>
ditd(1M) for each zone.
public Audit public files. By default, read-type operations are not audited for certain files which meet public charac<hy>
teristics: owned by root, readable by all, and not writable by all.
trail Include the trailer token in every audit record. By default, the trailer token is not included.
seq Include the sequence token as part of every audit record. By default, the sequence token is not included. The se<hy>
quence token attaches a sequence number to every audit record.
windata_down Include in an audit record any downgraded data moved between windows. This policy is available
only if the system is configured with Trusted Extensions. By default, this information is not included.
windata_up Include in an audit record any upgraded data moved between windows. This policy is available only if
the system is configured with Trusted Extensions. By default, this information is not included.
zonename Include the zonename token as part of every audit record. By default, the zonename token is not includ<hy>
ed. The zonename token gives the name of the zone from which the audit record was generated.
-setqbufsz buffer_size
Set the audit queue write buffer size (bytes).
-setqctrl hiwater lowater bufsz interval
Set the audit queue write buffer size (bytes), hiwater audit record count, lowater audit record count, and wakeup in<hy>
terval (ticks). Valid within a local zone only if perzone is set.
-setqdelay interval
Set the audit queue wakeup interval (ticks). This determines the interval at which the kernel pokes the audit queue,
to write audit records to the audit trail. Valid within a local zone only if perzone is set.
-setqhiwater hiwater
Set the number of undelivered audit records in the audit queue at which audit record generation blocks. Valid within
a local zone only if perzone is set.
-setqlowater lowater
Set the number of undelivered audit records in the audit queue at which blocked auditing processes unblock. Valid
<beginning of page>
within a local zone only if perzone is set.
-setsmask asid flags
Set the preselection mask of all processes with the specified audit session ID. Valid within a local zone only if per<hy>
zone is set.
-setstat
Reset audit statistics counters. Valid within a local zone only if perzone is set.
-setumask auid flags
Set the preselection mask of all processes with the specified audit ID. Valid within a local zone only if perzone is
set.
Example 1 Using auditconfig
The following is an example of an auditconfig program:
 #
 # map kernel audit event number 10 to the "fr" audit class
 #
 % auditconfig -setclass 10 fr
 #
 # turn on inclusion of exec arguments in exec audit records
 #
 % auditconfig -setpolicy +argv
0 Successful completion.
1 An error occurred.
/etc/security/audit_event Stores event definitions used in the audit system.
/etc/security/audit_class Stores class definitions used in the audit system.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ Interface StabilityCommitted
audit(1M), auditd(1M), auditstat(1M), bsmconv(1M), praudit(1M), auditon(2), execv(2), audit_class(4), au<hy>
dit_control(4), audit_event(4), attributes(5), audit_binfile(5)
See the section on Solaris Auditing in System Administration Guide: Security Services.
If plugin output is selected using audit_control(4), the behavior of the system with respect to the -setpolicy +cnt
and the -setqhiwater options is modified slightly. If -setpolicy +cnt is set, data will continue to be sent to the select<hy>
ed plugin, even though output to the binary audit log is stopped, pending the freeing of disk space. If -setpolicy -cnt
is used, the blocking behavior is as described under OPTIONS, above. The value set for the queue high water mark
is used within auditd as the default value for its queue limits unless overridden by means of the qsize attribute as de<hy>
scribed in audit_control(4).
<beginning of page>
The auditconfig options that modify or display process-based information are not affected by the perzone policy.
Those that modify system audit data such as the terminal id and audit queue parameters are valid only in the global
zone, unless the perzone policy is set. The display of a system audit reflects the local zone if perzone is set. Other<hy>
wise, it reflects the settings of the global zone.
The -setcond option has been removed. Use audit(1M) to enable or disable auditing.
The -getfsize and -setfsize options have been removed. Use audit_binfile(5) p_fsize to set the audit file size.
auditd.1m <beginning of page>
auditd <-> audit daemon
/usr/sbin/auditd
The audit daemon, auditd, controls the generation and location of audit trail files and the generation of syslog mes<hy>
sages based on the definitions in audit_control(4). If auditing is enabled, auditd reads the audit_control file to do
the following: <bu> reads the path to a library module for realtime conversion of audit data into syslog messages; <bu> reads
other parameters specific to the selected plugin or plugins; <bu> obtains a list of directories into which audit files can be
written; <bu> obtains the percentage limit for how much space to reserve on each filesystem before changing to the next
directory.
audit(1M) is used to control auditd. It can cause auditd to: <bu> close the current audit file and open a new one; <bu> close
the current audit file, re-read /etc/security/audit_control and open a new audit file; <bu> close the audit trail and termi<hy>
nate auditing.
The audit daemon invokes the program audit_warn(1M) under the following conditions with the indicated options:
audit_warn soft pathname
The file system upon which pathname resides has exceeded the minimum free space limit defined in audit_con<hy>
trol(4). A new audit trail has been opened on another file system.
audit_warn allsoft
All available file systems have been filled beyond the minimum free space limit. A new audit trail has been opened
anyway.
audit_warn hard pathname
The file system upon which pathname resides has filled or for some reason become unavailable. A new audit trail
has been opened on another file system.
audit_warn allhard count
All available file systems have been filled or for some reason become unavailable. The audit daemon will repeat this
call to audit_warn at intervals of at least twenty seconds until space becomes available. count is the number of
times that audit_warn has been called since the problem arose.
audit_warn ebusy
There is already an audit daemon running.
audit_warn tmpfile
The file /etc/security/audit/audit_tmp exists, indicating a fatal error.
audit_warn nostart
The internal system audit condition is AUC_FCHDONE. Auditing cannot be started without rebooting the system.
audit_warn auditoff
The internal system audit condition has been changed to not be AUC_AUDITING by someone other than the audit
daemon. This causes the audit daemon to exit.
audit_warn postsigterm
An error occurred during the orderly shutdown of the auditing system.
<beginning of page>
audit_warn getacdir
There is a problem getting the directory list from /etc/security/audit/audit_control.
The audit daemon will hang in a sleep loop until this file is fixed.
/etc/security/audit/audit_control
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ Interface StabilityCommitted
audit(1M), audit_warn(1M), bsmconv(1M), praudit(1M), auditon(2), audit.log(4), audit_control(4), at<hy>
tributes(5)
See the section on Solaris Auditing in System Administration Guide: Security Services.
The functionality described in this man page is available only if the Solaris Auditing feature has been enabled. See
bsmconv(1M) for more information.
auditd is loaded in the global zone at boot time if auditing is enabled. See bsmconv(1M).
If the audit policy perzone is set, auditd runs in each zone, starting automatically when the local zone boots. If a
zone is running when the perzone policy is set, auditing must be started manually in local zones. It is not necessary
to reboot the system or the local zone to start auditing in a local zone. auditd can be started with "/usr/sbin/audit
-s" and will start automatically with future boots of the zone.
When auditd runs in a local zone, the configuration is taken from the local zone's /etc/security directory's files: au<hy>
dit_control, audit_class, audit_user, audit_startup, and audit_event.
Configuration changes do not affect audit sessions that are currently running, as the changes do not modify a
process's preselection mask. To change the preselection mask on a running process, use the -setpmask option of the
auditconfig command (see auditconfig(1M)). If the user logs out and logs back in, the new configuration changes
will be reflected in the next audit session.
audit.log.4 <beginning of page>
audit.log <-> audit trail file
#include <bsm/audit.h>
#include <bsm/audit_record.h>
audit.log files are the depository for audit records stored locally or on an on an NFS-mounted audit server. These
files are kept in directories named in the file audit_control(4) using the dir option. They are named to reflect the
time they are created and are, when possible, renamed to reflect the time they are closed as well. The name takes the
form
yyyymmddhhmmss.not_terminated.hostname
when open or if the auditd(1M) terminated ungracefully, and the form
yyyymmddhhmmss.yyyymmddhhmmss.hostname
when properly closed. yyyy is the year, mm the month, dd day in the month, hh hour in the day, mm minute in the
hour, and ss second in the minute. All fields are of fixed width.
Audit data is generated in the binary format described below; the default for Solaris audit is binary format. See au<hy>
dit_syslog(5) for an alternate data format.
The audit.log file begins with a standalone file token and typically ends with one also. The beginning file token
records the pathname of the previous audit file, while the ending file token records the pathname of the next audit
file. If the file name is NULL the appropriate path was unavailable.
The audit.log files contains audit records. Each audit record is made up of audit tokens. Each record contains a
header token followed by various data tokens. Depending on the audit policy in place by auditon(2), optional other
tokens such as trailers or sequences may be included.
The tokens are defined as follows:
The file token consists of:
 token ID 1 byte
 seconds of time 4 bytes
 microseconds of time 4 bytes
 file name length 2 bytes
 file pathname N bytes + 1 terminating NULL byte
The header token consists of:
 token ID 1 byte
 record byte count 4 bytes
 version # 1 byte [2]
 event type 2 bytes
 event modifier 2 bytes
 seconds of time 4 bytes/8 bytes (32-bit/64-bit value)
 nanoseconds of time 4 bytes/8 bytes (32-bit/64-bit value)
The expanded header token consists of:
 token ID 1 byte
 record byte count 4 bytes
 version # 1 byte [2]
 event type 2 bytes
 event modifier 2 bytes
 address type/length 1 byte
 machine address 4 bytes/16 bytes (IPv4/IPv6 address)
 seconds of time 4 bytes/8 bytes (32/64-bits)
 nanoseconds of time 4 bytes/8 bytes (32/64-bits)
<beginning of page>
The trailer token consists of:
 token ID 1 byte
 trailer magic number 2 bytes
 record byte count 4 bytes
The arbitrary data token is defined:
 token ID 1 byte
 how to print 1 byte
 basic unit 1 byte
 unit count 1 byte
 data items (depends on basic unit)
The in_addr token consists of:
 token ID 1 byte
 IP address type/length 1 byte
 IP address 4 bytes/16 bytes (IPv4/IPv6 address)
The expanded in_addr token consists of:
 token ID 1 byte
 IP address type/length 4 bytes/16 bytes (IPv4/IPv6 address)
 IP address 16 bytes
The ip token consists of:
 token ID 1 byte
 version and ihl 1 byte
 type of service 1 byte
 length 2 bytes
 id 2 bytes
 offset 2 bytes
 ttl 1 byte
 protocol 1 byte
 checksum 2 bytes
 source address 4 bytes
 destination address 4 bytes
The expanded ip token consists of:
 token ID 1 byte
 version and ihl 1 byte
 type of service 1 byte
 length 2 bytes
 id 2 bytes
 offset 2 bytes
 ttl 1 byte
 protocol 1 byte
 checksum 2 bytes
 address type/type 1 byte
 source address 4 bytes/16 bytes (IPv4/IPv6 address)
<beginning of page>
 address type/length 1 byte
 destination address 4 bytes/16 bytes (IPv4/IPv6 address)
The iport token consists of:
 token ID 1 byte
 port IP address 2 bytes
The path token consists of:
 token ID 1 byte
 path length 2 bytes
 path N bytes + 1 terminating NULL byte
The path_attr token consists of:
 token ID 1 byte
 count 4 bytes
 path count null-terminated string(s)
The process token consists of:
 token ID 1 byte
 audit ID 4 bytes
 effective user ID 4 bytes
 effective group ID 4 bytes
 real user ID 4 bytes
 real group ID 4 bytes
 process ID 4 bytes
 session ID 4 bytes
 terminal ID 
  port ID 4 bytes/8 bytes (32-bit/64-bit value)
  machine address 4 bytes
The expanded process token consists of:
 token ID 1 byte
 audit ID 4 bytes
 effective user ID 4 bytes
 effective group ID 4 bytes
 real user ID 4 bytes
 real group ID 4 bytes
 process ID 4 bytes
 session ID 4 bytes
 terminal ID 
  port ID 4 bytes/8 bytes (32-bit/64-bit value)
  address type/length 1 byte
  machine address 4 bytes/16 bytes (IPv4/IPv6 address)
The return token consists of:
 token ID 1 byte
 error number 1 byte
 return value 4 bytes/8 bytes (32-bit/64-bit value)
<beginning of page>
The subject token consists of:
 token ID 1 byte
 audit ID 4 bytes
 effective user ID 4 bytes
 effective group ID 4 bytes
 real user ID 4 bytes
 real group ID 4 bytes
 process ID 4 bytes
 session ID 4 bytes
 terminal ID 
  port ID 4 bytes/8 bytes (32-bit/64-bit value)
  machine address 4 bytes
The expanded subject token consists of:
 token ID 1 byte
 audit ID 4 bytes
 effective user ID 4 bytes
 effective group ID 4 bytes
 real user ID 4 bytes
 real group ID 4 bytes
 process ID 4 bytes
 session ID 4 bytes
 terminal ID 
  port ID 4 bytes/8 bytes (32-bit/64-bit value)
  address type/length 1 byte
  machine address 4 bytes/16 bytes (IPv4/IPv6 address)
The System V IPC token consists of:
 token ID 1 byte
 object ID type 1 byte
 object ID 4 bytes
The text token consists of:
 token ID 1 byte
 text length 2 bytes
 text N bytes + 1 terminating NULL byte
The attribute token consists of:
 token ID 1 byte
 file access mode 4 bytes
 owner user ID 4 bytes
 owner group ID 4 bytes
 file system ID 4 bytes
 node ID 8 bytes
 device 4 bytes/8 bytes (32-bit/64-bit)
The groups token consists of:
<beginning of page>
 token ID 1 byte
 number groups 2 bytes
 group list N * 4 bytes
The System V IPC permission token consists of:
 token ID 1 byte
 owner user ID 4 bytes
 owner group ID 4 bytes
 creator user ID 4 bytes
 creator group ID 4 bytes
 access mode 4 bytes
 slot sequence # 4 bytes
 key 4 bytes
The arg token consists of:
 token ID 1 byte
 argument # 1 byte
 argument value 4 bytes/8 bytes (32-bit/64-bit value)
 text length 2 bytes
 text N bytes + 1 terminating NULL byte
The exec_args token consists of:
 token ID 1 byte
 count 4 bytes
 text count null-terminated string(s)
The exec_env token consists of:
 token ID 1 byte
 count 4 bytes
 text count null-terminated string(s)
The exit token consists of:
 token ID 1 byte
 status 4 bytes
 return value 4 bytes
The socket token consists of:
 token ID 1 byte
 socket type 2 bytes
 remote port 2 bytes
 remote Internet address 4 bytes
The expanded socket token consists of:
 token ID 1 byte
 socket domain 2 bytes
<beginning of page>
 socket type 2 bytes
 local port 2 bytes
 address type/length 2 bytes
 local port 2 bytes
 local Internet address 4 bytes/16 bytes (IPv4/IPv6 address)
 remote port 2 bytes
 remote Internet address 4 bytes/16 bytes (IPv4/IPv6 address)
The seq token consists of:
 token ID 1 byte
 sequence number 4 bytes
The privilege token consists of:
 token ID 1 byte
 text length 2 bytes
 privilege set name N bytes + 1 terminating NULL byte
 text length 2 bytes
 list of privileges N bytes + 1 terminating NULL byte
The use-of-auth token consists of:
 token ID 1 byte
 text length 2 bytes
 authorization(s) N bytes + 1 terminating NULL byte
The use-of-privilege token consists of:
 token ID 1 byte
 succ/fail 1 byte
 text length 2 bytes
 privilege used N bytes + 1 terminating NULL byte
The command token consists of:
 token ID 1 byte
 count of args 2 bytes
 argument list (count times)
 text length 2 bytes
 argument text N bytes + 1 terminating NULL byte
 count of env strings 2 bytes
 environment list (count times)
 text length 2 bytes
 env. text N bytes + 1 terminating NULL byte
The ACL token consists of:
 token ID   1 byte
 type     4 bytes
 value    4 bytes
 file mode    4 bytes
The ACE token consists of:
 token ID 1 byte
 who 4 bytes
<beginning of page>
 access_mask 4 bytes
 flags 2 bytes
 type 2 bytes
The zonename token consists of:
 token ID 1 byte
 name length 2 bytes
 name <name length> including terminating NULL byte
The fmri token consists of:
 token ID 1 byte
 fmri length 2 bytes
 fmri <fmri length> including terminating NULL byte
The label token consists of:
 token ID 1 byte
 label ID 1 byte
 compartment length 1 byte
 classification 2 bytes
 compartment words <compartment length> * 4 bytes
The xatom token consists of:
 token ID 1 byte
 string length 2 bytes
 atom string string length bytes
The xclient token consists of:
 token ID 1 byte
 client ID 4 bytes
The xcolormap token consists of:
 token ID 1 byte
 XID 4 bytes
 creator UID 4 bytes
The xcursor token consists of:
 token ID 1 byte
 XID 4 bytes
 creator UID 4 bytes
The xfont token consists of:
 token ID 1 byte
 XID 4 bytes
 creator UID 4 bytes
The xgc token consists of:
 token ID 1 byte
 XID 4 bytes
<beginning of page>
 creator UID 4 bytes
The xpixmap token consists of:
 token ID 1 byte
 XID 4 bytes
 creator UID 4 bytes
The xproperty token consists of:
 token ID 1 byte
 XID 4 bytes
 creator UID 4 bytes
 string length 2 bytes
 string string length bytes
The xselect token consists of:
 token ID 1 byte
 property length 2 bytes
 property string property length bytes
 prop. type len. 2 bytes
 prop type prop. type len. bytes
 data length 2 bytes
 window data data length bytes
The xwindow token consists of:
 token ID 1 byte
 XID 4 bytes
 creator UID 4 bytes
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
See below.
The binary file format is Committed. The binary file contents is Uncommitted.
audit(1M), auditd(1M), bsmconv(1M), audit(2), auditon(2), au_to(3BSM), audit_control(4), audit_syslog(5)
Part VII, Solaris Auditing, in System Administration Guide: Security Services
Each token is generally written using the au_to(3BSM) family of function calls.
auditrecord.1m <beginning of page>
auditrecord <-> display Solaris audit record formats
/usr/sbin/auditrecord [-d] [ [-a] | [-e string] | [-c class] |
 [-i id] | [-p programname] | [-s systemcall] | [-h]]
The auditrecord utility displays the event ID, audit class and selection mask, and record format for audit record
event types defined in audit_event(4). You can use auditrecord to generate a list of all audit record formats, or to
select audit record formats based on event class, event name, generating program name, system call name, or event
ID.
There are two output formats. The default format is intended for display in a terminal window; the optional HTML
format is intended for viewing with a web browser.
Tokens contained in square brackets ( [ ] ) are optional and might not be present in every record.
The following options are supported:
-a
List all audit records.
-c class
List all audit records selected by class. class is one of the two-character class codes from the file /etc/security/au<hy>
dit_class.
-d
Debug mode. Display number of audit records that are defined in audit_event, the number of classes defined in au<hy>
dit_class, any mismatches between the two files, and report which defined events do not have format information
available to auditrecord.
-e string
List all audit records for which the event ID label contains the string string. The match is case insensitive.
-h
Generate the output in HTML format.
-i id
List the audit records having the numeric event ID id.
-p programname
List all audit records generated by the program programname, for example, audit records generated by a user-space
program.
-s systemcall
List all audit records generated by the system call systemcall, for example, audit records generated by a system call.
The -p and -s options are different names for the same thing and are mutually exclusive. The -a option is ignored if
any of -c, -e, -i, -p, or -s are given. Combinations of -c, -e, -i, and either -p or -s are ANDed together. Example 1
Displaying an Audit Record with a Specified Event ID
The following example shows how to display the contents of a specified audit record.
 % auditrecord -i 6152
  terminal login
<beginning of page>
  program /usr/sbin/login see login(1)
  /usr/dt/bin/dtlogin See dtlogin
  event ID 6152 AUE_login
  class lo (0x00001000)
  header
  subject
  [text] error message
  return
Example 2 Displaying an Audit Record with an Event ID Label that Contains a Specified String
The following example shows how to display the contents of a audit record with an event ID label that contains the
string login.
 # auditrecord -e login
 terminal login
  program /usr/sbin/login see login(1)
  /usr/dt/bin/dtlogin See dtlogin
  event ID 6152 AUE_login
  class lo (0x00001000)
  header
  subject
  [text] error message
  return
 rlogin
  program /usr/sbin/login see login(1) - rlogin
  event ID 6155 AUE_rlogin
  class lo (0x00001000)
  header
  subject
  [text] error message
  return
0
Successful operation
non-zero
Error
/etc/security/audit_class
Provides the list of valid classes and the associated audit mask.
/etc/security/audit_event
Provides the numeric event ID, the literal event name, and the name of the associated system call or program.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsr _ CSIEnabled _ Interface StabilityObsolete Uncommitted
auditconfig(1M), praudit(1M), audit.log(4), audit_class(4), audit_event(4), attributes(5)
<beginning of page>
See the section on Solaris Auditing in System Administration Guide: Security Services.
If unable to read either of its input files or to write its output file, auditrecord shows the name of the file on which it
failed and exits with a non-zero return.
If no options are provided, if an invalid option is provided, or if both -s and -p are provided, an error message is dis<hy>
played and auditrecord displays a usage message then exits with a non-zero return.
This command is Obsolete and may be removed and replaced with equivalent functionality in a future release of So<hy>
laris. This command was formerly known as bsmrecord.
If /etc/security/audit_event has been modified to add user-defined audit events, auditrecord displays the record
format as undefined.
The audit records displayed by bsmrecord are the core of the record that can be produced. Various audit policies
and optional tokens, such as those shown below, might also be present.
The following is a list of praudit(1M) token names with their descriptions.
group
Present if the group audit policy is set.
sensitivity label
Present when Trusted Extensions is enabled and represents the label of the subject or object with which it is associ<hy>
ated. The mandatory_label token is noted in the basic audit record where a label is explicitly part of the record.
sequence
Present when the seq audit policy is set.
trailer
Present when the trail audit policy is set.
zone
The name of the zone generating the record when the zonename audit policy is set. The zonename token is noted in
the basic audit record where a zone name is explicitly part of the record.
audit_remote.5 <beginning of page>
audit_remote <-> send Solaris audit logs to a remote server
/usr/lib/security/audit_remote.so
The audit_remote plugin module for Solaris audit, /usr/lib/security/audit_remote.so, sends binary audit records
(audit.log(4)) to audit servers specified in audit_control(4).
The audit_remote plugin is loaded by auditd(1M) if audit_control contains a plugin: specification of name=au<hy>
dit_remote.so.
The following attributes specify the configuration of audit_remote plugin:
p_hosts
 host1[:[port1][:mech1]][,host2[:[port2][:mech2]],... \
  hostn[:[portn][:mechn]]]
A list of audit hosts/servers. Audit records are sent to the first available host. If a host is unreachable or a timeout oc<hy>
curs while sending data, the next host in the list is tried. If connection to all hosts fails, the list is tried again from the
beginning.
The host part of a p_hosts entry can be in any form acceptable to getipnodebyname(3SOCKET).
The port part of a p_hosts entry is the port on host that is contacted to initiate an audit server connection. If not
specified, the port number is that assigned to the solaris-audit service. See getservbyname(3XNET).
The mech part of a p_host entry is the GSS-API mechanism name (mech(4)). If not specified, the local host's de<hy>
fault mechanism is used. The recommended mechanism is kerberos_v5.
p_retries
The number of retries for connecting to and sending data to a server.
The default value is 3.
p_timeout
The number of seconds in which a connection/sending data timeouts.
The default value is 5 seconds.
qsize
The maximum number of outstanding audit records to keep.
The default is the value of the kernel queue control high water mark. See auditconfig(1M).
The audit_remote plugin is a TCP client that authenticates configured audit servers using the GSS-API
(libgss(3LIB)). Binary Solaris Audit records are sent with integrity and confidentiality protection as per-message to<hy>
kens generated by gss_wrap(3GSS).
The plugin initiates a TCP connection to an audit server (host:port:mech) and establishes a GSS security context
(with gss_init_sec_context(3GSS)), with appropriate security mechanism (mech(4)).
If no port is specified, the service name solaris-audit is looked up to obtain a TCP port number. If no mechanism is
specified, the GSS_C_NO_OID is used as a mech_type parameter of gss_init_sec_context(3GSS), and causes the
underlying GSS-API to use the local default mechanism.
gss_init_sec_context(3GSS) uses GSS_C_NO_CREDENTIAL as the initiator credential handle and a target name
of the form audit@<ost_fqdn>. The server is expected to use gss_accept_sec_context(3GSS) to complete the con<hy>
text establishment.
<beginning of page>
Once the security context is established, the client (audit_remote plugin) calls gss_wrap(3GSS) to achieve the con<hy>
fidentiality of the transferred payload - the audit records. The server is expected to use gss_unwrap(3GSS) to un<hy>
wrap the received data and gss_get_mic(3GSS) to obtain the MIC (Message Integrity Code) to be later sent back to
the plugin as a message retrieval acknowledgment.
For example, if the kerberos_v5 mechanism is configured as GSS_API mechanism on the client and both sides
agree on using this mechanism, the client side has to be eligible to non-interactively gain session keys for the au<hy>
dit/<host_fqdn>@<REALM> principal from the Kerberos KDC/TGS. At the same time the identity running the
audit server application has to have the long term keys associated with the audit/<host_fqdn>@<REALM> princi<hy>
pal stored in the keytab file (krb5.conf(4)) to be able to decrypt the session keys.
The audit_remote plugin initiates a connection to first server in the p_hosts list. If the connection fails or audit
record sends are not responded to in p_timeout seconds, after p_retries attempts the plugin tries to connect to the
next server. If the connection to the last server fails, the plugin retries to connect to the first host in the list. au<hy>
dit_warn(1M) is executed at every unsuccessful attempt to connect to the server or send timeout with the plugin op<hy>
tion plugin audit_remote.so retry <count> <error>.<error> is connection <host:port> <the network error>. An
EPROTO network error indicates that the client plugin did not get a successful protocol version handshake.
All protocol messages are preceded by the 4 octets of the size of the data to follow. This size is in network byte or<hy>
der.
The protocol begins with version negotiation followed by a GSS-API security context token exchange. On error the
connection is closed (and any output token optionally sent).
The version negotiation takes place in the clear with the plugin sending an octet array of the comma (,) separated list
of versions supported. The current version number is the characters 01. The receiver is expected to respond with the
version that they accept (in the current case that is the characters 01). A mismatch is considered an error and the con<hy>
nection is closed.
The version octet array sent by the plugin and the version characters accepted by the receiver are concatenated to<hy>
gether to make up the application data field of the channel bindings of the GSS security context establishment.
 <plugin version characters> || <server accepted version characters>"
 ||" represents concatenation
Subsequent tokens contain a 64 bit sequence number in network byte order and a single audit record (audit.log(4));
the client uses confidentiality protection. wrap (64 bit sequence number || audit record)
The server acknowledges the receipt (and is then responsible for any data loss) with the received 64 bit sequence
number and a MIC token of the unwrapped 64 bit sequence number and audit record. MIC verification on the client
side acknowledges the audit record can be freed and not saved for possible retransmission.
 64 bit sequence number || mic (64 bit sequence number || audit record)
Secure remote audit client/server communication flow:
 1) Client <--> Server - TCP handshake
 2) Client <--> Server - protocol version negotiation:
  a) Client --> Server - send data size - uint32_t value (2)
  b) Client --> Server - send clear text message of the versions
  supported comma separated, e.g.,
  "01,02,03" for versions 1 and 2 and 3.
  The only version supported at present is
  "01"
  c) Client <-- Server - send data size - uint32_t value (2)
  d) Client <-- Server - send clear text version selected
  ("01")
  :no version match; close connection; try next host
 3) Security context initiation:
  a) Client - Construct channel bindings application data value
  (4 octets "0101")
  b) Client --> Server - send token (data) size - uint32_t value
<beginning of page>
  c) Client --> Server - GSS-API per-context token
  d) Client <-- Server - send token (data) size
  e) Client <-- Server - GSS-API per-context token
  :repeat a-e until security context is initialized; if unsuccessful,
  close connection; try next host
 4) Client - transmit thread, when audit record to be sent:
  a) Client --> Server - send data size
  b) Client --> Server - GSS-API per-message token
  wrap (sequence number || audit record)
  :repeat a-b while less than max (qsize) outstanding records
  5) Client - receive thread:
  a) Client <-- Server - receive data size - uint32_t value
  b) Client <-- Server - receive sequence number - uint64_t value
  c) Client <-- Server - receive MIC
  d) Client - MIC verification - OK
  e) Client - remove particular audit record
  pointed by the sequence number from the
  retransmit buffer
  :repeat a-e, on error close connection; try next host;
  retransmit unacknowledged audit records
 6) Server - receive thread:
  a) Client --> Server - receive data size
  b) Client --> Server - GSS-API receive, uwrap, store
  per-message token
 7) Server - transmit thread:
  a) Server - MIC generation - message integrity code
  mic (sequence number || audit record)
  b) Client <-- Server - send data size
  c) Client < -- Server - send sequence number
  d) Client <-- Server - send MIC
Example 1 Loading audit_remote.so and Specifying the Remote Audit Servers
The following directives cause audit_remote.so to be loaded and specify the remote audit servers to where the audit
records are sent. The kerberos_v5 security mechanism is defined to be used when communicating with the servers.
 plugin: name=audit_remote.so;\
 p_timeout=90;p_retries=2;\
 p_hosts=eggplant.eng.sun.com::kerberos_v5,\
 purple.ebay.sun.com:4592:kerberos_v5
Example 2 Using the Configuration of Usage Default Security Mechanism
The following example shows the configuration of usage of default security mechanism. It also shows use of default
port on one of the configured servers:
 plugin: name=audit_remote.so;\
 p_timeout=10;p_retries=2;\
 p_hosts=jedger.eng.sun.com,\
 jbadams.ebay.sun.com:4592
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT LevelMT-Safe
_ Interface StabilitySee below.
<beginning of page>
The plugin configuration parameters are Committed. The client/server protocol (version "01") is Contracted Project
Private. See audit.log(4) for the audit record format and content stability.
auditd(1M), auditconfig(1M), audit_warn(1M), getipnodebyname(3SOCKET), getservbyname(3XNET),
gss_accept_sec_context(3GSS), gss_get_mic(3GSS), gss_init_sec_context(3GSS), gss_wrap(3GSS), gss_un<hy>
wrap(3GSS), libgss(3LIB), libsocket(3LIB), audit_control(4), audit.log(4), krb5.conf(4), mech(4), attributes(5),
kerberos(5), tcp(7P)
audit_remote authenticates itself to the remote audit service by way of GSS-API (libgss(3LIB)). Default gss cre<hy>
dentials are used as provided by the gss implementation mechanism, such as Kerberos.
The solaris-audit service port assigned by IANA is 16162.
auditstat.1m <beginning of page>
auditstat <-> display kernel audit statistics
auditstat [-c count] [-h numlines] [-i interval] [-n]
 [-T u | d ] [-v]
auditstat displays kernel audit statistics. The fields displayed are as follows:
aud The total number of audit records processed by the audit(2) system call.
ctl This field is obsolete.
drop The total number of audit records that have been dropped. Records are dropped according to the kernel audit
policy. See auditon(2), AUDIT_CNT policy for details.
enq The total number of audit records put on the kernel audit queue.
gen The total number of audit records that have been constructed (not the number written).
kern The total number of audit records produced by user processes (as a result of system calls).
mem The total number of Kbytes of memory currently in use by the kernel audit module.
nona The total number of non-attributable audit records that have been constructed. These are audit records that are
not attributable to any particular user.
rblk The total number of times that the audit queue has blocked waiting to process audit data.
tot The total number of Kbytes of audit data written to the audit trail.
wblk The total number of times that user processes blocked on the audit queue at the high water mark.
wrtn The total number of audit records written. The difference between enq and wrtn is the number of outstanding
audit records on the audit queue that have not been written.
-c count Display the statistics a total of count times. If count is equal to zero, statistics are displayed indefinitely. A
time interval must be specified.
-h numlines Display a header for every numlines of statistics printed. The default is to display the header every 20
lines. If numlines is equal to zero, the header is never displayed.
-i interval Display the statistics every interval where interval is the number of seconds to sleep between each collec<hy>
tion.
-n Display the number of kernel audit events currently configured.
-T u | d Display a time stamp.
Specify u for a printed representation of the internal representation of time. See time(2). Specify d for standard date
format. See date(1).
<beginning of page>
-v Display the version number of the kernel audit module software.
auditstat returns 0 upon success and 1 upon failure.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
auditconfig(1M), praudit(1M), bsmconv(1M), audit(2), auditon(2), attributes(5)
The functionality described in this man page is available only if Solaris Auditing has been enabled. See bsm<hy>
conv(1M) for more information.
audit_user.4 <beginning of page>
audit_user <-> per-user auditing data file
/etc/security/audit_user
audit_user is a database that stores per-user auditing preselection data. You can use the audit_user file with other
authorization sources, including the NIS map audit_user.byname and the NIS+ table audit_user. Programs use the
getauusernam(3BSM) routines to access this information.
The search order for multiple user audit information sources is specified in the /etc/nsswitch.conf file. See nss<hy>
witch.conf(4). The lookup follows the search order for passwd(4).
The fields for each user entry are separated by colons (:). Each user is separated from the next by a newline. au<hy>
dit_user does not have general read permission. Each entry in the audit_user file has the form:
 username:always-audit-flags:never-audit-flags
The fields are defined as follows:
username User's login name.
always-audit-flags Flags specifying event classes to always audit.
never-audit-flags Flags specifying event classes to never audit.
For a complete description of the audit flags and how to combine them, see audit_control(4). Example 1 Using the
audit_user File
 other:lo,am:io,cl
 fred:lo,ex,+fc,-fr,-fa:io,cl
 ethyl:lo,ex,nt:io,cl
/etc/nsswitch.conf
/etc/passwd
/etc/security/audit_user
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability
See below.
The file format stability is Committed. The file content is Uncommitted.
bsmconv(1M), getauusernam(3BSM), audit_control(4), nsswitch.conf(4), passwd(4)
Part VII, Solaris Auditing, in System Administration Guide: Security Services
This functionality is available only if the Basic Security Module (BSM) has been enabled. See bsmconv(1M) for
more information.
Configuration changes do not affect audit sessions that are currently running, as the changes do not modify a
process's preselection mask. To change the preselection mask on a running process, use the -setpmask option of the
auditconfig command (see auditconfig(1M)). If the user logs out and logs back in, the new configuration changes
will be reflected in the next audit session.
au_open.3bsm <beginning of page>
au_open, au_close, au_write <-> construct and write audit records
cc [ flag... ] file... -lbsm -lsocket -lnsl [ library... ]
#include <bsm/libbsm.h>
int au_close(int d, int keep, short event);
int au_open(void);
int au_write(int d, token_t *m);
The au_open() function returns an audit record descriptor to which audit tokens can be written using au_write().
The audit record descriptor is an integer value that identifies a storage area where audit records are accumulated.
The au_close() function terminates the life of an audit record d of type event started by au_open(). If the keep pa<hy>
rameter is AU_TO_NO_WRITE, the data contained therein is discarded. If the keep parameter is
AU_TO_WRITE, the additional parameters are used to create a header token. Depending on the audit policy infor<hy>
mation obtained by auditon(2), additional tokens such as sequence and trailer tokens can be added to the record.
The au_close() function then writes the record to the audit trail by calling audit(2). Any memory used is freed by
calling free(3C).
The au_write() function adds the audit token pointed to by m to the audit record identified by the descriptor d. After
this call is made the audit token is no longer available to the caller.
Upon successful completion, au_open() returns an audit record descriptor. If a descriptor could not be allocated,
au_open() returns <mi>1 and sets errno to indicate the error.
Upon successful completion, au_close() returns 0. If d is an invalid or corrupted descriptor or if audit() fails,
au_close() returns <mi>1 without setting errno. If audit() fails, errno is set to one of the error values described on the
audit(2) manual page.
Upon successful completion, au_write() returns 0. If d is an invalid descriptor or m is an invalid token, or if audit()
fails, au_write() returns <mi>1 without setting errno. If audit() fails, errno is set to one of the error values described
on the audit(2) manual page.
The au_open() function will fail if:
ENOMEM The physical limits of the system have been exceeded such that sufficient memory cannot be allocated.
EAGAIN There is currently insufficient memory available. The application can try again later.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
bsmconv(1M), audit(2), auditon(2), au_preselect(3BSM), au_to(3BSM), free(3C), attributes(5)
The functionality described on this manual page is available only if the Solaris Auditing has been enabled. See
bsmconv(1M) for more information.
auth_attr.4 <beginning of page>
auth_attr <-> authorization description database
/etc/security/auth_attr
/etc/security/auth_attr is a local source for authorization names and descriptions. The auth_attr file can be used
with other authorization sources, including the auth_attr NIS map and NIS+ table. Programs use the getauthat<hy>
tr(3SECDB) routines to access this information.
The search order for multiple authorization sources is specified in the /etc/nsswitch.conf file, as described in the
nsswitch.conf(4) man page.
An authorization is a right assigned to users that is checked by certain privileged programs to determine whether
users can execute restricted functionality. Each entry in the auth_attr database consists of one line of text containing
six fields separated by colons (:). Line continuations using the backslash (\) character are permitted. The format of
each entry is:
 name:res1:res2:short_desc:long_desc:attr
name The name of the authorization. Authorization names are unique strings. Construct authorization names using
the following convention:
prefix. or prefix.suffix
prefix Everything in the name field up to the final dot (.). Authorizations from Sun Microsystems, Inc. use solaris as
a prefix. To avoid name conflicts, all other authorizations should use a prefix that begins with the reverse-order Inter<hy>
net domain name of the organization that creates the authorization (for example, com.xyzcompany). Prefixes can
have additional arbitrary components chosen by the authorization's developer, with components separated by dots.
suffix The final component in the name field. Specifies what is being authorized.
When there is no suffix, the name is defined as a heading. Headings are not assigned to users but are constructed for
use by applications in their GUIs.
When a name ends with the word grant, the entry defines a grant authorization. Grant authorizations are used to
support fine-grained delegation. Users with appropriate grant authorizations can delegate some of their authoriza<hy>
tions to others. To assign an authorization, the user needs to have both the authorization itself and the appropriate
grant authorization.
res1 Reserved for future use.
res2 Reserved for future use.
short_desc A short description or terse name for the authorization. This name should be suitable for displaying in us<hy>
er interfaces, such as in a scrolling list in a GUI.
long_desc A long description. This field can explain the precise purpose of the authorization, the applications in
which it is used, and the type of user that would be interested in using it. The long description can be displayed in
the help text of an application.
attr An optional list of semicolon-separated (;) key-value pairs that describe the attributes of an authorization. Zero
or more keys may be specified. The keyword help identifies a help file in HTML.
Example 1 Constructing a Name
In the following example, the name has a prefix (solaris.admin.usermgr) followed by a suffix (read):
 solaris.admin.usermgr.read
<beginning of page>
Example 2 Defining a Heading
Because the name field ends with a dot, the following entry defines a heading:
 solaris.admin.usermgr.:::User Accounts::help=AuthUsermgrHeader.html
Example 3 Assigning Separate Authorizations to Set User Attributes
In this example, a heading entry is followed by other associated authorization entries. The entries below the heading
provide separate authorizations for setting user attributes. The attr field for each entry, including the heading entry,
assigns a help file. The application that uses the help key requires the value to equal the name of a file ending in
.htm or .html:
 solaris.admin.usermgr.:::User Accounts::help=AuthUsermgrHeader.html
 solaris.admin.usermgr.pswd:::Change Password::help=AuthUserMgrPswd.html
 solaris.admin.usermgr.write:::Manage Users::help=AuthUsermgrWrite.html
Example 4 Assigning a Grant Authorization
This example assigns to an administrator the following authorizations:
 solaris.admin.printer.grant
 solaris.admin.printer.delete
 solaris.admin.printer.modify
 solaris.admin.printer.read
 solaris.login.enable
With the above authorizations, the administrator can assign to others the solaris.admin.printer.delete, solaris.ad<hy>
min.printer.modify, and solaris.admin.printer.read authorizations, but not the solaris.login.enable authorization.
If the administrator has both the grant authorization, solaris.admin.printmgr.grant, and the wildcard authorization,
solaris.admin.printmgr.*, the administrator can grant to others any of the printer authorizations. See user_attr(4)
for more information about how wildcards can be used to assign multiple authorizations whose names begin with the
same components.
Example 5 Authorizing the Ability to Assign Other Authorizations
The following entry defines an authorization that grants the ability to assign any authorization created with a solaris
prefix, when the administrator also has either the specific authorization being granted or a matching wildcard entry:
 solaris.grant:::Grant All Solaris Authorizations::help=PriAdmin.html
Example 6 Consulting the Local Authorization File Ahead of the NIS Table
With the following entry from /etc/nsswitch.conf, the local auth_attr file is consulted before the NIS table:
 auth_attr:files nisplus
/etc/nsswitch.conf
/etc/user_attr
/etc/security/auth_attr
getauthattr(3SECDB), getexecattr(3SECDB), getprofattr(3SECDB), getuserattr(3SECDB), exec_attr(4), nss<hy>
witch.conf(4), user_attr(4)
When deciding which authorization source to use, keep in mind that NIS+ provides stronger authentication than
NIS.
<beginning of page>
Because the list of legal keys is likely to expand, any code that parses this database must be written to ignore un<hy>
known key-value pairs without error. When any new keywords are created, the names should be prefixed with a
unique string, such as the company's stock symbol, to avoid potential naming conflicts.
Each application has its own requirements for whether the help value must be a relative pathname ending with a file<hy>
name or the name of a file. The only known requirement is for the name of a file.
The following characters are used in describing the database format and must be escaped with a backslash if used as
data: colon (:), semicolon (;), equals (=), and backslash (\).
au_to.3bsm <beginning of page>
au_to, au_to_arg, au_to_arg32, au_to_arg64, au_to_attr, au_to_cmd, au_to_data, au_to_groups, au_to_in_addr,
au_to_ipc, au_to_iport, au_to_me, au_to_newgroups, au_to_opaque, au_to_path, au_to_process, au_to_process_ex,
au_to_return, au_to_return32, au_to_return64, au_to_socket, au_to_subject, au_to_subject_ex, au_to_text <-> create
audit record tokens
cc [ flag... ] file... -lbsm -lsocket -lnsl [ library... ]
#include <sys/types.h>
#include <sys/vnode.h>
#include <netinet/in.h>
#include <bsm/libbsm.h>
token_t *au_to_arg(char n, char *text, uint32_t v);
token_t *au_to_arg32(char n, char *text, uint32_t v);
token_t *au_to_arg64(char n, char *text, uint64_t v);
token_t *au_to_attr(struct vattr *attr);
token_t *au_to_cmd(uint_t argc, char **argv, char **envp);
token_t *au_to_data(char unit_print, char unit_type, char unit_count,
 char *p);
token_t *au_to_groups(int *groups);
token_t *au_to_in_addr(struct in_addr *internet_addr);
token_t *au_to_ipc(char type, int id);
token_t *au_to_iport(u_short_t iport);
token_t *au_to_me(void);
token_t *au_to_newgroups(int n, gid_t *groups);
token_t *au_to_opaque(char *data, short bytes);
token_t *au_to_path(char *path);
token_t *au_to_process(au_id_t auid, uid_t euid, gid_t egid,
 uid_t ruid, gid_t rgid, pid_t pid, au_asid_t sid, au_tid_t *tid);
token_t *au_to_process_ex(au_id_t auid, uid_t euid, gid_t egid,
 uid_t ruid, gid_t rgid, pid_t pid, au_asid_t sid, au_tid_addr_t *tid);
token_t *au_to_return(char number, uin32t_t value);
token_t *au_to_return32(char number, uin32t_t value);
token_t *au_to_return64(char number, uin64t_t value);
token_t *au_to_socket(struct oldsocket *so);
token_t *au_to_subject(au_id_t auid, uid_t euid, gid_t egid,
 uid_t ruid, gid_t rgid, pid_t pid, au_asid_t sid, au_tid_t *tid);
token_t *au_to_subject_ex(au_id_t auid, uid_t euid, gid_t egid,
 uid_t ruid, gid_t rgid, pid_t pid, au_asid_t sid, au_tid_addr_t *tid);
token_t *au_to_text(char *text);
The au_to_arg(), au_to_arg32(), and au_to_arg64() functions format the data in v into an "argument token". The n
argument indicates the argument number. The text argument is a null-terminated string describing the argument.
The au_to_attr() function formats the data pointed to by attr into a "vnode attribute token".
<beginning of page>
The au_to_cmd() function formats the data pointed to by argv into a "command token". A command token reflects a
command and its parameters as entered. For example, the pfexec(1) utility uses au_to_cmd() to record the com<hy>
mand and arguments it reads from the command line.
The au_to_data() function formats the data pointed to by p into an "arbitrary data token". The unit_print parameter
determines the preferred display base of the data and is one of AUP_BINARY, AUP_OCTAL, AUP_DECIMAL,
AUP_HEX, or AUP_STRING. The unit_type parameter defines the basic unit of data and is one of AUR_BYTE,
AUR_CHAR, AUR_SHORT, AUR_INT, or AUR_LONG. The unit_count parameter specifies the number of ba<hy>
sic data units to be used and must be positive.
The au_to_groups() function formats the array of 16 integers pointed to by groups into a "groups token". The
au_to_newgroups() function (see below) should be used in place of this function.
The au_to_in_addr() function formats the data pointed to by internet_addr into an "internet address token".
The au_to_ipc() function formats the data in the id parameter into an "interprocess communications ID token".
The au_to_iport() function formats the data pointed to by iport into an "ip port address token".
The au_to_me() function collects audit information from the current process and creates a "subject token" by call<hy>
ing au_to_subject().
The au_to_newgroups() function formats the array of n integers pointed to by groups into a "newgroups token".
This function should be used in place of au_to_groups().
The au_to_opaque() function formats the bytes bytes pointed to by data into an "opaque token". The value of size
must be positive.
The au_to_path() function formats the path name pointed to by path into a ``path token.''
The au_to_process() function formats an auid (audit user ID), an euid (effective user ID), an egid (effective group
ID), a ruid (real user ID), a rgid (real group ID), a pid (process ID), an sid (audit session ID), and a tid (audit termi<hy>
nal ID containing an IPv4 IP address), into a "process token". A process token should be used when the process is
the object of an action (ie. when the process is the receiver of a signal). The au_to_process_ex() function (see be<hy>
low) should be used in place of this function.
The au_to_process_ex() function formats an auid (audit user ID), an euid (effective user ID), an egid (effective
group ID), a ruid (real user ID), a rgid (real group ID), a pid (process ID), an sid (audit session ID), and a tid (audit
terminal ID containing an IPv4 or IPv6 IP address), into a "process token". A process token should be used when
the process is the object of an action (that is, when the process is the receiver of a signal). This function should be
used in place of au_to_process().
The au_to_return(), au_to_return32(), and au_to_return64() functions format an error number number and a re<hy>
turn value value into a "return value token".
The au_to_socket() function format the data pointed to by so into a ``socket token.''
The au_to_subject() function formats an auid (audit user ID), an euid (effective user ID), an egid (effective group
ID), a ruid (real user ID), an rgid (real group ID), a pid (process ID), an sid (audit session ID), an tid (audit terminal
ID containing an IPv4 IP address), into a "subject token". The au_to_subject_ex() function (see below) should be
used in place of this function.
The au_to_subject_ex() function formats an auid (audit user ID), an euid (effective user ID), an egid (effective
group ID), a ruid (real user ID), an rgid (real group ID), a pid (process ID), an sid (audit session ID), an tid (audit
terminal ID containing an IPv4 or IPv6 IP address), into a "subject token". This function should be used in place
of au_to_subject().
The au_to_text() function formats the null-terminated string pointed to by text into a "text token".
These functions return NULL if memory cannot be allocated to put the resultant token into, or if an error in the input
is detected.
See attributes(5) for a description of the following attributes:
<beginning of page>
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
bsmconv(1M), au_open(3BSM), attributes(5)
The functionality described on this manual page is available only if the Solaris Auditing has been enabled. See
bsmconv(1M) for more information.
auto_ef.3ext <beginning of page>
auto_ef, auto_ef_file, auto_ef_str, auto_ef_free, auto_ef_get_encoding, auto_ef_get_score <-> auto encoding finder
functions
cc [ flag ... ] file... -lauto_ef [ library... ]
#include <auto_ef.h>
size_t auto_ef_file(auto_ef_t **info, const char *filename, int flags);
size_t auto_ef_str(auto_ef_t **info, const char *buffer, size_t bufsize,
 int flags);
void auto_ef_free(auto_ef_t *info);
char *auto_ef_get_encoding(auto_ef_t info);
double auto_ef_get_score(auto_ef_t info);
Auto encoding finder provides functions that find the encoding of given file or string.
The auto_ef_file() function examines text in the file specified with filename and returns information on possible en<hy>
codings.
The info argument is a pointer to a pointer to an auto_ef_t, the location at which the pointer to the auto_ef_t array is
stored upon return.
The flags argument specifies the level of examination. Currently only one set of flags, exclusive each other, is avail<hy>
able: AE_LEVEL_0, AE_LEVEL_1, AE_LEVEL_2, and AE_LEVEL_3. The AE_LEVEL_0 level is fastest but
the result can be less accurate. The AE_LEVEL_3 level produces best result but can be slow. If the flags argument
is unspecified, the default is AE_LEVEL_0. When another flag or set of flags are defined in the future, use the in<hy>
clusive-bitwise OR operation to specify multiple flags.
Information about encodings are stored in data typeauto_ef_t in the order of possibility with the most possible en<hy>
coding stored first. To examine the information, use the auto_ef_get_encoding() and auto_ef_get_score() access
functions. For a list of encodings with which auto_ef_file() can examine text, see auto_ef(1).
If auto_ef_file() cannot determine the encoding of text, it returns 0 and stores NULL at the location pointed by info.
The auto_ef_get_encoding() function returns the name of the encoding. The returned string is vaild until until the
location pointed to by info is freed with auto_ef_free(). Applications should not use free(3C) to free the pointer re<hy>
turned by auto_ef_get_encoding().
The auto_ef_get_score() function returns the score of this encoding in the range between 0.0 and 1.0.
The auto_ef_str() function is identical to auto_ef_file(), except that it examines text in the buffer specified by buffer
with a maximum size of bufsize bytes, instead of text in a file.
The auto_ef_free() function frees the area allocated by auto_ef_file() or by auto_ef_str(), taking as its argument the
pointer stored at the location pointed to by info.
Upon successful completion, the auto_ef_file() and auto_ef_str() functions return the number of possible encodings
for which information is stored. Otherwise, <mi>1 is returned.
The auto_ef_get_encoding() function returns the string that stores the encoding name.
the auto_ef_get_score() function returns the score value for encoding the name with the examined text data.
The auto_ef_file() and auto_ef_str() will fail if:
EACCES Search permission is denied on a component of the path prefix, the file exists and the permissions speci<hy>
fied by mode are denied, the file does not exist and write permission is denied for the parent directory of the file to
be created, or libauto_ef cannot find the internal hashtable.
EINTR A signal was caught during the execution.
<beginning of page>
ENOMEM Failed to allocate area to store the result.
EMFILE Too many files descriptors are currently open in the calling process.
ENFILE Too many files are currently open in the system.
Example 1 Specify the array index to examine stored information.
Since auto_ef_file() stores the array whose elements hold information on each possible encoding, the following ex<hy>
ample specifies the array index to examine the stored information.
 #include <auto_ef.h>
 auto_ef_t *array_info;
 size_t number;
 char *encoding;
 number = auto_ef_file(&array_info, filename, flags);
 encoding = auto_ef_get_encoding(array_info[0]);
 auto_ef_free(array_info);
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stabili<hy>
tyStable _ MT-LevelMT-Safe
auto_ef(1), libauto_ef(3LIB), attributes(5)
automount.1m <beginning of page>
automount <-> install automatic mount points
/usr/sbin/automount [-t duration] [-v]
The automount utility installs autofs mount points and associates an automount map with each mount point. It
starts the automountd(1M) daemon if it finds any non-trivial entries in either local or distributed automount maps
and if the daemon is not already running. The autofs file system monitors attempts to access directories within it and
notifies the automountd(1M) daemon. The daemon uses the map to locate a file system, which it then mounts at the
point of reference within the autofs file system. A map can be assigned to an autofs mount using an entry in the
/etc/auto_master map or a direct map.
If the file system is not accessed within an appropriate interval (10 minutes by default), the automountd daemon un<hy>
mounts the file system.
The file /etc/auto_master determines the locations of all autofs mount points. By default, this file contains three en<hy>
tries:
 # Master map for automounter
 #
 +auto_master
 /net -hosts -nosuid
 /home auto_home
The +auto_master entry is a reference to an external NIS or NIS+ master map. If one exists, then its entries are read
as if they occurred in place of the +auto_master entry. The remaining entries in the master file specify a directory
on which an autofs mount will be made followed by the automounter map to be associated with it. Optional mount
options may be supplied as an optional third field in the each entry. These options are used for any entries in the map
that do not specify mount options explicitly. The automount command is usually run without arguments. It com<hy>
pares the entries /etc/auto_master with the current list of autofs mounts in /etc/mnttab and adds, removes or up<hy>
dates autofs mounts to bring the /etc/mnttab up to date with the /etc/auto_master. At boot time it installs all autofs
mounts from the master map. Subsequently, it may be run to install autofs mounts for new entries in the master map
or the direct map, or to perform unmounts for entries that have been removed from these maps.
If a system is configured with Solaris Trusted Extensions, additional processing is performed to facilitate multilevel
home directory access. A list of zones whose labels are dominated by the current zone is generated and default au<hy>
to_home automount maps are generated if they do not currently exist. These automount maps are named au<hy>
to_home_<zonename>, where <zonename> is the name of each zone's lower-level zone. An autofs mount of each
such auto_home map is then performed, regardless of whether it is explicitly or implicitly listed in the master map.
Instead of autofs mounting the standard auto_home map, the zone uses an auto_home file appended with its own
zone name. Each zone's auto_home map is uniquely named so that it can be maintained and shared by all zones us<hy>
ing a common name server.
By default, the home directories of lower-level zones are mounted read-only under /zone/<zonename>/export/home
when each zone is booted. The default auto_home_<zonename> automount map specifies that path as the source
directory for an lofs remount onto /zone/<zonename>/home/<username>. For example, the file auto_home_pub<hy>
lic, as generated from a higher level zone would contain:
+auto_home_public
* -fstype=lofs :/zone/public/export/home/&
When a home directory is referenced and the name does not match any other keys in the auto_home_public map, it
will match this loopback mount specification. If this loopback match occurs and the name corresponds to a valid us<hy>
er whose home directory does not exist in the public zone, the directory is automatically created on behalf of the us<hy>
er.
The following options are supported:
-t duration Specifies a duration, in seconds, that a file system is to remain mounted when not in use. The default is
10 minutes.
-v Verbose mode. Notifies of autofs mounts, unmounts, or other non-essential information.
<beginning of page>
A simple map entry (mapping) takes the form:
 key [ -mount-options ] location ...
where key is the full pathname of the directory to mount when used in a direct map, or the simple name of a subdi<hy>
rectory in an indirect map. mount-options is a comma-separated list of mount options, and location specifies a file
system from which the directory may be mounted. In the case of a simple NFS mount, the options that can be used
are as specified in mount_nfs(1M), and location takes the form:
 host:pathname
host is the name of the host from which to mount the file system, and pathname is the absolute pathname of the di<hy>
rectory to mount.
Options to other file systems are documented on the other mount_* reference manual pages, for example,
mount_cachefs(1M).
Multiple location fields can be specified for replicated NFS file systems, in which case automount and the kernel
will each try to use that information to increase availability. If the read-only flag is set in the map entry, automountd
mounts a list of locations that the kernel may use, sorted by several criteria. Only locations available at mount time
will be mounted, and thus be available to the kernel. When a server does not respond, the kernel will switch to an al<hy>
ternate server. The sort ordering of automount is used to determine how the next server is chosen. If the read-only
flag is not set, automount will mount the best single location, chosen by the same sort ordering, and new servers
will only be chosen when an unmount has been possible, and a remount is done. Servers on the same local subnet
are given the strongest preference, and servers on the local net are given the second strongest preference. Among
servers equally far away, response times will determine the order if no weighting factors (see below) are used.
If the list includes server locations using both the NFS Version 2 Protocol and the NFS Version 3 Protocol, auto<hy>
mount will choose only a subset of the server locations on the list, so that all entries will be the same protocol. It
will choose servers with the NFS Version 3 Protocol so long as an NFS Version 2 Protocol server on a local subnet
will not be ignored. See the for additional details.
If each location in the list shares the same pathname then a single location may be used with a comma-separated list
of hostnames:
 hostname,hostname...:pathname
Requests for a server may be weighted, with the weighting factor appended to the server name as an integer in
parentheses. Servers without a weighting are assumed to have a value of zero (most likely to be selected). Progres<hy>
sively higher values decrease the chance of being selected. In the example,
 man -ro alpha,bravo,charlie(1),delta(4):/usr/man
hosts alpha and bravo have the highest priority; host delta has the lowest.
Server proximity takes priority in the selection process. In the example above, if the server delta is on the same net<hy>
work segment as the client, but the others are on different network segments, then delta will be selected; the weight<hy>
ing value is ignored. The weighting has effect only when selecting between servers with the same network proximi<hy>
ty. The automounter always selects the localhost over other servers on the same network segment, regardless of
weighting.
In cases where each server has a different export point, the weighting can still be applied. For example:
 man -ro alpha:/usr/man bravo,charlie(1):/usr/share/man
  delta(3):/export/man
<beginning of page>
A mapping can be continued across input lines by escaping the NEWLINE with a backslash (\) Comments begin
with a number sign (#) and end at the subsequent NEWLINE.
The ampersand (&) character is expanded to the value of the key field for the entry in which it occurs. In this case:
 jane sparcserver:/home/&
the & expands to jane.
The asterisk (*) character, when supplied as the key field, is recognized as the catch-all entry. Such an entry will
match any key not previously matched. For instance, if the following entry appeared in the indirect map for /config:
 * &:/export/config/&
this would allow automatic mounts in /config of any remote file system whose location could be specified as:
 hostname:/export/config/hostname
Note that the wildcard key does not work in conjunction with the -browse option.
Client specific variables can be used within an automount map. For instance, if $HOST appeared within a map, au<hy>
tomount would expand it to its current value for the client's host name. Supported variables are:
tab(); lw(1.07i) lw(2.6i) lw(1.83i) lw(1.07i) lw(2.6i) lw(1.83i) ARCHThe output of archT{ The architecture name.
For example, sun4 on a sun4u machine. T} CPUThe output of uname -pThe processor type. For example, "sparc"
HOSTThe output of uname -nThe host name. For example, myhost. KARCHThe output of arch -k or uname
-mT{ The kernel architecture name or machine hardware name. For example, sun4u. T} OSNAMEThe output of
uname -sThe OS name. For example, "SunOS" OSRELThe output of uname -rThe OS release name. For example
"5.3" OSVERSThe output of uname -vThe OS version. For example, "beta1.0" NATISAThe output of isainfo
-nT{ The native instruction set architecture for the system. T} For example, "sparcv9" PLATFORMThe output of
uname -iT{ The platform name. For example, SUNW,Sun-Fire-V240. T}
If a reference needs to be protected from affixed characters, you can surround the variable name with curly braces
({}).
A multiple mount entry takes the form:
 key [-mount-options] [[mountpoint] [-mount-options] location...]...
The initial /[mountpoint] is optional for the first mount and mandatory for all subsequent mounts. The optional
mountpoint is taken as a pathname relative to the directory named by key. If mountpoint is omitted in the first occur<hy>
rence, a mountpoint of / (root) is implied.
Given an entry in the indirect map for /src
 beta -ro\
  / svr1,svr2:/export/src/beta \
  /1.0 svr1,svr2:/export/src/beta/1.0 \
  /1.0/man svr1,svr2:/export/src/beta/1.0/man
All offsets must exist on the server under beta. automount will automatically mount /src/beta, /src/beta/1.0, and
/src/beta/1.0/man, as needed, from either svr1 or svr2, whichever host is nearest and responds first.
<beginning of page>
The automounter assumes NFS mounts as a default file system type. Other file system types can be described using
the fstype mount option. Other mount options specific to this file system type can be combined with the fstype op<hy>
tion. The location field must contain information specific to the file system type. If the location field begins with a
slash, a colon character must be prepended, for instance, to mount a CD file system:
 cdrom -fstype=hsfs,ro :/dev/sr0
or to perform an autofs mount:
 src -fstype=autofs auto_src
Use this procedure only if you are not using Volume Manager.
Mounts using CacheFS are most useful when applied to an entire map as map defaults. The following entry in the
master map describes cached home directory mounts. It assumes the default location of the cache directory, /cache.
 /home auto_home -fstype =cachefs,backfstype=nfs
See the NOTES section for information on option inheritance.
An indirect map allows you to specify mappings for the subdirectories you wish to mount under the directory indi<hy>
cated on the command line. In an indirect map, each key consists of a simple name that refers to one or more file
systems that are to be mounted as needed.
Entries in a direct map are associated directly with autofs mount points. Each key is the full pathname of an autofs
mount point. The direct map as a whole is not associated with any single directory.
Direct maps are distinguished from indirect maps by the /- key. For example:
 # Master map for automounter
 #
 +auto_master
 /net -hosts -nosuid,nobrowse
 /home auto_home -nobrowse
 /- auto_direct
The contents of another map can be included within a map with an entry of the form
 +mapname
If mapname begins with a slash, it is assumed to be the pathname of a local file. Otherwise, the location of the map
is determined by the policy of the name service switch according to the entry for the automounter in /etc/nss<hy>
witch.conf, such as
 automount: files nis
If the name service is files, then the name is assumed to be that of a local file in /etc. If the key being searched for is
not found in the included map, the search continues with the next entry.
There are two special maps available: -hosts and -null. The -hosts map is used with the /net directory and assumes
that the map key is the hostname of an NFS server. The automountd daemon dynamically constructs a map entry
from the server's list of exported file systems. References to a directory under /net/hermes will refer to the corre<hy>
sponding directory relative to hermes root.
<beginning of page>
The -null map cancels a previous map for the directory indicated. This is most useful in the /etc/auto_master for
cancelling entries that would otherwise be inherited from the +auto_master include entry. To be effective, the -null
entries must be inserted before the included map entry.
Local maps that have the execute bit set in their file permissions will be executed by the automounter and provided
with a key to be looked up as an argument. The executable map is expected to return the content of an automounter
map entry on its stdout or no output if the entry cannot be determined. A direct map cannot be made executable.
When initiated without arguments, automount consults the master map for a list of autofs mount points and their
maps. It mounts any autofs mounts that are not already mounted, and unmounts autofs mounts that have been re<hy>
moved from the master map or direct map.
The master map is assumed to be called auto_master and its location is determined by the name service switch poli<hy>
cy. Normally the master map is located initially as a local file /etc/auto_master.
The automount daemon supports browsability of indirect maps. This allows all of the potential mount points to be
visible, whether or not they are mounted. The -nobrowse option can be added to any indirect autofs map to disable
browsing. For example:
 /net -hosts -nosuid,nobrowse
 /home auto_home
In this case, any hostnames would only be visible in /net after they are mounted, but all potential mount points
would be visible under /home. The -browse option enables browsability of autofs file systems. This is the default
for all indirect maps.
The -browse option does not work in conjunction with the wildcard key.
Options specified for a map are used as the default options for all the entries in that map. They are ignored when
map entries specify their own mount options.
In some cases, however, it is desirable to force nosuid, nodevices, nosetuid, or noexec for a complete mount map
and its submounts. This can be done by specifying the additional mount option, -restrict.
  /home auto_home -restrict,nosuid,hard
The -restrict option forces the inheritance of all the restrictive options nosuid, nodevices, nosetuid, and noexec as
well as the restrict option itself. In this particular example, the nosuid and restrict option are inherited but the hard
option is not. The restrict option also prevents the execution of "executable maps" and is enforced for auto mounts
established by programs with fewer than all privileges available in their zone.
The following exit values are returned:
0 Successful completion.
1 An error occurred.
/etc/auto_master Master automount map.
/etc/auto_home Map to support automounted home directories.
/etc/default/autofs Supplies default values for parameters for automount and automountd. See autofs(4).
/etc/nsswitch.conf Name service switch configuration file. See nsswitch.conf(4).
<beginning of page>
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
isainfo(1), ls(1), svcs(1), uname(1), automountd(1M), mount(1M), mount_cachefs( 1M), mount_nfs(1M), sv<hy>
cadm(1M), autofs(4), attributes(5), nfssec(5), smf(5)

autofs mount points must not be hierarchically related. automount does not allow an autofs mount point to be cre<hy>
ated within another autofs mount.
Since each direct map entry results in a new autofs mount such maps should be kept short.
Entries in both direct and indirect maps can be modified at any time. The new information is used when auto<hy>
mountd next uses the map entry to do a mount.
New entries added to a master map or direct map will not be useful until the automount command is run to install
them as new autofs mount points. New entries added to an indirect map may be used immediately.
As of the Solaris 2.6 release, a listing (see ls(1)) of the autofs directory associated with an indirect map shows all
potential mountable entries. The attributes associated with the potential mountable entries are temporary. The real
file system attributes will only be shown once the file system has been mounted.
Default mount options can be assigned to an entire map when specified as an optional third field in the master map.
These options apply only to map entries that have no mount options. Note that map entities with options override the
default options, as at this time, the options do not concatenate. The concatenation feature is planned for a future re<hy>
lease.
When operating on a map that invokes an NFS mount, the default number of retries for the automounter is 0, that is,
a single mount attempt, with no retries. Note that this is significantly different from the default (10000) for the
mount_nfs(1M) utility.
The Network Information Service (NIS) was formerly known as Sun Yellow Pages (YP). The functionality of the
two remains the same.
The automount service is managed by the service management facility, smf(5), under the service identifier:
 svc:/system/filesystem/autofs:default
Administrative actions on this service, such as enabling, disabling, or requesting restart, can be performed using sv<hy>
cadm(1M). The service's status can be queried using the svcs(1) command.
autopush.1m <beginning of page>
autopush <-> configures lists of automatically pushed STREAMS modules
autopush -f filename
autopush -g -M major -m minor
autopush -r -M major -m minor
The autopush command configures the list of modules to be automatically pushed onto the stream when a device is
opened. It can also be used to remove a previous setting or get information on a setting.
The following options are supported:
-f filename
Sets up the autopush configuration for each driver according to the information stored in filename. An autopush file
consists of lines of four or more fields, separated by spaces as shown below:
 major minor last-minor module1 module2 ... module8
The first field is a string that specifies the major device name, as listed in the /kernel/drv directory. The next two
fields are integers that specify the minor device number and last-minor device number. The fields following repre<hy>
sent the names of modules. If minor is <mi>1, then all minor devices of a major driver specified by major are config<hy>
ured, and the value for last-minor is ignored. If last-minor is 0, then only a single minor device is configured. To
configure a range of minor devices for a particular major, minor must be less than last-minor.
The remaining fields list the names of modules to be automatically pushed onto the stream when opened, along with
the position of an optional anchor. The maximum number of modules that can be pushed is eight. The modules are
pushed in the order they are specified. The optional special character sequence [anchor] indicates that a STREAMS
anchor should be placed on the stream at the module previously specified in the list; it is an error to specify more
than one anchor or to have an anchor first in the list.
A nonzero exit status indicates that one or more of the lines in the specified file failed to complete successfully.
-g
Gets the current configuration setting of a particular major and minor device number specified with the -M and -m
options respectively and displays the autopush modules associated with it. It will also return the starting minor de<hy>
vice number if the request corresponds to a setting of a range (as described with the -f option).
-m minor
Specifies the minor device number.
-M major
Specifies the major device number.
-r
Removes the previous configuration setting of the particular major and minor device number specified with the -M
and -m options respectively. If the values of major and minor correspond to a previously established setting of a
range of minor devices, where minor matches the first minor device number in the range, the configuration would be
removed for the entire range.
The following exit values are returned:
0
Successful completion.
<beginning of page>
non-zero
An error occurred.
Example 1 Using the autopush command.
The following example gets the current configuration settings for the major and minor device numbers as indicated
and displays the autopush modules associated with them for the character-special device /dev/term/a:
 example# autopush -g -M 29 -m 0
 Major Minor Lastminor Modules
  29 0 1 ldterm ttcompat
/etc/iu.ap
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu
dladm(1M), ttymon(1M), attributes(5), ldterm(7M), sad(7D), streamio(7I), ttcompat(7M)

The use of the autopush command is obsolete for networking data-links. The preferred method of configuring a list
of automatically pushed STREAMS modules on a given networking data-link interface is the dladm(1M) autopush
link property.
Because network devices are self-cloning, the autopush command is inadequate for networking devices. The granu<hy>
larity of the autopush command's configuration is driver-wide, and not per-interface as one might expect. Another
reason not to use autopush is that administrators are more familiar with the names of their network interfaces than
with device major and minor numbers. The dladm(1M) command allows the configuration using data-link interface
names.
av1394.7d <beginning of page>
av1394 <-> 1394 audio/video driver
unit@GUID
The av1394 driver implements iec61883(7I) interfaces for IEEE 1394 compliant devices.
The driver allows applications to act as FCP controllers, but not FCP targets. Only IEC61883_FCP_CMD requests
can be sent with write(2). Only IEC61883_FCP_RESP requests can be received with read(2).
When the read/write method of is used for transmit, the driver is capable of auto-detecting and transmitting SD-
DVCR 525/60 and 625/50 streams. See iec61883(7I) for details.
/dev/av/N/async device node for asynchronous data
/dev/av/N/isoch device node for isochronous data
kernel/drv/sparcv9/av1394 64-bit ELF kernel module
kernel/drv/av1394 32-bit ELF kernel module
kernel/drv/amd64/av1394 64-bit ELF kernel module
See attributes(5) for a description of the following attributes:
tab() box; lw(2.75i) |lw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureAll _
Interface StabilityCommitted
read(2), write(2), attributes(5), hci1394(7D), iec61883(7I)
IEEE Std 1394-1995 Standard for a High Performance Serial Bus
IEC 61883 Consumer audio/video equipment - Digital interface
awrite.9e <beginning of page>
awrite <-> asynchronous write to a device
#include <sys/uio.h>
#include <sys/aio_req.h>
#include <sys/cred.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
intprefixawrite(dev_t dev, struct aio_req *aio_reqp,
 cred_t *cred_p);
Solaris DDI specific (Solaris DDI). This entry point is optional. Drivers that do not support an awrite() entry point
should use nodev(9F)
dev Device number.
aio_reqp Pointer to the aio_req(9S) structure that describes where the data is stored.
cred_p Pointer to the credential structure.
The driver's awrite() routine is called to perform an asynchronous write. getminor(9F) can be used to access the
minor number component of the dev argument. awrite() may use the credential structure pointed to by cred_p to
check for superuser access by calling drv_priv(9F). The awrite() routine may also examine the uio(9S) structure
through the aio_req structure pointer, aio_reqp. awrite() must call aphysio(9F) with the aio_req pointer and a
pointer to the driver's strategy(9E) routine.
No fields of the uio(9S) structure pointed to by aio_req, other than uio_offset or uio_loffset, may be modified for
non-seekable devices.
The awrite() routine should return 0 for success, or the appropriate error number.
This function is called from user context only. Example 1 Using the awrite() routine:
The following is an example of an awrite() routine:
 static int
 xxawrite(dev_t dev, struct aio_req *aio, cred_t *cred_p)
 {
  int instance;
  struct xxstate *xsp;
  instance = getminor(dev);
  xsp = ddi_get_soft_state(statep, instance);
  /*Verify soft state structure has been allocated */
  if (xsp == NULL)
  return (ENXIO);
  return (aphysio(xxstrategy, anocancel, dev, B_WRITE, \
  xxminphys, aio));
 }
write(2), aiowrite(3C), aread(9E), read(9E), strategy(9E), write(9E), anocancel(9F), aphysio(9F),
ddi_get_soft_state(9F), drv_priv(9F), getminor(9F), minphys(9F), nodev(9F), aio_req(9S), cb_ops(9S), uio(9S)
Writing Device Drivers
There is no way other than calling aphysio(9F) to accomplish an asynchronous write.
banner.1 <beginning of page>
banner <-> make posters
banner strings
banner prints its arguments (each up to 10 characters long) in large letters on the standard output.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wesu
echo(1), attributes(5)
bart_manifest.4 <beginning of page>
bart_manifest <-> system audit manifest file
The bart(1M) command generates a manifest that describes the contents of a managed host. A manifest consists of a
header and entries. Each entry represents a single file. Entries are sorted in ascending order by file name. Any non<hy>
standard file names, such as those that contain embedded newline or tab characters, have the special characters quot<hy>
ed prior to being sorted. See Quoting Syntax.
Lines that begin with ! supply metadata about the manifest. The manifest version line indicates the manifest specifi<hy>
cation version. The date line shows the date on which the manifest was created, in date(1) form.
Some lines are ignored by the manifest comparison tool. Ignored lines include blank lines, lines that consist only of
white space, and comments that begin with #.
In addition to metadata lines, the header contains the format comment block. This comment block lists the attributes
reported for each file type.
To see the format of a manifest file, see EXAMPLES.
Each manifest file entry is a single line of one of the following forms, depending on the file type:
 fname D size mode acl dirmtime uid gid
 fname P size mode acl mtime uid gid
 fname S size mode acl mtime uid gid
 fname F size mode acl mtime uid gid contents
 fname L size mode acl lnmtime uid gid dest
 fname B size mode acl mtime uid gid devnode
 fname C size mode acl mtime uid gid devnode
The fields of the manifest file entries are described as follows:
fname Name of the file. To prevent parsing problems that are caused by special characters embedded in file names,
file names are encoded as described in Quoting Syntax.
type Type of file.
Possible values for type are as follows:
B Block device node
C Character device node
D Directory
F File
L Symbolic link
P Pipe
S Socket
size File size in bytes.
mode Octal number that represents the permissions of the file.
<beginning of page>
acl ACL attributes for the file. For a file with ACL attributes, this field contains the output from acltotext().
uid Numerical user ID of the owner of this entry.
gid Numerical group ID of the owner of this entry.
dirmtime Modification time in seconds since 00:00:00 UTC, January 1, 1970 for directories.
lnmtime Creation time for links.
mtime Modification time in seconds since 00:00:00 UTC, January 1, 1970 for files.
contents Checksum value of the file. This attribute is only specified for regular files. If you turn off context checking
or if checksums cannot be computed, the value of this field is -.
dest Destination of a symbolic link.
devnode Value of the device node. This attribute is for character device files and block device files only.
The rules file supports a quoting syntax for representing nonstandard file names.
When generating a manifest for file names that embeded TAB, SPACE, or NEWLINE characters, the special charac<hy>
ters are encoded in their octal forms.
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) Input CharacterQuoted Character _ SPACE\SPACE _ TAB\TAB
_ NEWLINE\NEWLINE _ ?\? _ [\[ _ *\*
Example 1 Sample Manifest File
The following is a sample system manifest file. The file entries are sorted by the encoded versions of the file names
to correctly handle special characters.
 ! Version 1.0
 ! Mon Feb 11 10:55:30 2002
 # Format:
 # fname D size mode acl dirmtime uid gid
 # fname P size mode acl mtime uid gid
 # fname S size mode acl mtime uid gid
 # fname F size mode acl mtime uid gid contents
 # fname L size mode acl lnmtime uid gid dest
 # fname B size mode acl mtime uid gid devnode
 # fname C size mode acl mtime uid gid devnode
 /etc D 3584 40755 user::rwx,group::r-x,mask::r-x,other::r-x,
  3c6803d7 0 3
 /etc/.login F 524 100644 user::rw-,group::r--,mask::r--,other::r--,
  3c165878 0 3 27b53d5c3e844af3306f1f12b330b318
 /etc/.pwd.lock F 0 100600 user::rw-,group::---,mask::---,other::---,
  3c166121 0 0 d41d8cd98f00b204e9800998ecf8427e
 /etc/.syslog_door L 20 120777 user::rw-,group::r--,mask::
  rwx,other::r--,3c6803d5 0 0 /var/run/syslog_door
 /etc/autopush L 16 120777 user::r-x,group::r-x,mask::r-x,other::r-x,
  3c165863 0 0 ../sbin/autopush
 /etc/cron.d/FIFO P 0 10600 user::rw-,group::---,mask::---,other::---,
<beginning of page>
  3c6803d5 0 0
date(1), bart(1M), bart_rules(4), attributes(5)
basename.1b <beginning of page>
basename <-> display portions of pathnames
/usr/ucb/basename string [suffix]
The basename utility deletes any prefix ending in `/' and the suffix, if present in string. It directs the result to the
standard output, and is normally used inside substitution marks (` `) within shell procedures. The suffix is a string
with no special significance attached to any of the characters it contains. Example 1 Using the basename com<hy>
mand.
This shell procedure invoked with the argument /usr/src/bin/cat.c compiles the named file and moves the output to
cat in the current directory:
 example% cc $1
 example% mv a.out `basename $1 .c`
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wscpu
sh(1), attributes(5)
basename.3c <beginning of page>
basename <-> return the last element of a path name
#include <libgen.h>
char *basename(char *path);
The basename() function takes the pathname pointed to by path and returns a pointer to the final component of the
pathname, deleting any trailing '/' characters.
If the string consists entirely of the '/' character, basename() returns a pointer to the string "/" .
If path is a null pointer or points to an empty string, basename() returns a pointer to the string "." .
The basename() function returns a pointer to the final component of path.
The basename() function may modify the string pointed to by path, and may return a pointer to static storage that
may then be overwritten by a subsequent call to basename().
When compiling multithreaded applications, the _REENTRANT flag must be defined on the compile line. This
flag should only be used in multithreaded applications. Example 1 Examples for Input String and Output String
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) Input StringOutput String _ "/usr/lib""lib" _ "/usr/""usr" _
"/""/"
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
basename(1), dirname(3C), attributes(5), standards(5)
bbc_beep.7d <beginning of page>
bbc_beep <-> Platform-dependent Beep driver for BBC-based hardware.
beep@unit-address
The bbc_beep driver generates beeps on platforms (including Sun Blade 1000) that use BBC-based registers and
USB keyboards. When the KIOCCMD ioctl is issued to the USB keyboard module (see usbkbm(7M)) with com<hy>
mand KBD_CMD_BELL/KBD_CMD_NOBELL, usbkbm(7M) passes the request to the bbc_beep driver to turn
the beep on and off, respectively.
/platform/sun4u/kernel/drv/sparcv9/bbc_beep
 64-bit ELF kernel driver
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureBBC-
based SPARC _ AvailabilitySUNWcarx.u
kbd(1), attributes(5), grbeep(7d), kb(7M), usbkbm(7M)
Writing Device Drivers
None
bcanput.9f <beginning of page>
bcanput <-> test for flow control in specified priority band
#include <sys/stream.h>
int bcanput(queue_t *q, unsigned char pri);
Architecture independent level 1 (DDI/DKI).
q Pointer to the message queue.
pri Message priority.
The bcanput() function searches through the stream (starting at q) until it finds a queue containing a service routine
where the message can be enqueued, or until it reaches the end of the stream. If found, the queue containing the ser<hy>
vice routine is tested to see if there is room for a message of priority pri in the queue.
If pri is 0, bcanput() is equivalent to a call with canput(9F).
canputnext(q) and bcanputnext(q,pri) should always be used in preference to canput(q<->>q_next) and bcan<hy>
put(q<->>q_next,pri) respectively.
1 If a message of priority pri can be placed on the queue.
0 If the priority band is full.
The bcanput() function can be called from user, interrupt, or kernel context.
bcanputnext(9F), canput(9F), canputnext(9F), putbq(9F), putnext(9F)
Writing Device Drivers
STREAMS Programming Guide
Drivers are responsible for both testing a queue with bcanput() and refraining from placing a message on the queue
if bcanput() fails.
bcm_sata.7d <beginning of page>
bcm_sata <-> Broadcom HT1000 SATA controller driver
sata@unit-address
The bcm_sata driver is a SATA HBA driver that supports Broadcom HT1000 SATA HBA controllers.
HT1000 SATA controllers are compliant with the Serial ATA 1.0 specification and SATA II Phase 1.0 specification
(the extension to the SATA 1.0 specification). These HT1000 controllers support standard SATA features including
SATA-II disks, NCQ, hotplug, ATAPI devices and port multiplier.
The driver does not currently support NCQ and port multiplier features.
The bcm_sata module contains no user configurable parameters.
/kernel/drv/bcm_sata 32-bit ELF kernel module (x86)
/kernel/drv/amd64/bcm_sata 64-bit ELF kernel module (x86)
See attributes(5) for a description of the following attributes:
tab() box; lw(2.75i) |lw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Architecturex86 _
AvailabilitySUNWbcmsata
cfgadm(1M), cfgadm_sata(1M), prtconf(1M), attributes(5), sata(7D), sd(7D)
Writing Device Drivers
bdiff.1 <beginning of page>
bdiff <-> big diff
bdiff filename1 filename2 [n] [-s]
bdiff is used in a manner analogous to diff to find which lines in filename1 and filename2 must be changed to bring
the files into agreement. Its purpose is to allow processing of files too large for diff. If filename1 (filename2) is <mi>, the
standard input is read.
bdiff ignores lines common to the beginning of both files, splits the remainder of each file into n-line segments, and
invokes diff on corresponding segments. If both optional arguments are specified, they must appear in the order indi<hy>
cated above.
The output of bdiff is exactly that of diff, with line numbers adjusted to account for the segmenting of the files (that
is, to make it look as if the files had been processed whole). Note: Because of the segmenting of the files, bdiff does
not necessarily find a smallest sufficient set of file differences.
n The number of line segments. The value of n is 3500 by default. If the optional third argument is given and it is nu<hy>
meric, it is used as the value for n. This is useful in those cases in which 3500-line segments are too large for diff,
causing it to fail.
-s Specifies that no diagnostics are to be printed by bdiff (silent option). Note: However, this does not suppress pos<hy>
sible diagnostic messages from diff, which bdiff calls.
See largefile(5) for the description of the behavior of bdiff when encountering files greater than or equal to 2 Gbyte
( 2^31 bytes).
/tmp/bd?????
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wesu _ CSIenabled
diff(1), attributes(5), largefile(5)
Use help for explanations.
ber_decode.3ldap <beginning of page>
ber_decode, ber_alloc_t, ber_free, ber_bvdup, ber_init, ber_flatten, ber_get_next, ber_skip_tag, ber_peek_tag,
ber_scanf, ber_get_int, ber_get_stringa, ber_get_stringal, ber_get_stringb, ber_get_null, ber_get_boolean,
ber_get_bitstring, ber_first_element, ber_next_element, ber_bvfree, ber_bvecfree <-> Basic Encoding Rules library
decoding functions
cc[ flag... ] file... -lldap[ library... ]
#include <lber.h>
BerElement *ber_alloc_t(int options);
struct berval *ber_bvdup(const struct berval *bv);
void ber_free(BerElement *ber, int freebuf);
BerElement *ber_init(const struct berval *bv);
int ber_flatten(BerElement *ber, struct berval **bvPtr);
ber_tag_tber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);
ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);
ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);
ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);
ber_tag_t ber_get_stringb(BerElement *ber, char *buf,
 ber_len_t *len);
ber_tag_t ber_get_stringa(BerElement *ber, char **buf);
ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);
ber_tag_t ber_get_null(BerElement *ber);
ber_tag_t ber_get_boolean(BerElement *ber, int *boolval);
ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf,
 ber_len_t *len);
ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len,
 char **last);
ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len,
 char *last);
ber_tag_t ber_scanf(BerElement *ber, const char *fmt [, arg...]);
void ber_bvfree(struct berval *bv);
void ber_bvecfree(struct berval **bvec);
These functions provide a subfunction interface to a simplified implementation of the Basic Encoding Rules of
ASN.1. The version of BER these functions support is the one defined for the LDAP protocol. The encoding rules
are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always en<hy>
coded in primitive form. In addition, these lightweight BER functions restrict tags and class to fit in a single octet
(this means the actual tag must be less than 31). When a "tag"is specified in the descriptions below, it refers to the
tag, class, and primitive or constructed bit in the first octet of the encoding. This man page describes the decoding
functions in the lber library. See ber_encode(3LDAP) for details on the corresponding encoding functions.
Normally, the only functions that need be called by an application are ber_get_next() to get the next BER element
and ber_scanf() to do the actual decoding. In some cases, ber_peek_tag() may also need to be called in normal
usage. The other functions are provided for those applications that need more control than ber_scanf() provides. In
general, these functions return the tag of the element decoded, or <mi>1 if an error occurred.
The ber_get_next() function is used to read the next BER element from the given Sockbuf, sb. A Sockbuf consists
<beginning of page>
of the descriptor (usually socket, but a file descriptor works just as well) from which to read, and a BerElement
structure used to maintain a buffer. On the first call, the sb_ber struct should be zeroed. It strips off and returns the
leading tag byte, strips off and returns the length of the entire element in len, and sets up ber for subsequent calls to
ber_scanf(), and all to decode the element.
The ber_peek_tag() function returns the tag of the next element to be parsed in the BerElement argument. The
length of this element is stored in the *lenPtr argument. LBER_DEFAULT is returned if there is no further data to
be read. The decoding position within the ber argument is unchanged by this call; that is, the fact that
ber_peek_tag() has been called does not affect future use of ber.
The ber_skip_tag() function is similar to ber_peek_tag(), except that the state pointer in the BerElement argument
is advanced past the first tag and length, and is pointed to the value part of the next element. This function should
only be used with constructed types and situations when a BER encoding is used as the value of an OCTET
STRING. The length of the value is stored in *lenPtr.
The ber_scanf() function is used to decode a BER element in much the same way that scanf(3C) works. It reads
from ber, a pointer to a BerElement such as returned by ber_get_next(), interprets the bytes according to the for<hy>
mat string fmt, and stores the results in its additional arguments. The format string contains conversion specifica<hy>
tions which are used to direct the interpretation of the BER element. The format string can contain the following
characters.
a Octet string. A char ** should be supplied. Memory is allocated, filled with the contents of the octet string, null-
terminated, and returned in the parameter.
s Octet string. A char * buffer should be supplied, followed by a pointer to an integer initialized to the size of the
buffer. Upon return, the null-terminated octet string is put into the buffer, and the integer is set to the actual size of
the octet string.
O Octet string. A struct ber_val ** should be supplied, which upon return points to a memory allocated struct berval
containing the octet string and its length. ber_bvfree() can be called to free the allocated memory.
b Boolean. A pointer to an integer should be supplied.
i Integer. A pointer to an integer should be supplied.
B Bitstring. A char ** should be supplied which will point to the memory allocated bits, followed by an unsigned
long *, which will point to the length (in bits) of the bitstring returned.
n Null. No parameter is required. The element is simply skipped if it is recognized.
v Sequence of octet strings. A char *** should be supplied, which upon return points to a memory allocated null-
terminated array of char *'s containing the octet strings. NULL is returned if the sequence is empty.
V Sequence of octet strings with lengths. A struct berval *** should be supplied, which upon return points to a
memory allocated, null-terminated array of struct berval *'s containing the octet strings and their lengths. NULL is
returned if the sequence is empty. ber_bvecfree() can be called to free the allocated memory.
x Skip element. The next element is skipped.
{ Begin sequence. No parameter is required. The initial sequence tag and length are skipped.
} End sequence. No parameter is required and no action is taken.
<beginning of page>
[ Begin set. No parameter is required. The initial set tag and length are skipped.
] End set. No parameter is required and no action is taken.
The ber_get_int() function tries to interpret the next element as an integer, returning the result in num. The tag of
whatever it finds is returned on success, -1 on failure.
The ber_get_stringb() function is used to read an octet string into a pre-allocated buffer. The len parameter should
be initialized to the size of the buffer, and will contain the length of the octet string read upon return. The buffer
should be big enough to take the octet string value plus a terminating NULL byte.
The ber_get_stringa() function is used to allocate memory space into which an octet string is read.
The ber_get_stringal() function is used to allocate memory space into which an octet string and its length are read.
It takes a struct berval **, and returns the result in this parameter.
The ber_get_null() function is used to read a NULL element. It returns the tag of the element it skips over.
The ber_get_boolean() function is used to read a boolean value. It is called the same way that ber_get_int() is
called.
The ber_get_bitstringa() function is used to read a bitstring value. It takes a char ** which will hold the allocated
memory bits, followed by an unsigned long *, which will point to the length (in bits) of the bitstring returned.
The ber_first_element() function is used to return the tag and length of the first element in a set or sequence. It also
returns in last a magic cookie parameter that should be passed to subsequent calls to ber_next_element(), which re<hy>
turns similar information.
The ber_alloc_t() function constructs and returns BerElement. A null pointer is returned on error. The options field
contains a bitwise-OR of options which are to be used when generating the encoding of this BerElement. One op<hy>
tion is defined and must always be supplied:
 #define LBER_USE_DER 0x01
When this option is present, lengths will always be encoded in the minimum number of octets. Note that this option
does not cause values of sets and sequences to be rearranged in tag and byte order, so these functions are not suitable
for generating DER output as defined in X.509 and X.680
The ber_init function constructs a BerElement and returns a new BerElement containing a copy of the data in the
bv argument. The ber_init function returns the null pointer on error.
The ber_free() function frees a BerElement which is returned from the API calls ber_alloc_t() or ber_init(). Each
BerElement must be freed by the caller. The second argument freebuf should always be set to 1 to ensure that the in<hy>
ternal buffer used by the BER functions is freed as well as the BerElement container itself.
The ber_bvdup() function returns a copy of a berval. The bv_val field in the returned berval points to a different
area of memory as the bv_val field in the argument berval. The null pointer is returned on error (that is, is out of
memory).
The ber_flatten() function allocates a struct berval whose contents are BER encoding taken from the ber argu<hy>
ment. The bvPtr pointer points to the returned berval, which must be freed using ber_bvfree(). This function re<hy>
turns 0 on success and <mi>1 on error. Example 1 Assume the variable ber contains a lightweight BER encoding of
the following ASN.1 object:
  AlmostASearchRequest := SEQUENCE {
  baseObject DistinguishedName,
  scope ENUMERATED {
  baseObject (0),
  singleLevel (1),
  wholeSubtree (2)
  },
  derefAliases ENUMERATED {
  neverDerefaliases (0),
<beginning of page>
  derefInSearching (1),
  derefFindingBaseObj (2),
  alwaysDerefAliases (3N)
  },
  sizelimit INTEGER (0 .. 65535),
  timelimit INTEGER (0 .. 65535),
  attrsOnly BOOLEAN,
  attributes SEQUENCE OF AttributeType
  }
Example 2 The element can be decoded using ber_scanf() as follows.
  int scope, ali, size, time, attrsonly;
  char *dn, **attrs;
  if ( ber_scanf( ber, "{aiiiib{v}}", &dn, &scope, &ali,
  &size, &time, &attrsonly, &attrs ) == -1 )
  /* error */
  else
  /* success */
If an error occurs during decoding, generally these functions return <mi>1.
The return values for all of these functions are declared in the <lber.h> header. Some functions may allocate memo<hy>
ry which must be freed by the calling application.
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsl (32-bit) _ SUNWcslx (64-bit) _ Interface StabilityCommitted
ber_encode(3LDAP), attributes(5)
Yeong, W., Howes, T., and Hardcastle-Kille, S., "Lightweight Directory Access Protocol", OSI-DS-26, April 1992.
Information Processing - Open Systems Interconnection - Model and Notation - Service Definition - Specification of
Basic Encoding Rules for Abstract Syntax Notation One, International Organization for Standardization, Interna<hy>
tional Standard 8825.
bfe.7d <beginning of page>
bfe <-> Device driver for Broadcom BCM4401 100Base-T NIC
The bfe Fast Ethernet driver is GLD-based and supports the Broadcom BCM4401 100Base-T NIC adapters
:pci14e4,170c Broadcom BCM4401 100Base-T..
The bfe driver supports IEEE 802.3 auto-negotiation, flow control and VLAN tagging.
The default configuration is auto-negotiation with bidirectional flow control. The advertised capabilities for auto-ne<hy>
gotiation are based on the capabilities of the PHY.
You can set the capabilities advertised by the bfe controlled device using dladm(1M). The driver supports only
those parameters which begin with en (enabled) in the parameters listed by the command dladm(1M). Each of these
boolean parameters determines if the device advertises that mode of operation when the hardware supports it.
/dev/bfe Special character device
/kernel/drv/bfe 32-bit device driver (x86)
/kernel/drv/amd64/bfe 64-bit device driver (x86)
See attributes(5) for a description of the following attributes:
tab() box; lw(2.75i) |lw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureSPARC,
x86
dladm(1M), netstat(1M), driver.conf(4), attributes(5), ieee802.3(5), dlpi(7P), streamio(7I)
Writing Device Drivers
STREAMS Programmer's Guide
Network Interface Guide
IEEE 802.3ae Specification - 2002
bge.7d <beginning of page>
bge <-> SUNW,bge Gigabit Ethernet driver for Broadcom BCM57xx
/dev/bge*
The bge Gigabit Ethernet driver is a multi-threaded, loadable, clonable, GLD-based STREAMS driver supporting
the Data Link Provider Interface, dlpi(7P), on Broadcom BCM57xx
(BCM5700/5701/5703/5704/5705/5705M/5714/5721/5751/5751M/5782/5788 on x86) Gigabit Ethernet controllers
fitted to the system motherboard. With the exception of BCM5700/BCM5701/BCM5704S, these devices incorporate
both MAC and PHY functions and provide three-speed (copper) Ethernet operation on the RJ-45 connectors.
(BCM5700/BCM5701/BCM5704S do not have a PHY integrated into the MAC chipset.)
The bge driver functions include controller initialization, frame transmit and receive, promiscuous and multicast
support, and error recovery and reporting.
The bge driver and hardware support auto-negotiation, a protocol specified by the 1000 Base-T standard. Auto-nego<hy>
tiation allows each device to advertise its capabilities and discover those of its peer (link partner). The highest com<hy>
mon denominator supported by both link partners is automatically selected, yielding the greatest available through<hy>
put, while requiring no manual configuration. The bge driver also allows you to configure the advertised capabilities
to less than the maximum (where the full speed of the interface is not required), or to force a specific mode of opera<hy>
tion, irrespective of the link partner's advertised capabilities.
The cloning character-special device, /dev/bge, is used to access all BCM57xx devices (
(BCM5700/5701/5703/5704, 5705/5714/5721/5751/5751M/5782 on x86) fitted to the system motherboard.
The bge driver is managed by the dladm(1M) command line utility, which allows VLANs to be defined on top of
bge instances and for bge instances to be aggregated. See dladm(1M) for more details.
You must send an explicit DL_ATTACH_REQ message to associate the opened stream with a particular device
(PPA). The PPA ID is interpreted as an unsigned integer data type and indicates the corresponding device instance
(unit) number. The driver returns an error (DL_ERROR_ACK) if the PPA field value does not correspond to a valid
device instance number for the system. The device is initialized on first attach and de-initialized (stopped) at last de<hy>
tach.
The values returned by the driver in the DL_INFO_ACK primitive in response to a DL_INFO_REQ are: <bu> Maximum
SDU (default 1500). <bu> Minimum SDU (default 0). <bu> DLSAP address length is 8. <bu> MAC type is DL_ETHER. <bu>
SAP length value is -2, meaning the physical address component is followed immediately by a 2-byte SAP compo<hy>
nent within the DLSAP address. <bu> Broadcast address value is the Ethernet/IEEE broadcast address
(FF:FF:FF:FF:FF:FF).
Once in the DL_ATTACHED state, you must send a DL_BIND_REQ to associate a particular Service Access Point
(SAP) with the stream.
By default, the bge driver performs auto-negotiation to select the link speed and mode. Link speed and mode can be
any one of the following, (as described in the IEEE803.2 standard): <bu> 1000 Mbps, full-duplex <bu> 1000 Mbps, half-du<hy>
plex <bu> 100 Mbps, full-duplex <bu> 100 Mbps, half-duplex <bu> 10 Mbps, full-duplex <bu> 10 Mbps, half-duplex
The auto-negotiation protocol automatically selects: <bu> Speed (1000 Mbps, 100 Mbps, or 10 Mbps) <bu> Operation mode
(full-duplex or half-duplex)
as the highest common denominator supported by both link partners. Because the bge device supports all modes, the
effect is to select the highest throughput mode supported by the other device.
Alternatively, you can set the capabilities advertised by the bge device using dladm(1M). The driver supports a
number of parameters whose names begin with en_ (see below). Each of these parameters contains a boolean value
that determines whether the device advertises that mode of operation. If en_autoneg_cap is set to 0, the driver
forces the mode of operation selected by the first non-zero parameter in priority order as listed below:
  (highest priority/greatest throughput)
  en_1000fdx_cap 1000Mbps full duplex
  en_1000hdx_cap 1000Mpbs half duplex
  en_100fdx_cap 100Mpbs full duplex
  en_100hdx_cap 100Mpbs half duplex
  en_10fdx_cap 10Mpbs full duplex
  en_10hdx_cap 10Mpbs half duplex
  (lowest priority/least throughput)
<beginning of page>
For example, to prevent the device 'bge2' from advertising gigabit capabilities, enter (as super-user):
 # dladm set-linkprop -p enable_1000hdx_cap=0 bge2
 # dladm set-linkprop -p enable_1000fdx_cap=0 bge2
All capabilities default to enabled. Note that changing any capability parameter causes the link to go down while the
link partners renegotiate the link speed/duplex using the newly changed capabilities.
The current settings of the parameters may be found using dladm show-ether. In addition, the driver exports the cur<hy>
rent state, speed, duplex setting, and working mode of the link via kstat parameters (these are read only and may not
be changed). For example, to check link state of device bge0:
 # dladm show-ether -x bge0
 LINK PTYPE STATE AUTO SPEED-DUPLEX PAUSE
 bge0 current up yes 1G-f bi
 -- capable -- yes 1G-fh,100M-fh,10M-fh bi
 -- adv -- yes 1G-fh bi
 -- peeradv -- yes 1G-f bi
The output above indicates that the link is up and running at 1Gbps full-duplex with its rx/tx direction pause capabil<hy>
ity.
To extract link state information for the same link using kstat:
 # kstat bge:0:mac:link_state
 module: bge instance: 0
 name: mac class: net
 link_state
The default MTU is 1500. To enable Jumbo Frames support, you can configure the bge driver by defining the de<hy>
fault_mtu property via dladm(1M) or in driver.conf(4) to greater than 1500 bytes (for example: default_mtu=9000).
Note that the largest jumbo size supported by bge is 9000 bytes. Additionally, not all bge-derived devices currently
support Jumbo Frames. The following devices support Jumbo Frames up to 9KB: BCM5700, 5701, 5702, 5703C,
5703S, 5704C, 5704S, 5714C, 5714S, 5715C and 5715S. Other devices currently do not support Jumbo Frames.
/kernel/drv/bge* 32-bit ELF kernel module. (x86)
/kernel/drv/amd64/bge 64-bit ELF kernel module (x86).
/kernel/drv/sparcv9/bge 64-bit ELF kernel module (SPARC).
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ ArchitectureS<hy>
PARC, x86
dladm(1M), driver.conf(4), attributes(5), streamio(7I), dlpi(7P)
Writing Device Drivers
STREAMS Programming Guide
Network Interfaces Programmer's Guide
biff.1b <beginning of page>
biff <-> give notice of incoming mail messages
/usr/ucb/biff [y | n]
biff turns mail notification on or off for the terminal session. With no arguments, biff displays the current notifica<hy>
tion status for the terminal.
If notification is allowed, the terminal rings the bell and displays the header and the first few lines of each arriving
mail message. biff operates asynchronously. For synchronized notices, use the MAIL variable of sh(1) or the mail
variable of csh(1).
A `biff y' command can be included in your ~/.login or ~/.profile file for execution when you log in.
y Allow mail notification for the terminal.
n Disable notification for the terminal.
~/.login User's login file
~/.profile User's profile file
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wscpu
csh(1), mail(1), sh(1), attributes(5)
bind.3xnet <beginning of page>
bind <-> bind a name to a socket
cc [ flag ... ] file ... -lxnet [ library ... ]
#include <sys/socket.h>
int bind(int socket, const struct sockaddr *address,
 socklen_t address_len);
The bind() function assigns an address to an unnamed socket. Sockets created with socket(3XNET) function are
initially unnamed. They are identified only by their address family.
The function takes the following arguments:
socket Specifies the file descriptor of the socket to be bound.
address Points to a sockaddr structure containing the address to be bound to the socket. The length and format of
the address depend on the address family of the socket.
address_len Specifies the length of the sockaddr structure pointed to by the address argument.
The socket in use may require the process to have appropriate privileges to use the bind() function.
An application program can retrieve the assigned socket name with the getsockname(3XNET) function.
Upon successful completion, bind() returns 0. Otherwise, <mi>1 is returned and errno is set to indicate the error.
The bind() function will fail if:
EADDRINUSE The specified address is already in use.
EADDRNOTAVAIL The specified address is not available from the local machine.
EAFNOSUPPORT The specified address is not a valid address for the address family of the specified socket.
EBADF The socket argument is not a valid file descriptor.
EFAULT The address argument can not be accessed.
EINVAL The socket is already bound to an address, and the protocol does not support binding to a new address; or
the socket has been shut down.
ENOTSOCK The socket argument does not refer to a socket.
EOPNOTSUPP The socket type of the specified socket does not support binding to an address.
If the address family of the socket is AF_UNIX, then bind() will fail if:
EACCES A component of the path prefix denies search permission, or the requested name requires writing in a di<hy>
rectory with a mode that denies write permission.
EDESTADDRREQ
EISDIR The address argument is a null pointer.
<beginning of page>
EIO An I/O error occurred.
ELOOP Too many symbolic links were encountered in translating the pathname in address.
ENAMETOOLONG A component of a pathname exceeded NAME_MAX characters, or an entire pathname exceed<hy>
ed PATH_MAX characters.
ENOENT A component of the pathname does not name an existing file or the pathname is an empty string.
ENOTDIR A component of the path prefix of the pathname in address is not a directory.
EROFS The name would reside on a read-only filesystem.
The bind() function may fail if:
EACCES The specified address is protected, and {PRIV_NET_PRIVADOR} is not asserted in the effective set of
the current process.
EINVAL The address_len argument is not a valid length for the address family.
EISCONN The socket is already connected.
ENAMETOOLONG Pathname resolution of a symbolic link produced an intermediate result whose length exceeds
PATH_MAX.
ENOBUFS Insufficient resources were available to complete the call.
ENOSR There were insufficient STREAMS resources for the operation to complete.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
connect(3XNET), getsockname(3XNET), listen(3XNET), socket(3XNET), attributes(5), privileges(5), stan<hy>
dards(5)
biodone.9f <beginning of page>
biodone <-> release buffer after buffer I/O transfer and notify blocked threads
#include <sys/types.h>
#include <sys/buf.h>
void biodone(struct buf *bp);
Architecture independent level 1 (DDI/DKI).
bp Pointer to a buf(9S) structure.
The biodone() function notifies blocked processes waiting for the I/O to complete, sets the B_DONE flag in the
b_flags field of the buf(9S) structure, and releases the buffer if the I/O is asynchronous. biodone() is called by either
the driver interrupt or strategy(9E) routines when a buffer I/O request is complete.
The biodone() function provides the capability to call a completion routine if bp describes a kernel buffer. The ad<hy>
dress of the routine is specified in the b_iodone field of the buf(9S) structure. If such a routine is specified,
biodone() calls it and returns without performing any other actions. Otherwise, it performs the steps above.
The biodone() function can be called from user, interrupt, or kernel context.
Generally, the first validation test performed by any block device strategy(9E) routine is a check for an end-of-file
(EOF) condition. The strategy(9E) routine is responsible for determining an EOF condition when the device is ac<hy>
cessed directly. If a read(2) request is made for one block beyond the limits of the device (line 10), it will report an
EOF condition. Otherwise, if the request is outside the limits of the device, the routine will report an error condi<hy>
tion. In either case, report the I/O operation as complete (line 27).
  1 #define RAMDNBLK 1000 /* Number of blocks in RAM disk */
  2 #define RAMDBSIZ 512 /* Number of bytes per block */
  3 char ramdblks[RAMDNBLK][RAMDBSIZ]; /* Array containing RAM disk */
  4
  5 static int
  6 ramdstrategy(struct buf *bp)
  7 {
  8 daddr_t blkno = bp->b_blkno;/* get block number */
  9
 10 if ((blkno < 0) || (blkno >= RAMDNBLK)) {
 11 /*
 12 * If requested block is outside RAM disk
 13 * limits, test for EOF which could result
 14 * from a direct (physio) request.
 15 */
 16 if ((blkno == RAMDNBLK) && (bp->b_flags & B_READ)) {
 17 /*
 18 * If read is for block beyond RAM disk
 19 * limits, mark EOF condition.
 20 */
 21 bp->b_resid = bp->b_bcount; /* compute return value */
 22
 23 } else { /* I/O attempt is beyond */
 24 bp->b_error = ENXIO; /* limits of RAM disk */
 25 bp->b_flags |= B_ERROR; /* return error */
 26 }
 27 biodone(bp); /* mark I/O complete (B_DONE) */
 28 /*
 29 * Wake any processes awaiting this I/O
 30 * or release buffer for asynchronous
 31 * (B_ASYNC) request.
 32 */
 33 return (0);
 34 }
  ...
<beginning of page>
read(2), strategy(9E), biowait(9F), ddi_add_intr(9F), delay(9F), timeout(9F), untimeout(9F), buf(9S)
Writing Device Drivers
After calling biodone(), bp is no longer available to be referred to by the driver. If the driver makes any reference to
bp after calling biodone(), a panic may result.
Drivers that use the b_iodone field of the buf(9S) structure to specify a substitute completion routine should save the
value of b_iodone before changing it, and then restore the old value before calling biodone() to release the buffer.
biofini.9f <beginning of page>
biofini <-> uninitialize a buffer structure
#include <sys/ddi.h>
#include <sys/sunddi.h>
void biofini(struct buf *bp);
Solaris DDI specific (Solaris DDI).
bp Pointer to the buffer header structure.
The biofini() function uninitializes a buf(9S) structure. If a buffer structure has been allocated and initialized using
kmem_alloc(9F) and bioinit(9F) it needs to be uninitialized using biofini() before calling kmem_free(9F). It is not
necessary to call biofini() before freeing a buffer structure using freerbuf(9F) because freerbuf() will call biofini()
directly.
The biofini() function can be called from any context. Example 1 Using biofini()
 struct buf *bp = kmem_alloc(biosize(), KM_SLEEP);  
 bioinit(bp);  
 /* use buffer */  
 biofini(bp);  
 kmem_free(bp, biosize());
bioinit(9F), bioreset(9F), biosize(9F), freerbuf(9F), kmem_alloc(9F), kmem_free(9F), buf(9S)
Writing Device Drivers
biomodified.9f <beginning of page>
biomodified <-> check if a buffer is modified
#include <sys/ddi.h>
#include <sys/sunddi.h>
int biomodified(struct buf *bp);
Solaris DDI specific (Solaris DDI).
bp Pointer to the buffer header structure.
The biomodified() function returns status to indicate if the buffer is modified. The biomodified() function is only
supported for paged- I/O request, that is the B_PAGEIOflag must be set in the b_flags field of the buf(9S) structure.
The biomodified() function will check the memory pages associated with this buffer whether the Virtual Memory
system's modification bit is set. If at least one of these pages is modified, the buffer is indicated as modified. A
filesystem will mark the pages unmodified when it writes the pages to the backing store. The biomodified() func<hy>
tion can be used to detect any modifications to the memory pages while I/O is in progress.
A device driver can use biomodified() for disk mirroring. An application is allowed to mmap a file which can re<hy>
side on a disk which is mirrored by multiple submirrors. If the file system writes the file to the backing store, it is
written to all submirrors in parallel. It must be ensured that the copies on all submirrors are identical. The biomodi<hy>
fied() function can be used in the device driver to detect any modifications to the buffer by the user program during
the time the buffer is written to multiple submirrors.
The biomodified() function returns the following values:
1 Buffer is modified.
0 Buffer is not modified.
-1 Buffer is not used for paged I/O request.
biomodified() can be called from any context.
bp_mapin(9F), buf(9S)
Writing Device Drivers
biosize.9f <beginning of page>
biosize <-> returns size of a buffer structure
#include <sys/ddi.h>
#include <sys/sunddi.h>
size_t biosize(void)
Solaris DDI specific (Solaris DDI).
The biosize() function returns the size in bytes of the buf(9S) structure. The biosize() function is used by drivers in
combination with kmem_alloc(9F) and bioinit(9F) to allocate buffer structures embedded in other data structures.
The biosize() function can be called from any context.
biofini(9F), bioinit(9F), getrbuf(9F), kmem_alloc(9F), buf(9S)
Writing Device Drivers
bkgd.3xcurses <beginning of page>
bkgd, bkgdset, getbkgd, wbkgd, wbkgdset <-> set or get the background character (and rendition) of window
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library... ]
#include <curses.h>
int bkgd(chtype ch);
void bkgdset(chtype ch);
chtype getbkgd(WINDOW *win);
int wbkgd(WINDOW *win, chtype ch);
void wbkgdset(WINDOW *win, chtype ch);
The bkgdset() and wbkgdset() functions turn off the previous background attributes, logical OR the requested at<hy>
tributes into the window rendition, and set the background property of the current or specified window based on the
information in ch. If ch refers to a multi-column character, the results are undefined.
The bkgd() and wbkgd() functions turn off the previous background attributes, logical OR the requested attributes
into the window rendition, and set the background property of the current or specified window and then apply this
setting to every character position in that window: <bu> The rendition of every character on the screen is changed to the
new window rendition. <bu> Wherever the former background character appears, it is changed to the new background
character.
The getbkgd() function extracts the specified window's background character and rendition.
ch Is the background character to be set.
win Is a pointer to the window in which the background character is to be set.
Upon successful completion, the bkgd() and wbkgd() functions return OK. Otherwise, they return ERR.
The bkgdset() and wbkgdset() functions do not return a value.
Upon successful completion, the getbkgd() function returns the specified window's background character and rendi<hy>
tion. Otherwise, it returns (chtype)ERR.
No errors are defined.
These functions are only guaranteed to operate reliably on character sets in which each character fits into a single
byte, whose attributes can be expressed using only constants with the A_ prefix.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
addch(3XCURSES), addchstr(3XCURSES), attroff(3XCURSES), bkgrnd(3XCURSES), clear(3XCURSES), clr<hy>
toeol(3XCURSES), clrtobot(3XCURSES), erase(3XCURSES), inch(3XCURSES), libcurses(3XCURSES),
mvprintw(3XCURSES), attributes(5), standards(5)
blcompare.3tsol <beginning of page>
blcompare, blequal, bldominates, blstrictdom, blinrange <-> compare binary labels
cc [flag...] file... -ltsol [library...]
#include <tsol/label.h>
int blequal(const m_label_t *label1, const m_label_t *label2);
int bldominates(const m_label_t *label1, const m_label_t *label2);
int blstrictdom(const m_label_t *label1, const m_label_t *label2);
int blinrange(const m_label_t *label, const brange_t *range);
These functions compare binary labels for meeting a particular condition.
The blequal() function compares two labels for equality.
The bldominates() function compares label label1 for dominance over label label2.
The blstrictdom() function compares label label1 for strict dominance over label label2.
The blinrange() function compares label label for dominance over range<->>lower_bound and range<->>upper_bound
for dominance over level label.
These functions return non-zero if their respective conditions are met, otherwise zero is returned.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
getplabel(3TSOL), label_to_str(3TSOL), libtsol(3LIB), ucred_getlabel(3C), label_encodings(4), attributes(5),
labels(5)
Determining the Relationship Between Two Labels in Solaris Trusted Extensions Developer's Guide
The functionality described on this manual page is available only if the system is configured with Trusted Exten<hy>
sions.
blminmax.3tsol <beginning of page>
blminmax, blmaximum, blminimum <-> bound of two labels
cc [flag...] file... -ltsol [library...]
#include <tsol/label.h>
void blmaximum(m_label_t *maximum_label,
 const m_label_t *bounding_label);
void blminimum(m_label_t *minimum_label,
 const m_label_t *bounding_label);
The blmaximum() function replaces the contents of label maximum_label with the least upper bound of the labels
maximum_label and bounding_label. The least upper bound is the greater of the classifications and all of the com<hy>
partments of the two labels. This is the least label that dominates both of the original labels.
The blminimum() function replaces the contents of label minimum_label with the greatest lower bound of the labels
minimum_label and bounding_label. The greatest lower bound is the lower of the classifications and only the com<hy>
partments that are contained in both labels. This is the greatest label that is dominated by both of the original labels.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
label_to_str(3TSOL), libtsol(3LIB), sbltos(3TSOL), attributes(5)
The functionality described on this manual page is available only if the system is configured with Trusted Exten<hy>
sions.
bltos.3tsol <beginning of page>
bltos, bsltos, bcleartos <-> translate binary labels to character coded labels
cc [flag...] file... -ltsol [library...]
#include <tsol/label.h>
int bsltos(const m_label_t *label, char **string,
 const int str_len, const int flags);
int bcleartos(const m_label_t *label, char **string,
 const int str_len, const int flags);
These functions translate binary labels into strings controlled by the value of the flags parameter.
The bsltos() function translates a binary sensitivity label into a string. The applicable flags are LONG_CLASSIFI<hy>
CATION or SHORT_CLASSIFICATION, LONG_WORDS or SHORT_WORDS, VIEW_EXTERNAL or
VIEW_INTERNAL, and NO_CLASSIFICATION. A flags value 0 is equivalent to (SHORT_CLASSIFICA<hy>
TION | LONG_WORDS).
The bcleartos() function translates a binary clearance into a string. The applicable flags are LONG_CLASSIFICA<hy>
TION or SHORT_CLASSIFICATION, LONG_WORDS or SHORT_WORDS, VIEW_EXTERNAL or
VIEW_INTERNAL, and NO_CLASSIFICATION. A flags value 0 is equivalent to (SHORT_CLASSIFICA<hy>
TION | LONG_WORDS). The translation of a clearance might not be the same as the translation of a sensitivity la<hy>
bel. These functions use different label_encodings file tables that might contain different words and constraints.
The calling process must have PRIV_SYS_TRANS_LABEL in its set of effective privileges to perform label trans<hy>
lation on labels that dominate the current process's sensitivity label.
The generic form of an output character-coded label is:
 CLASSIFICATION WORD1 WORD2 WORD3/WORD4 SUFFIX PREFIX WORD5/WORD6
Capital letters are used to display all CLASSIFICATION names and WORDs. The ` ' (space) character separates
classifications and words from other words in all character-coded labels except where multiple words that require the
same PREFIX or SUFFIX are present, in which case the multiple words are separated from each other by the `/'
(slash) character.
The string argument can point to either a pointer to pre-allocated memory, or the value (char *)0. If string points to
a pointer to pre-allocated memory, then str_len indicates the size of that memory. If string points to the value
(char *)0, memory is allocated using malloc() to contain the translated character-coded labels. The translated label
is copied into allocated or pre-allocated memory.
The flags argument is 0 or the logical sum of the following:
LONG_WORDS Translate using long names of words defined in label.
SHORT_WORDS Translate using short names of words defined in label. If no short name is defined in the la<hy>
bel_encodings file for a word, the long name is used.
LONG_CLASSIFICATION Translate using long name of classification defined in label.
SHORT_CLASSIFICATION Translate using short name of classification defined in label.
ACCESS_RELATED Translate only access-related entries defined in information label label.
VIEW_EXTERNAL Translate ADMIN_LOW and ADMIN_HIGH labels to the lowest and highest labels defined
in the label_encodings file.
<beginning of page>
VIEW_INTERNAL Translate ADMIN_LOW and ADMIN_HIGH labels to the admin low name and admin
high name strings specified in the label_encodings file. If no strings are specified, the strings "ADMIN_LOW" and
"ADMIN_HIGH" are used.
NO_CLASSIFICATION Do not translate classification defined in label.
If the VIEW_EXTERNAL or VIEW_INTERNAL flags are not specified, translation of ADMIN_LOW and AD<hy>
MIN_HIGH labels is controlled by the label view process attribute flags. If no label view process attribute flags are
defined, their translation is controlled by the label view configured in the label_encodings file. A value of External
specifies that ADMIN_LOW and ADMIN_HIGH labels are mapped to the lowest and highest labels defined in the
label_encodings file. A value of Internal specifies that the ADMIN_LOW and ADMIN_HIGH labels are translat<hy>
ed to the admin low and admin high name strings specified in the label_encodings file. If no such names are speci<hy>
fied, the strings "ADMIN_LOW" and "ADMIN_HIGH" are used.
Upon successful completion, the bsltos() and bcleartos() functions return the length of the character-coded label, in<hy>
cluding the NULL terminator.
If the label is not of the valid defined required type, if the label is not dominated by the process sensitivity label and
the process does not have PRIV_SYS_TRANS_LABEL in its set of effective privileges, or if the label_encodings
file is inaccessible, these functions return <mi>1.
If memory cannot be allocated for the return string or if the pre-allocated return string memory is insufficient to hold
the string, these functions return 0. The value of the pre-allocated string is set to the NULL string (*string[0]=' 0';).
/etc/security/tsol/label_encodings
The label encodings file contains the classification names, words, constraints, and values for the defined labels of
this system.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Obsolete _ MT-LevelMT-Safe with exceptions
The bsltos() and bcleartos() functions are Obsolete. Use the label_to_str(3TSOL) function instead.
free(3C), label_to_str(3TSOL), libtsol(3LIB), malloc(3C), label_encodings(4), attributes(5)
The functionality described on this manual page is available only if the system is configured with Trusted Exten<hy>
sions.
If memory is allocated by these functions, the caller must free the memory with free(3C) when the memory is no
longer in use.
bootadm.1m <beginning of page>
bootadm <-> manage bootability of GRUB-enabled operating system
/sbin/bootadm update-archive [-vn] [-R altroot [-p platform]]
/sbin/bootadm list-archive [-vn] [-R altroot [-p platform]]
 x86 only
/sbin/bootadm set-menu [-R altroot [-p platform]] key=value
/sbin/bootadm list-menu [-R altroot [-p platform]]
The bootadm command manages the boot archive and, with x86 boot environments, the GRUB (GRand Unified
Bootloader) menu. The update-archive option provides a way for user to update the boot archive as a preventative
measure or as part of a recovery procedure. The set-menu subcommand allows you to switch the auto-boot timeout
and default boot entry in the GRUB menu.
The list-menu subcommand displays the location of the GRUB menu and the current GRUB menu entries. While
the typical location of the GRUB menu is /boot/grub/menu.lst, depending on the install method used the active
GRUB menu might be located somewhere else. Use the list-menu subcommand to locate the active GRUB menu.
For example, if a system was installed using Live Upgrade, the GRUB menu might not be located in the current boot
environment. See the EXAMPLES section for typical output from the list-menu option.
Note that OpenBoot PROM (OBP)-based machines, such as SPARC systems, do not use GRUB and have no boot
menu manageable by bootadm.
The bootadm command determines dynamically the options supported by the image to be managed, so that
bootadm invoked on one platform can be used to manage diskless clients of a different platform type.
The bootadm command has the following subcommands:
update-archive
Updates current boot archive if required. Applies to both SPARC and x86 platforms.
list-archive
Lists the files and directories to be included in the boot archive. Applies to both SPARC and x86 platforms.
set-menu
Maintain the GRUB menu. The current GRUB menu is boot/grub/menu.lst, relative to root. Do not depend on this
location, because it is subject to change. Applies to x86 platforms only.
list-menu
Lists the location of the active GRUB menu, as well as the current GRUB menu entries. This includes the autoboot-
timeout, the default entry number, and the title of each entry. Applies to x86 platforms only.
The bootadm command has the following options:
-v
In an update-archive operation, stale files are displayed on stderr.
-n
In an update-archive operation, archive content is checked but not updated.
-p platform
The platform, or machine hardware class, of the client. The platform type can only be specified together with -R,
and is generally useful only for managing a diskless client where the client is of a different platform class than the
<beginning of page>
server. Platform must be one of i86pc, sun4u, or sun4v.
-R altroot
Operation is applied to an alternate root path. Note -
The root file system of any non-global zones must not be referenced with the -R option. Doing so might damage the
global zone's file system, might compromise the security of the global zone, and might damage the non-global
zone's file system. See zones(5).
key=value
Possible values are:
default=entrynum
The item number (for example, 0, 1, or 2) in the GRUB menu designating the operating system to boot when the
timer expires.
timeout=seconds
The number of seconds before the operating system designated by the default item number is booted. If the value is
-1, auto boot is disabled.
Example 1 Updating the Current Boot Archive
The following command updates the current boot archive:
 # bootadm update-archive
Example 2 Updating the Boot Archive on an Alternate Root
The following command updates the boot archive on an alternate root:
 # bootadm update-archive -R /a
Example 3 Listing Installed OS Instances
The following command lists the installed operating system instances in a GRUB menu:
 # bootadm list-menu
 default=0
 timeout=10
 (0) Solaris10
 (1) Solaris10 Failsafe
 (2) Linux
Example 4 Switching Default Boot Entry
The following command refers to the menu displayed in the previous example. The user selects Linux (item 2).
 # bootadm set-menu default=2
Example 5 Listing GRUB Menu Entries and Location of GRUB Menu
The following command lists the GRUB menu entries and the location of the GRUB menu:
 # bootadm list-menu
<beginning of page>
 The location for the active GRUB menu is: /stubboot/boot/grub/menu.lst
 default 0
 timeout 10
 0 Solaris10
 1 Solaris10 failsafe
 2 Linux
Example 6 Displaying Location of GRUB Menu
The following command displays the location of the GRUB menu:
 # bootadm list-menu
 The location for the active GRUB menu is: /dev/dsk/c0t1d0s0 (not mounted)
 The filesystem type of the menu device is <ufs>
 default 2
 timeout 10
 0 c0t1d0s3
 1 c0t1d0s3 failsafe
 2 Solaris10
 3 Solaris10 failsafe
In this example, the active GRUB menu is located on a device which is not mounted. To access the GRUB menu,
mount the device and access the GRUB menu at <mountpoint>/boot/grub/menu.lst.
The following exit values are returned:
0
The command completed successfully.
1
The command exited due to an error.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wcsu _ Interface StabilityCommitted
boot(1M), installgrub(1M), attributes(5)
Consult the GRUB home page, under:
 http://www.gnu.org/
bootparams.4 <beginning of page>
bootparams <-> boot parameter data base
/etc/bootparams
The bootparams file contains a list of client entries that diskless clients use for booting. Diskless booting clients re<hy>
trieve this information by issuing requests to a server running the rpc.bootparamd(1M) program. The bootparams
file may be used in conjunction with or in place of other sources for the bootparams information. See nss<hy>
witch.conf(4).
For each client the file contains an entry with the client's name and a list of boot parameter values for that client.
Each entry has the form:
 clientname keyword=value...
The first item of each entry is the host name of the diskless client. You can use the asterisk ('*') character as a "wild<hy>
card" in place of the client name in a single entry. A wildcard entry applies to all clients for which there is not an en<hy>
try that specifically names them.
In a given entry, the host name or asterisk is followed by one or more whitespace characters and a series of
keyword<em>value pairs separated by whitespace characters. There must not be any whitespace within a keyword<em>
value pair.
Each keyword<em>value pair has the syntax:
 keyword=value
The preceding form breaks out further as:
 keyword=server:value
Where server can be null and value can be a pathname.
An example that includes a server is:
 client1 root=server1:/export/client1/root
An example where server is null is:
 client1 rootopts=:vers2
A minor variation of the keyword=value syntax is used for the domain keyword. Unlike the forms shown above, this
syntax does not use a colon. For example:
 client1 domain=bldg1.workco.com
Entries can span multiple lines. Use the backslash ('\') character as the last character of a line to continue the entry
to the following line. For multiple-line entries, you can split a line only in places where whitespace is allowed. For
example, you can use a backslash to split the following entry between the end of the path (root) and the keyword do<hy>
main:
 client1 root=server1:/export/client1/root domain=bldg1.workco.com
<beginning of page>
In entries that specify a server, server is the name of the server that will provide the file or filesystem to the diskless
client and value is the pathname of the exported file or filesystem on that server.
In entries that use the domain keyword, the domain name specified must be the client's domain name. The algorithm
for determining a client's domain name is to first check for a domain keyword in the client-specific entry and then in
"wildcard" entry. If none is found, the server's domain name is used.
For the JumpStart installation of machines that do not have video displays, use the term keyword to identify the ter<hy>
minal type of the boot server. Terminal types are listed in /usr/share/lib/terminfo (see terminfo(4)).
An entry with the ns keyword associates a server (a name server) with, instead of a pathname, a specific name ser<hy>
vice (NIS+, NIS, LDAP, or none) and, if that server is not on a local subnet, the netmask needed to reach it. For ex<hy>
ample:
 ns=hoot:nisplus(255.255.255.0)
An ns entry forces sysidtool(1M) to use the specified name service. By default, sysidtool uses NIS+ in preference to
NIS or LDAP if it can find an NIS+ server for the system's domain on the subnet. An ns entry might be necessary if
you are trying to set up a hands-off installation, or if the name server is on a different subnet, which is common with
NIS+.
If an ns keyword is not used, sysidtool uses broadcast to attempt to bind to either a NIS+, NIS, or LDAP server. If a
name server is not on the local subnet, which is possible for NIS+ or LDAP, the bind will fail, automatic configura<hy>
tion of the name service will fail, and an interactive screen is displayed, prompting the user to specify the name ser<hy>
vice.
The ns keyword can be set in add_install_client or by Host Manager. Example 1 Sample bootparams Entry
Here is an example of an entry in the bootparams file:
  client1 root=server1:/export/client1/root rootopts=:vers=2 \
   domain=bldg1.workco.com
  client2 root=server2:/export/client2/root ns=:nis
  client3 root=server2:/export/client3/root ns=watson:
  client4 root=server2:/export/client4/root \
   ns=mach:nisplus(255.255.255.0)
Example 2 Sample Entry for JumpStart
The following is an example of an entry that might be used for the JumpStart installation of diskless clients that do
not have displays.
 mozart root=haydn:/export/install/sparc/os/latest/Solaris_9/boot \
 install=haydn:/export/install/sparc/os/8.1/latest boottype=:in \
 install_config=haydn:/usr/local/share/lib/jump-net \
 ns=otis:nisplus(255.255.255.0) term=:xterms domain=eu.cte.work.com
/etc/bootparams
rpc.bootparamd(1M), sysidtool(1M), nsswitch.conf(4)
Solaris diskless clients use the keywords root and rootopts to look up the pathname for the root filesystem and the
mount options for the root filesystem, respectively. These are the only keywords meaningful for diskless booting
clients. See mount_ufs(1M).
border_set.3xcurses <beginning of page>
border_set, box_set, wborder_set <-> use complex characters (and renditions) to draw borders
cc [ flag... ] file... -I /usr/xpg4/include -L /usr/xpg4/lib \
 -R /usr/xpg4/lib -lcurses [ library... ]
c89 [ flag... ] file... -lcurses [ library... ]
#include <curses.h>
int border_set(const cchar_t *ls, const cchar_t *rs, const cchar_t *ts,
 const cchar_t *bs, const cchar_t *tl, const cchar_t *tr,
 const cchar_t *bl,const cchar_t *br);
int wborder_set(WINDOW *win, const cchar_t *ls, const cchar_t *rs,
 const cchar_t *ts,const cchar_t *bs, const cchar_t *tl,
 const cchar_t *tr, const cchar_t *bl,const cchar_t *br);
int box_set(WINDOW *win, const cchar_t *verch, const cchar_t *horch);
The border_set() and wborder_set() functions draw a border around the specified window. All parameters must be
spacing complex characters with renditions. A parameter which is a null pointer is replaced by the default character.
Constant Values for Borders
tab() box; cw(1.83i) cw(1.83i) cw(1.83i) cw(1.83i) cw(1.83i) cw(1.83i) Constant Values for Borders _ ParameterDe<hy>
fault ConstantDefault Character _ verch WACS_VLINE| horch WACS_HLINE- lsWACS_VLINE|
rsWACS_VLINE| tsWACS_HLINE- bsWACS_HLINE- blWACS_BLCORNER+ brWACS_BRCORNER+
tlWACS_ULCORNER+ trWACS_URCORNER+
The call
 box_set(win,
 verch, horch)
is a short form for
 wborder(win,
 verch, verch,
 horch, horch, NULL,
 NULL, NULL, NULL)
When the window is boxed, the bottom and top rows and right and left columns are unavailable for text.
ls Is the character and rendition used for the left side of the border.
rs Is the character and rendition used for the right side of the border.
ts Is the character and rendition used for the top of the border.
bs Is the character and rendition used for the bottom of the border.
tl Is the character and rendition used for the top-left corner of the border.
tr Is the character and rendition used for the top-right corner of the border.
<beginning of page>
bl Is the character and rendition used for the bottom-left corner of the border.
br Is the character and rendition used for the bottom-right corner of the border.
win Is the pointer to the window in which the border or box is to be drawn.
verch Is the character and rendition used for the left and right columns of the box.
horch Is the character and rendition used for the top and bottom rows of the box.
On success, these functions return OK. Otherwise, they return ERR.
None.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelUnsafe
add_wch(3XCURSES), addch(3XCURSES), attr_get(3XCURSES), attroff(3XCURSES), border(3XCURSES),
libcurses(3XCURSES), attributes(5), standards(5)
bp_copyout.9f <beginning of page>
bp_copyout <-> copy from a driver buffer into a buf(9S)
#include <sys/types.h>
#include <sys/buf.h>
int bp_copyout(void *driverbuf, struct buf *bp, offset_t offset,
 size_t size);
Architecture independent level 1 (DDI/DKI).
bp Pointer to the buffer header structure to copy to.
driverbuf Driver buffer to copy from.
offset Offset into bp where to start copying.
size Size of copy.
The bp_copyout() function copies size bytes starting from the driver buffer driverbuf to offset bytes into the memory
associated with bp. The offset only applies to bp.
Under normal conditions, 0 is returned to indicate a successful copy. Otherwise, -1 is returned if bp references in<hy>
valid pages.
The bp_copyout() function can be called from user or kernel context only.
bp_copyin(9F), bp_mapin(9F), bp_mapout(9F), ddi_copyout(9F), buf(9S)
bp_mapout.9f <beginning of page>
bp_mapout <-> deallocate virtual address space
#include <sys/types.h>
#include <sys/buf.h>
void bp_mapout(struct buf *bp);
Architecture independent level 1 (DDI/DKI).
bp Pointer to the buffer header structure.
bp_mapout() deallocates system virtual address space allocated by a previous call to bp_mapin(9F).bp_mapout()
should only be called on buffers which have been allocated and are owned by the device driver. It must not be called
on buffers passed to the driver through the strategy(9E) entry point (for example a filesystem). Because
bp_mapin(9F) does not keep a reference count, bp_mapout() will wipe out any kernel mapping that a layer above
the device driver might rely on.
bp_mapout() can be called from user context only.
strategy(9E), bp_mapin(9F), buf(9S)
Writing Device Drivers
brands.5 <beginning of page>
brands <-> alternate operating environments for non-global zones
The branded zone (BrandZ) framework extends the Solaris Zones infrastructure described in zones(5) to include the
creation of brands, which provide non-global zones that contain non-native operating environments.
The term "brand" can refer to a wide range of operating environments. All brand management is performed as exten<hy>
sions to the current zones structure.
Every zone is configured with an associated brand. The brand type is used to determine which scripts are executed
when a zone is installed and booted. In addition, a zone's brand is used to properly identify the correct application
type at application launch time. The default brand is determined by the installed distribution in the global zone.
A branded zone will support exactly one brand of non-native binary, which means that a branded zone provides a
single operating environment. Once a zone has been assigned a brand, that brand cannot be changed or removed.
BrandZ extends the zones tools in the following ways: <bu> A brand is an attribute of a zone, set at zone create time. <bu>
The zonecfg tool (see zonecfg(1M)) is used to set a zone's brand type and configure the zone. <bu> The zoneadm tool
(see zoneadm(1M)) is used to report a zone's brand type and administer the zone.
The devices supported by each zone are documented in the man pages and other documentation for that brand. The
zones infrastructure detects any attempt to add an unsupported device and issues a warning to the administrator. If
the administrator chooses to add an unsupported device despite that warning, that device might or might not work as
expected. The configuration will be untested and unsupported.
See attributes(5) for a description of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wzoneu _ Interface StabilityEvolving
mdb(1), zlogin(1), zonename(1), dtrace(1M), in.rlogind(1M), sshd(1M), zoneadm(1M), zonecfg(1M), kill(2),
priocntl(2), getzoneid(3C), ucred_get(3C), getzoneid(3C), proc(4), attributes(5), lx(5), native(5), privileges(5),
zones(5), lx_systrace(7D), crgetzoneid(9F)
brk.2 <beginning of page>
brk, sbrk <-> change the amount of space allocated for the calling process's data segment
#include <unistd.h>
int brk(void *endds);
void *sbrk(intptr_t incr);
The brk() and sbrk() functions are used to change dynamically the amount of space allocated for the calling
process's data segment (see exec(2)). The change is made by resetting the process's break value and allocating the
appropriate amount of space. The break value is the address of the first location beyond the end of the data segment.
The amount of allocated space increases as the break value increases. Newly allocated space is set to zero. If, how<hy>
ever, the same memory space is reallocated to the same process its contents are undefined.
When a program begins execution using execve() the break is set at the highest location defined by the program and
data storage areas.
The getrlimit(2) function may be used to determine the maximum permissible size of the data segment; it is not
possible to set the break beyond the rlim_max value returned from a call to getrlimit(), that is to say, "end +
rlim.rlim_max." See end(3C).
The brk() function sets the break value to endds and changes the allocated space accordingly.
The sbrk() function adds incr function bytes to the break value and changes the allocated space accordingly. The in<hy>
cr function can be negative, in which case the amount of allocated space is decreased.
Upon successful completion, brk() returns 0. Otherwise, it returns <mi>1 and sets errno to indicate the error.
Upon successful completion, sbrk() returns the prior break value. Otherwise, it returns (void *)<mi>1 and sets errno to
indicate the error.
The brk() and sbrk() functions will fail and no additional memory will be allocated if:
ENOMEM The data segment size limit as set by setrlimit() (see getrlimit(2)) would be exceeded; the maximum
possible size of a data segment (compiled into the system) would be exceeded; insufficient space exists in the swap
area to support the expansion; or the new break value would extend into an area of the address space defined by
some previously established mapping (see mmap(2)).
EAGAIN Total amount of system memory available for private pages is temporarily insufficient. This may occur
even though the space requested was less than the maximum data segment size (see ulimit(2)).
The behavior of brk() and sbrk() is unspecified if an application also uses any other memory functions (such as
malloc(3C), mmap(2), free(3C)). The brk() and sbrk() functions have been used in specialized cases where no oth<hy>
er memory allocation function provided the same capability. The use of mmap(2) is now preferred because it can be
used portably with all other memory allocation functions and with any function that uses other allocation functions.
It is unspecified whether the pointer returned by sbrk() is aligned suitably for any purpose.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ MT-LevelMT-Safe
exec(2), getrlimit(2), mmap(2), shmop(2), ulimit(2), end(3C), free(3C), malloc(3C)
The value of incr may be adjusted by the system before setting the new break value. Upon successful completion,
the implementation guarantees a minimum of incr bytes will be added to the data segment if incr is a positive value.
If incr is a negative value, a maximum of incr bytes will be removed from the data segment. This adjustment may
not be necessary for all machine architectures.
The value of the arguments to both brk() and sbrk() are rounded up for alignment with eight-byte boundaries.
<beginning of page>
Setting the break may fail due to a temporary lack of swap space. It is not possible to distinguish this from a failure
caused by exceeding the maximum size of the data segment without consulting getrlimit().
bsdmalloc.3malloc <beginning of page>
bsdmalloc <-> memory allocator
cc [ flag ... ] file ... -lbsdmalloc [ library ... ]
char *malloc(sizeunsigned size;
int free( ptrchar *ptr;
char *realloc( ptr, sizechar *ptr;
unsigned size;
These routines provide a general-purpose memory allocation package. They maintain a table of free blocks for effi<hy>
cient allocation and coalescing of free storage. When there is no suitable space already free, the allocation routines
call sbrk(2) to get more memory from the system. Each of the allocation routines returns a pointer to space suit<hy>
ably aligned for storage of any type of object. Each returns a null pointer if the request cannot be completed.
The malloc() function returns a pointer to a block of at least size bytes, which is appropriately aligned.
The free() function releases a previously allocated block. Its argument is a pointer to a block previously allocated by
malloc() or realloc(). The free() function does not set errno.
The realloc() function changes the size of the block pointed to by ptr to size bytes and returns a pointer to the (possi<hy>
bly moved) block. The contents will be unchanged up to the lesser of the new and old sizes. If the new size of the
block requires movement of the block, the space for the previous instantiation of the block is freed. If the new size is
larger, the contents of the newly allocated portion of the block are unspecified. If ptr is NULL, realloc() behaves like
malloc() for the specified size. If size is 0 and ptr is not a null pointer, the space pointed to is freed.
The malloc() and realloc() functions return a null pointer if there is not enough available memory. They return a
non-null pointer if size is 0. These pointers should not be dereferenced. When realloc() returns NULL, the block
pointed to by ptr is left intact. Always cast the value returned by malloc() and realloc().
If malloc() or realloc() returns unsuccessfully, errno will be set to indicate the following:
ENOMEM size bytes of memory cannot be allocated because it exceeds the physical limits of the system.
EAGAIN There is not enough memory available at this point in time to allocate size bytes of memory; but the appli<hy>
cation could try again later.
Using realloc() with a block freed before the most recent call to malloc() or realloc() results in an error.
Comparative features of the various allocation libraries can be found in the umem_alloc(3MALLOC) manual page.
brk(2), malloc(3C), malloc(3MALLOC), mapmalloc(3MALLOC), umem_alloc(3MALLOC)
Use of libbsdmalloc renders an application non-SCD compliant.
The libbsdmalloc routines are incompatible with the memory allocation routines in the standard C-library (libc):
malloc(3C), alloca(3C), calloc(3C), free(3C), memalign(3C), realloc(3C), and valloc(3C).
bsearch.3c <beginning of page>
bsearch <-> binary search a sorted table
#include <stdlib.h>
void *bsearch(const void *key, const void *base, size_t nel, size_t size,
 int (*compar)(const void *,const void *));
The bsearch() function is a binary search routine generalized from Knuth (6.2.1) Algorithm B. It returns a pointer
into a table (an array) indicating where a datum may be found or a null pointer if the datum cannot be found. The ta<hy>
ble must be previously sorted in increasing order according to a comparison function pointed to by compar.
The key argument points to a datum instance to be sought in the table. The base argument points to the element at
the base of the table. The nel argument is the number of elements in the table. The size argument is the number of
bytes in each element.
The comparison function pointed to by compar is called with two arguments that point to the key object and to an ar<hy>
ray element, in that order. The function must return an integer less than, equal to, or greater than 0 if the key object is
considered, respectively, to be less than, equal to, or greater than the array element.
The bsearch() function returns a pointer to a matching member of the array, or a null pointer if no match is found.
If two or more members compare equal, which member is returned is unspecified.
The pointers to the key and the element at the base of the table should be of type pointer-to-element.
The comparison function need not compare every byte, so arbitrary data may be contained in the elements in addi<hy>
tion to the values being compared.
If the number of elements in the table is less than the size reserved for the table, nel should be the lower number.
The bsearch() function safely allows concurrent access by multiple threads to disjoint data, such as overlapping sub<hy>
trees or tables. Example 1 Examples for searching a table containing pointers to nodes.
The example below searches a table containing pointers to nodes consisting of a string and its length. The table is or<hy>
dered alphabetically on the string in the node pointed to by each entry.
This program reads in strings and either finds the corresponding node and prints out the string and its length, or
prints an error message.
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 struct node { /* these are stored in the table */
  char *string;
  int length;
 };
 static struct node table[] = { /* table to be searched */
  { "asparagus", 10 },
  { "beans", 6 },
  { "tomato", 7 },
  { "watermelon", 11 },
 };
 main()
 {
  struct node *node_ptr, node;
  /* routine to compare 2 nodes */
  static int node_compare(const void *, const void *);
  char str_space[20]; /* space to read string into */
  node.string = str_space;
  while (scanf("%20s", node.string) != EOF) {
  node_ptr = bsearch( &node,
  table, sizeof(table)/sizeof(struct node),
  sizeof(struct node), node_compare);
<beginning of page>
  if (node_ptr != NULL) {
  (void) printf("string = %20s, length = %d\n",
  node_ptr<mi>>string, node_ptr<mi>>length);
  } else {
  (void)printf("not found: %20s\n", node.string);
  }
  }
  return(0);
 }
 /* routine to compare two nodes based on an */
 /* alphabetical ordering of the string field */
 static int
 node_compare(const void *node1, const void *node2) {
  return (strcmp(
  ((const struct node *)node1)<mi>>string,
  ((const struct node *)node2)<mi>>string));
 }
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
hsearch(3C), lsearch(3C), qsort(3C), tsearch(3C), attributes(5), standards(5)
bstring.3c <beginning of page>
bstring, bcopy, bcmp, bzero <-> memory operations
#include <strings.h>
void bcopy(const void *s1, void *s2, size_t n);
int bcmp(const void *s1, const void *s2, size_t n);
void bzero(void *s, size_t n);
The bcopy(), bcmp(), and bzero() functions operate as efficiently as possible on memory areas (arrays of bytes
bounded by a count, not terminated by a null character). They do not check for the overflow of any receiving
memory area. These functions are similar to the memcpy(), memcmp(), and memset() functions described on the
memory(3C) manual page.
The bcopy() function copies n bytes from memory area s1 to s2. Copying between objects that overlap will take
place correctly.
The bcmp() function compares the first n bytes of its arguments, returning 0 if they are identical and 1 otherwise.
The bcmp() function always returns 0 when n is 0.
The bzero() function sets the first n bytes in memory area s to 0.
The bcopy() function takes parameters backwards from memcmp(). See memory(3C).
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe
memory(3C), attributes(5), standards(5)
btop.9f <beginning of page>
btop <-> convert size in bytes to size in pages (round down)
#include <sys/ddi.h>
unsigned long btop(unsigned long numbytes);
Architecture independent level 1 (DDI/DKI).
numbytes Number of bytes.
The btop() function returns the number of memory pages that are contained in the specified number of bytes, with
downward rounding in the case that the byte count is not a page multiple. For example, if the page size is 2048, then
btop(4096) returns 2, and btop(4097) returns 2 as well. btop(0) returns 0.
The return value is always the number of pages. There are no invalid input values, and therefore no error return val<hy>
ues.
The btop() function can be called from user, interrupt, or kernel context.
btopr(9F), ddi_btop(9F), ptob(9F)
Writing Device Drivers
btowc.3c <beginning of page>
btowc <-> single-byte to wide-character conversion
#include <stdio.h>
#include <wchar.h>
wint_t btowc(int c);
The btowc() function determines whether c constitutes a valid (one-byte) character in the initial shift state.
The behavior of this function is affected by the LC_CTYPE category of the current locale. See environ(5).
The btowc() function returns WEOF if c has the value EOF or if (unsigned char)c does not constitute a valid
(one-byte) character in the initial shift state. Otherwise, it returns the wide-character representation of that character.
No errors are defined.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Standard _ MT-LevelMT-Safe with exceptions
setlocale(3C), wctob(3C), attributes(5), environ(5), standards(5)
The btowc() function can be used safely in multithreaded applications, as long as setlocale(3C) is not being called to
change the locale.
